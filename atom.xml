<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Network-oriented programming]]></title>
  <link href="http://networkop.github.io/atom.xml" rel="self"/>
  <link href="http://networkop.github.io/"/>
  <updated>2016-09-07T13:40:40-07:00</updated>
  <id>http://networkop.github.io/</id>
  <author>
    <name><![CDATA[Michael Kashin]]></name>
    <email><![CDATA[mmkashin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Automating the Build of OpenStack Lab (Part 2)]]></title>
    <link href="http://networkop.github.io/blog/2016/09/09/os-lab-p2/"/>
    <updated>2016-09-09T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2016/09/09/os-lab-p2</id>
    <content type="html"><![CDATA[<p>In this post we&rsquo;ll use Chef, unnumbered BGP and Cumulus VX to build a massively scalable &ldquo;Lapukhov&rdquo; Leaf-Spine data centre.</p>

<!--more-->


<hr />

<p>In the <a href="http://networkop.github.io/blog/2016/08/26/os-lab-p1/">last post</a> we&rsquo;ve seen how to use Chef to automate the build of a 3-node OpenStack cloud. The only thing remaining is to build an underlay network supporting communication between the nodes, which is what we&rsquo;re going to do next. The build process will, again, be relatively simple and will include only a few manual steps, but before we get there let me go over some of the decisions and assumptions I&rsquo;ve made in my network design.</p>

<h2>High-level design</h2>

<p>The need to provide more bandwidth for East-West traffic has made the Clos Leaf-Spine architecture a de facto standard in any data centre network design. The use of virtual overlay networks has obviated the requirement to have a strict VLAN and IP numbering schemes in the underlay. The only requirement for the compute nodes now is to have any-to-any layer 3 connectivity. This is how the underlay network design has converged to a Layer 3 Leaf-Spine architecture.<br/>
The choice of a routing protocol is not so straight-forward. My fellow countryman Petr Lapukhov and co-authors of <a href="https://tools.ietf.org/html/draft-ietf-rtgwg-bgp-routi3ng-large-dc-11">RFC draft</a> claim that having a single routing protocol in your WAN and DC reduces complexity and makes interoperability and operations a lot easier. This draft presents some of the design principles that can be used to build a L3 data centre with BGP as the only routing protocol. In our lab we&rsquo;re going to implement a single &ldquo;cluster&rdquo; of the multi-tier topology proposed in that RFC.</p>

<p><img class="center" src="http://networkop.github.io/images/os-lab-chef-full.png"></p>

<p>In order to help us build this in an automated and scalable way, we&rsquo;re going to use a relatively new feature called <strong>unnumbered BGP</strong>.</p>

<h2>Unnumbered BGP as a replacement for IGP</h2>

<p>As we all know, one of the main advantages of interior gateway protocols is the automatic discovery of adjacent routers which is accomplished with the help of link-local multicasts. On the other hand, BGP traditionally required you to explicitly define neighbor&rsquo;s IP address in order to establish a peering relationship with it. This is where IPv6 comes to the rescue. With the help of neighbor discovery protocol and router advertisement messages, it becomes possible to accurately determine the address of the peer BGP router on an intra-fabric link. The only question is how we would exchange IPv4 information over and IPv6-only BGP network.<br/>
<a href="https://tools.ietf.org/html/rfc5549">RFC 5549</a>, described an &ldquo;extended nexthop encoding capability&rdquo; which allows BGP to exchange routing updates with nexthops that don&rsquo;t belong to the address family of the adveritised prefix. In plain English it means that BGP is now capable of advertising an IPV4 prefix with an IPv6 nexthop. This makes it possible to configure all transit links inside the Clos fabric with IPv6 link-local addresses and still maintain reachability between the edge IPv4 host networks. Since nexthop IPs will get updated at every hop, there is no need for an underlying IGP to distribute them between all BGP routers. What we see is, effectively, BGP <strong>absorbing</strong> the functions of an IGP protocol inside the data centre.</p>

<h2>Configuration example on Cumulus VX</h2>

<p>In order to implement BGP unnumbered on Cumulus Linux all you need to is:</p>

<ol>
<li>Enable IPv6 router advertisements on all transit links</li>
<li>Enable BGP on the same interfaces</li>
</ol>


<p>Example Quagga configuration snippet will look like this:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>interface swp1
</span><span class='line'>  ipv6 nd ra-interval 5
</span><span class='line'>  no ipv6 nd suppress-ra
</span><span class='line'>
</span><span class='line'>rouer bgp &lt;ASN&gt;
</span><span class='line'>  neighbor swp1 interface
</span><span class='line'>  neighbor swp1 external
</span></code></pre></td></tr></table></div></figure>


<p>As you can see, Cumulus simplifies it even more by allowing you to only specify the BGP peering type (external/internal) and learning the value of peer BGP AS dynamically from a neighbor.</p>

<h2>Design assumptions and caveats</h2>

<p>With all the above in mind, this is the list of decisions I&rsquo;ve made while building the fabric configuration:</p>

<ul>
<li>All switches inside the fabric will be running BGP peerings using <strong>IPv6 link-local</strong> addresses</li>
<li><strong>eBGP</strong> will be used throughout to simplify configuration automation (all peers will be external)</li>
<li>Each Leaf/Spine switch will have a <strong>unique IPv4 loopback</strong> address assigned for management purposes (ICMP, SSH)</li>
<li>On each Leaf switch <strong>all directly connected IPv4</strong> prefixes will get redistributed into BGP</li>
<li>BGP multipath rule will be &ldquo;relaxed&rdquo; to allow for different AS-PATHs. This is not used in our current topology but is required in an HA Leaf switch design (same IPv4 prefix will be advertised from two Leaf switches with different ASN)</li>
<li>Loop prevention on Leaf switches will also be &ldquo;relaxed&rdquo;. This, again, is not used in our single &ldquo;cluster&rdquo; topology, however it will allow same Leaf ASNs to be reused in a different cluster.</li>
</ul>


<h2>Implementation steps</h2>

<p>Picking up where we left off after the OpenStack node provisioning described in the <a href="http://networkop.github.io/blog/2016/08/26/os-lab-p1/">previous post</a></p>

<ol>
<li><p>Get the latest <a href="https://github.com/networkop/chef-unl-os">OpenStack lab cookbooks</a></p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    git clone <a href="https://github.com/networkop/chef-unl-os.git">https://github.com/networkop/chef-unl-os.git</a>
</span><span class='line'>    <span class="nb">cd </span>chef-unl-os
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p><a href="https://cumulusnetworks.com/cumulus-vx/">Download</a> and import Cumulus VX image similar to how it&rsquo;s described <a href="http://www.unetlab.com/2015/06/adding-cisco-asav-images/">here</a>.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    /opt/unetlab/addons/qemu/cumulus-vx/hda.qcow2
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Build the topology inside UNL. Make sure that Node IDs inside UNL match the ones in <strong>chef-unl-os/environment/lab.rb</strong> file and that interfaces are connected as shown in the diagram below</p>

<p> <img class="center" src="http://networkop.github.io/images/os-lab-unl.png"></p></li>
<li><p>Re-run UNL self-provisioning cookbook to create a <a href="https://github.com/networkop/chef-unl-os/blob/master/cookbooks/pxe/templates/ztp.erb">zero touch provisioning</a> file and update DHCP server configuration with static entries for the switches.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    chef-client -z -E lab -o pxe
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  Cumulus <a href="https://docs.cumulusnetworks.com/display/DOCS/Zero+Touch+Provisioning+-+ZTP">ZTP</a> allows you to run a predefined script on the first boot of the operating system. In our case we inject a UNL VM&rsquo;s public key and enable passwordless <strong>sudo</strong> for cumulus user.</p></li>
<li><p>Kickoff Chef provisioning to bootstrap and configure the DC fabric.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    chef-client -z -E lab fabric.rb
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  This command instructs Chef provisioning to connect to each switch, download and install the Chef client and run a simple recipe to create quagga configuration file from a template.</p></li>
</ol>


<p>At the end of step 5 we should have a fully functional BGP-only fabric and all 3 compute nodes should be able to reach each other in at most 4 hops.</p>

<figure class='code'><figcaption><span>[root@controller-1 ~]# traceroute 10.0.0.4</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>traceroute to 10.0.0.4 <span class="o">(</span>10.0.0.4<span class="o">)</span>, <span class="m">30</span> hops max, <span class="m">60</span> byte packets
</span><span class='line'> <span class="m">1</span>  10.0.0.1 <span class="o">(</span>10.0.0.1<span class="o">)</span>  0.609 ms  0.589 ms  0.836 ms
</span><span class='line'> <span class="m">2</span>  10.255.255.7 <span class="o">(</span>10.255.255.7<span class="o">)</span>  0.875 ms  2.957 ms  3.083 ms
</span><span class='line'> <span class="m">3</span>  10.255.255.6 <span class="o">(</span>10.255.255.6<span class="o">)</span>  3.473 ms  5.486 ms  3.147 ms
</span><span class='line'> <span class="m">4</span>  10.0.0.4 <span class="o">(</span>10.0.0.4<span class="o">)</span>  4.231 ms  4.159 ms  4.115 ms
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automating the Build of OpenStack Lab (Part 1)]]></title>
    <link href="http://networkop.github.io/blog/2016/08/26/os-lab-p1/"/>
    <updated>2016-08-26T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2016/08/26/os-lab-p1</id>
    <content type="html"><![CDATA[<p>In this post we will explore what&rsquo;s required to perform a zero-touch deployment of an OpenStack cloud. We&rsquo;ll get a 3-node lab up and running inside UNetLab with just a few commands.</p>

<!--more-->


<hr />

<p>Now that I&rsquo;m finally beginning to settle down at my new place of residence I can start spending more time on research and blogging. I have left off right before I was about to start exploring the native OpenStack distributed virtual routing function. However as I&rsquo;d started rebuilding my OpenStack lab from scratch I realised that I was doing a lot of repetitive tasks which can be easily automated. Couple that with the fact that I needed to learn Chef for my new work and you&rsquo;ve got this blogpost describing a few Chef <a href="https://github.com/networkop/chef-unl-os.git">cookbooks</a> (similar to Ansible&rsquo;s playbook) automating all those manual steps described in my earlier blogposts <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">1</a> and <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">2</a>.<br/>
In addition to that in this post I&rsquo;ll show how to build a very simple OpenStack baremetal provisioner and installer. Some examples of production-grade baremetal provisioners are <a href="https://wiki.openstack.org/wiki/Ironic">Ironic</a>, <a href="http://crowbar.github.io/">Crowbar</a> and <a href="http://maas.io/">MAAS</a>. In our case we&rsquo;ll turn UNetLab VM into an <strong>undercloud</strong>, a server used to provision and deploy our OpenStack lab, an <strong>overcloud</strong>. To do that we&rsquo;ll first install and configure DHCP, TFTP and Apache servers to PXE-boot our UNL OpenStack nodes. Once all the nodes are bootstrapped, we&rsquo;ll use Chef to configure the server networking and kickoff the packstack OpenStack installer.</p>

<p><img class="center" src="http://networkop.github.io/images/os-lab-chef.png"></p>

<p>In this post I&rsquo;ll try to use Chef recipes that I&rsquo;ve written as much as possible, therefore you won&rsquo;t see the actual configuration commands, e.g. how to configure Apache or DHCP servers. However I will try to describe everything that happens at each step and hopefully that will provide enough incentive for the curious to look into the Chef code and see how it&rsquo;s done. To help with the Chef code understanding let me start with a brief overview of what to look for in a cookbook.</p>

<h2>How to read a Chef cookbook (Optional)</h2>

<p>A cookbook directory (<strong>/cookbooks/[cookbook_name]</strong>) contains all its configuration scripts in <strong>/recipes</strong>. Each file inside a recipe contains a list of steps to be performed on a server. Each step is an operation (add/delete/update) on a <strong>resource</strong>. Here are some of the common Chef resources:</p>

<ul>
<li>Package - allows you to add, remove or update a package</li>
<li>Template - creates a file from an <strong>erb</strong>-formatted template</li>
<li>Execute - runs an ad-hoc CLI command</li>
</ul>


<p>Just these three basic resources allow you to do 95% of administrative tasks on any server. Most importantly they do it in platform-independent (any flavour of Linux) and idempotent (only make changes if current state is different from a desired state) way. Other directories you might want to explore are:</p>

<ul>
<li>/templates - contains all the <strong>erb</strong>-formatted templates</li>
<li>/attributes - contains recipe variables (file paths, urls etc.)</li>
<li>/files - contains the non-template files, i.e. files with static content</li>
</ul>


<h2>Bootstrapping the OpenStack nodes</h2>

<ol>
<li><p>If you haven&rsquo;t done it yet, download a copy of the <strong>UNetLab VM</strong> from the <a href="http://www.unetlab.com/">official website</a>. Set it up inside your hypervisor so that you can access Internet through the first interface <strong>pnet0</strong> (i.e. connect the first NIC of the VM to hypervisor&rsquo;s NAT interface). Make sure the VM has got at least 6GB of RAM and VT-x support enabled for nested virtualization.</p></li>
<li><p>Follow the official <a href="https://downloads.chef.io/chef-dk/">installation instructions</a> to <strong>install Chef Development Kit</strong> inside UNetLab VM.</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   wget <a href="https://packages.chef.io/stable/ubuntu/12.04/chefdk_0.16.28-1_amd64.deb">https://packages.chef.io/stable/ubuntu/12.04/chefdk_0.16.28-1_amd64.deb</a>
</span><span class='line'>   dpkg -i chefdk_0.16.28-1_amd64.deb
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p><strong>Install git</strong> and clone <a href="https://github.com/networkop/chef-unl-os.git">chef cookbooks</a>.</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   apt-get -y update
</span><span class='line'>   apt-get -y install git
</span><span class='line'>   git clone <a href="https://github.com/networkop/chef-unl-os.git">https://github.com/networkop/chef-unl-os.git</a>
</span><span class='line'>   <span class="nb">cd </span>chef-unl-os
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Examine the lab <strong>environment settings</strong> to see what values are going to be used. You can modify that file to your liking.</p>

<blockquote><p>Note that the OpenStack node IDs (keys of <em>os_lab</em> hash) MUST have one to one correspondence with the UNL node IDs which will be created at step 5</p></blockquote>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   cat environment/lab.rb
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Run Chef against a local server to setup the <strong>baremetal provisioner</strong>. This step installs and configures DHCP, TFTP and Apache servers. It also creates all the necessary PXE-boot and kickstart files based on our environment settings. Note that a part of the process is the download of a 700MB CentOS image so it might take a while to complete.</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   chef-client -z -E lab -o pxe
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p> At the start of the PXE-boot process, DCHP server sends an OFFER which, along with the standard IP information, includes the name of the PXE boot image and the IP address of TFTP server where to get it from. A server loads this image and then searches the TFTP server for the boot configuration file which tells it what kernel to load and where to get a kickstart file. Both kickstart and the actual installation files are accessed via HTTP and served by the same Apache server that runs UNL GUI.</p></li>
<li><p>From <strong>UNL GUI</strong> create a new lab, add 3 OpenStack nodes and connect them all to <strong>pnet10</strong> interface as described in <a href="http://www.unetlab.com/2014/11/using-cloud-devices/">this guide</a>. Note that the <strong>pnet10</strong> interface has already been created by Chef so you don&rsquo;t have to re-create it again.</p>

<blockquote><p>Make sure that the UNL node IDs match the ones defined in the environment setting file</p></blockquote></li>
<li><p>Fire-up the nodes and watch them being bootstrapped by our UNL VM.</p></li>
</ol>


<h2>Server provisioning</h2>

<p>Next step is to configure the server networking and kickoff the OpenStack installer. These steps will also be done with a single command:</p>

<p>   <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   chef-client -z -E lab lab.rb
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>
The first part of this script will connect to each prospective OpenStack node and setup its network interfaces and hostnames. The second part of this script will generate a packstack answer file and modify its settings to exclude some of the components we&rsquo;re not going to use (like Nagios, Ceph and Ceilometer). Have a look at <strong>cookbooks/packstack/recipe/default.rb</strong> for the list of modifications. The final step is a command to kickoff the packstack installer which will use another configuration management system, Puppet, to install and configure OpenStack according to the provided answer file.</p>

<p>At the end of these steps you should have a fully functional 3-node OpenStack environment.</p>

<h2>To be continued&hellip;</h2>

<p>This is a part of a 2-post series. In the next post we&rsquo;ll look into how to use the same tools to perform the baremetal provisioning of our physical underlay network.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStack SDN - Interconnecting VMs and Physical Devices With Cumulus VX L2 Gateway]]></title>
    <link href="http://networkop.github.io/blog/2016/05/21/neutron-l2gw/"/>
    <updated>2016-05-21T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2016/05/21/neutron-l2gw</id>
    <content type="html"><![CDATA[<p>One of the basic function of any data centre network is the ability to communicate with baremetal servers. In this post we&rsquo;ll see how Neutron L2 Gateway plugin can be used to configure a Cumulus VX switch for VXLAN-VLAN bridging.</p>

<!--more-->


<p>Since I have all my OpenStack environment running inside UNetLab, it makes it really easy for me to extend my L3 fabric with a switch from another vendor. In my previous posts I&rsquo;ve used <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">Cisco</a> and <a href="http://networkop.github.io/blog/2016/05/11/neutron-routed-extnet/">Arista</a> switches to build a 4-leaf 2-spine CLOS fabric. For this task I&rsquo;ve decided to use a Cumulus VX switch which I&rsquo;ve <a href="https://cumulusnetworks.com/cumulus-vx/">downloaded</a> and imported into my lab.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-l2gw-overview.png"></p>

<p>To simulate the baremetal server (10.0.0.100) I&rsquo;ve VRF&rsquo;d an interface on Arista &ldquo;L4&rdquo; switch and connected it directly to a &ldquo;swp3&rdquo; interface of the Cumulus VX. This is not shown on the diagram.</p>

<h2>Solution overview</h2>

<p><a href="https://wiki.openstack.org/wiki/Neutron/L2-GW">L2 Gateway</a> is a relatively <a href="https://github.com/openstack/networking-l2gw/releases">new</a> service plugin for OpenStack Neutron.  It provides the ability to interconnect a given tenant network with a VLAN on a physical switch. There are three main components that compose this solution:</p>

<ul>
<li><strong>Hardware switch</strong> implementing the OVSDB hardware vtep schema. This is a special &ldquo;flavour&rdquo; of OVSDB designed specifically to enable connectivity between logical (VXLAN VTEP) and physical (switchport) interfaces.</li>
<li><strong>L2GW agent</strong> running on a network node. This is the process responsible for connecting to OVSDB server running on a hardware switch and updating that database based on instructions received from a L2GW service plugin.</li>
<li><strong>L2GW Service Plugin</strong> residing on a control node. The task of this plugin is to notify the L2GW agent and normal L2 OVS agents running on compute hosts about network events and distribute VTEP IP address information between them.</li>
</ul>


<p>Note that in our case both network and control nodes are running on the same VM.</p>

<h2>Cumulux VX configuration</h2>

<p>Cumulux is a debian-based linux distribution, therefore most of the basic networking configuration will be similar to how things are done in Ubuntu. First, let&rsquo;s start by configuring basic IP addressing on Loopback (VTEP IP), Eth0 (OOB management), swp1 and swp2 (fabric) interfaces.</p>

<figure class='code'><figcaption><span>/etc/network/interfaces</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>iface lo inet loopback
</span><span class='line'>        address 10.0.0.5/32
</span><span class='line'>
</span><span class='line'>auto eth0
</span><span class='line'>iface eth0 inet static
</span><span class='line'>        address 192.168.91.21/24
</span><span class='line'>
</span><span class='line'>auto swp1
</span><span class='line'>iface swp1 inet static
</span><span class='line'>        address 169.254.51.5/24
</span><span class='line'>
</span><span class='line'>auto swp2
</span><span class='line'>iface swp2 inet static
</span><span class='line'>        address 169.254.52.5/24
</span><span class='line'>
</span><span class='line'>auto swp3
</span><span class='line'>iface swp3
</span></code></pre></td></tr></table></div></figure>


<p>Next, let&rsquo;s enable OSPF</p>

<figure class='code'><figcaption><span>Enable OSPF process</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo sed -i s/zebra<span class="o">=</span>no/zebra<span class="o">=</span>yes/ /etc/quagga/daemons
</span><span class='line'>sudo sed -i s/ospfd<span class="o">=</span>no/ospfd<span class="o">=</span>yes/ /etc/quagga/daemons
</span><span class='line'>sudo service quagga restart
</span></code></pre></td></tr></table></div></figure>


<p>Once OSPFd is running, we can use <code>sudo vtysh</code> to connect to local quagga shell and finalise the configuration.</p>

<figure class='code'><figcaption><span>show run</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>interface lo
</span><span class='line'> ip ospf area 0.0.0.0
</span><span class='line'> link-detect
</span><span class='line'>!
</span><span class='line'>interface swp1
</span><span class='line'> ip ospf area 0.0.0.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> link-detect
</span><span class='line'>!
</span><span class='line'>interface swp2
</span><span class='line'> ip ospf area 0.0.0.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> link-detect
</span><span class='line'>!
</span><span class='line'>router ospf
</span><span class='line'> ospf router-id 10.0.0.5
</span><span class='line'> passive-interface default
</span><span class='line'> no passive-interface swp1
</span><span class='line'> no passive-interface swp2
</span></code></pre></td></tr></table></div></figure>


<p>At this stage our Cumulus VX switch should be fully adjacent to both spines and its loopback IP (10.0.0.5) should be reachable from all OpenStack nodes.</p>

<p>The final step is to enable the hardware VTEP functionality. The <a href="https://docs.cumulusnetworks.com/display/CL22/Integrating+Hardware+VTEPs+with+Midokura+MidoNet+and+OpenStack">process</a> is fairly simple and involves only a few commands.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sudo sed -i s/START<span class="o">=</span>no/START<span class="o">=</span>yes/g /etc/default/openvswitch-vtep
</span><span class='line'><span class="nv">$ </span>sudo service openvswitch-vtep start
</span><span class='line'><span class="nv">$ </span>sudo vtep-bootstrap L5 10.0.0.5 192.168.91.21 --no_encryption
</span></code></pre></td></tr></table></div></figure>


<p>The last command runs a bootstrap script that does the following things:</p>

<ul>
<li>Creates a hardware VTEP OVSDB schema</li>
<li>Inside that schema creates a new physical switch called &ldquo;L5&rdquo;</li>
<li>Sets the VTEP IP to 10.0.0.5</li>
<li>Starts listening to incoming OVSDB connections on 192.168.91.21</li>
</ul>


<h2>Hardware VTEP vs OpenvSwitch OVSDB schemas (Optional)</h2>

<p>By now you&rsquo;re probably wondering what&rsquo;s that hardware VTEP OVSDB schema and how it&rsquo;s different from a normal OVS schema. First of all, remember that <a href="https://tools.ietf.org/html/rfc7047">OVSDB</a> is just a database and OVSDB protocol is just a set of JSON RPC calls to work with that database. Information that can be stored in the database is defined by a schema - a structure that represents tables and their relations. Therefore, OVSDB can be used to store and manage <a href="https://twitter.com/ben_pfaff/status/453333818653417472">ANY</a> type of data which makes it very flexible. Specificallly OVS project defines two OVSDB schemas:</p>

<ul>
<li><strong><a href="http://openvswitch.org/ovs-vswitchd.conf.db.5.pdf">Open_vSwitch schema</a></strong> - used to manage bridges, ports and controllers of OpenvSwitch. This schema is used by OVS inside every compute host we have in our OpenStack environment.</li>
<li><strong><a href="http://openvswitch.org/docs/vtep.5.pdf">Hardware_vtep schema</a></strong> - designed to be used by physical switches. The goal of this schema is to extend the virtual L2 switch into a physical realm by providing the ability to map physical ports to logical networks. For each logical network the hardware VTEP database holds mappings of MAC addresses to VTEPs and physical switchport.</li>
</ul>


<p>The information from these databases is later consumed by another process that sets up the actual bridges and ports. The first schema is used by the <strong>ovs-vswitchd</strong> process running on all compute hosts to configure ports and flows of integration and tunnel bridges. In case of a Cumulus switch, the information from <strong>hardware_vtep</strong> OVSDB is used by a process called <strong>ovs-vtepd</strong> that is responsible for settings up VXLAN VTEP interfaces, provisioning of VLANs on physical switchports and interconnecting them with a Linux bridge.</p>

<p>If you want to learn more, check out this <a href="http://www.relaxdiego.com/2014/09/hardware_vtep.html">awesome post</a> about hardware VTEP and OVS.</p>

<h2>OpenStack Control node configuration</h2>

<p>Most of the following procedure has been borrowed from <a href="http://kimizhang.com/neutron-l2-gateway-hp-5930-switch-ovsdb-integration/">another blog</a>. It&rsquo;s included it this post because I had to do some modifications and also for the sake of completeness.</p>

<ol>
<li><p>Clone the L2GW repository</p>

<pre><code class="`"> git clone -b stable/mitaka https://github.com/openstack/networking-l2gw.git
</code></pre></li>
<li><p>Use pip to install the plugin</p>

<pre><code class="`"> pip install ./networking-l2gw/
</code></pre></li>
<li><p>Enable the L2GW service plugin</p>

<pre><code class="`"> sudo sed -ri 's/^(service_plugins.*)/\1,networking_l2gw.services.l2gateway.plugin.L2GatewayPlugin/' \
 /etc/neutron/neutron.conf
</code></pre></li>
<li><p>Copy L2GW configuration files into the neutron configuration directory</p>

<pre><code class="`"> cp  /usr/etc/neutron/l2g* /etc/neutron/
</code></pre></li>
<li><p>Point the L2GW plugin to our Cumulus VX switch</p>

<pre><code class="`"> sudo sed -ri "s/^#\s+(ovsdb_hosts).*/\1 = 'ovsdb1:192.168.91.21:6632'/" /etc/neutron/l2gateway_agent.ini
</code></pre></li>
<li><p>Update Neutron database with the new schema required by L2GW plugin</p>

<pre><code class="`"> systemctl stop neutron-server
 neutron-db-manage --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/l2gw_plugin.ini  upgrade head
 systemctl start neutron-server
</code></pre></li>
<li><p>Update Neutron startup script to load the L2GW plugin configuration file</p>

<pre><code class="`"> sed -ri "s/(ExecStart=.*)/\1 --config-file \/etc\/neutron\/l2gw_plugin.ini /" /usr/lib/systemd/system/neutron-server.service
</code></pre></li>
<li><p>Create a L2GW systemd unit file</p>

<pre><code class="`"> cat &gt;&gt; /usr/lib/systemd/system/neutron-l2gateway-agent.service &lt;&lt; EOF
 [Unit]
 Description=OpenStack Neutron L2 Gateway Agent
 After=neutron-server.service

 [Service]
 Type=simple
 User=neutron
 ExecStart=/usr/bin/neutron-l2gateway-agent --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/l2gateway_agent.ini
 KillMode=process

 [Install]
 WantedBy=multi-user.target
 EOF
</code></pre></li>
<li><p>Restart both L2GW and neutron server</p>

<pre><code class="`"> systemctl daemon-reload
 systemctl restart neutron-server.service
 systemctl start neutron-l2gateway-agent.service  
</code></pre></li>
<li><p>Enter the &ldquo;neutron configuration mode&rdquo;</p>

<pre><code>source ~/keystone_admin
neutron
</code></pre></li>
<li><p>Create a new L2 gateway device</p>

<pre><code>l2-gateway-create --device name="L5",interface_names="swp3" CUMULUS-L2GW
</code></pre></li>
<li><p>Create a connection between a &ldquo;private_network&rdquo; and a native vlan (dot1q 0) of swp3 interface</p>

<pre><code>l2-gateway-connection-create --default-segmentation-id 0 CUMULUS-L2GW private_network
</code></pre></li>
</ol>


<h2>Verification and Traffic Flows</h2>

<p>At this stage everything should be ready for testing. We&rsquo;ll start by examining the following traffic flow:</p>

<ul>
<li>From VM-2 10.0.0.4/fa:16:3e:d7:0e:14</li>
<li>To baremetal server 10.0.0.100/50:00:00:6b:2e:70</li>
</ul>


<p><img class="center" src="http://networkop.github.io/images/neutron-l2gw-detailed.png"></p>

<p>The communication starts with VM-2 sending an ARP request for the MAC address of the baremetal server. Packet flow inside the compute host will be exactly the same <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">as before</a>, with packet being flooded from the VM to the integration and tunnel bridges. Inside the tunnel bridge the packet gets resubmitted to table 22 where head-end replication of ARP request takes place.</p>

<p>The only exception is that this time the frame will get replicated to a new VXLAN port pointing towards the Cumulux VTEP IP. We&rsquo;ll use the <code>ovs-appctl ofproto/trace</code> command to see the full path a packet takes inside OVS, which is similar to <code>packet-tracer</code> command of Cisco ASA. To simulate an ARP packet we need to specify the incoming port(in_port), EtherType(arp), internal VLAN number for our tenant(dl_vlan) and an ARP request target IP address(arp_tpa). You can find the full list of fields that can be matched in <a href="http://openvswitch.org/support/dist-docs/ovs-ofctl.8.txt">this document</a>.</p>

<figure class='code'><figcaption><span>ARP request to the baremetal server</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-appctl ofproto/trace br-tun <span class="nv">in_port</span><span class="o">=</span>1,arp,dl_vlan<span class="o">=</span>1,arp_tpa<span class="o">=</span>10.0.0.100 <span class="p">|</span> grep -E <span class="s2">&quot;Rule|actions=&quot;</span>
</span><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>1
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">2</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">20</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">priority</span><span class="o">=</span>0
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,22<span class="o">)</span>
</span><span class='line'>                        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">22</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">dl_vlan</span><span class="o">=</span>1
</span><span class='line'>                        OpenFlow <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x45,output:9,output:4,output:6
</span></code></pre></td></tr></table></div></figure>


<p>The packet leaving port 9 will get encapsulated into a VXLAN header with destination IP of 10.0.0.5 and forwarded out the fabric-facing interface eth1.100. When VXLAN packet reaches the <strong>vxln69</strong> interface (10.0.0.5) of the Cumulus switch, the <strong>br-vxlan69</strong> Linux bridge floods the frame out the second connected interface - <strong>swp3</strong>.</p>

<figure class='code'><figcaption><span>brctl show br-vxln69</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>bridge name        bridge id          STP enabled     interfaces
</span><span class='line'>br-vxln69          8000.500000070003  no              swp3
</span><span class='line'>                                                      vxln69
</span></code></pre></td></tr></table></div></figure>


<p>The rest of the story is very simple. When ARP packet hits the baremetal server it populates its ARP cache. A unicast response travels all the way back to the Cumulus switch, gets matched by the static MAC (0e:14) entry created based on information provided by the L2GW plugin. This entry points to the VTEP IP of Compute host 2(10.0.2.10) which is where it gets forwarded next.</p>

<figure class='code'><figcaption><span>bridge fdb show</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>50:00:00:09:00:04 dev swp3 vlan <span class="m">0</span> master br-vxln69
</span><span class='line'>50:00:00:07:00:03 dev swp3 vlan <span class="m">0</span> master br-vxln69 permanent
</span><span class='line'>50:00:00:6b:2e:70 dev swp3 vlan <span class="m">0</span> master br-vxln69
</span><span class='line'>26:21:90:a8:8a:cc dev vxln69 vlan <span class="m">0</span> master br-vxln69 permanent
</span><span class='line'>fa:16:3e:57:1c:6c dev vxln69 dst 10.0.3.10 vlan <span class="m">65535</span> self permanent
</span><span class='line'>fa:16:3e:a4:12:e6 dev vxln69 dst 10.0.3.10 vlan <span class="m">65535</span> self permanent
</span><span class='line'>fa:16:3e:d7:0e:14 dev vxln69 dst 10.0.2.10 vlan <span class="m">65535</span> self permanent
</span><span class='line'>fa:16:3e:3c:51:d7 dev vxln69 dst 10.0.1.10 vlan <span class="m">65535</span> self permanent
</span></code></pre></td></tr></table></div></figure>


<p>The packet travels through compute host 2, populating the flow entries of all OVS bridges along the way. These entries are then used by subsequent unicast packets travelling from VM-2.</p>

<figure class='code'><figcaption><span>Unicast packet to the baremetal server</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-appctl ofproto/trace br-tun <span class="nv">in_port</span><span class="o">=</span>1,dl_vlan<span class="o">=</span>1,dl_dst<span class="o">=</span>50:00:00:6b:2e:70 <span class="p">|</span> grep -E <span class="s2">&quot;Rule|actions=&quot;</span>
</span><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xb5625033061a8ae5 <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>1
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">2</span> <span class="nv">cookie</span><span class="o">=</span>0xb5625033061a8ae5 <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">20</span> <span class="nv">cookie</span><span class="o">=</span>0xb5625033061a8ae5 <span class="nv">priority</span><span class="o">=</span>1,vlan_tci<span class="o">=</span>0x0001/0x0fff,dl_dst<span class="o">=</span>50:00:00:6b:2e:70
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:0x45-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:9
</span></code></pre></td></tr></table></div></figure>


<p>It all looks fine until the ARP cache of the baremetal server expires and you get an ARP request coming from the physical into the virtual world. There is a <a href="https://drive.google.com/file/d/0Bx8nDIFktlzBRm0tV3pmYURnZ3M/view">known issue</a> with BUM forwarding which requires a special <a href="http://blog.scottlowe.org/2014/02/27/learning-nsx-part-10-adding-a-service-node/">service node</a> to perform the head-end replication. The idea is that a switch that needs to flood a multicast packet, would send it to a service node which keeps track of all active VTEPs in the network and performs packet replication on behalf of the sender. OpenStack doesn&rsquo;t have a dedicated service node, however it is possible to trick the network node into performing a similar functionality, which is what I&rsquo;m going to demonstrate next.</p>

<h2>Programming Network Node as BUM replication service node</h2>

<p>First of all, we need to tell our Cumulus switch to send all multicast packets to the network node. To do that we need to modify OVSDB table called &ldquo;Mcast_Macs_Remote&rdquo;. You can view the contents of the database using the <code>ovsdb-client dump --pretty tcp:192.168.91.21:6632</code> command to make sure that this table is empty. Using the VTEP control command we need to force all <strong>unknown-dst</strong> (BUM) traffic to go to the network node(10.0.3.10). The UUID of the logical switch can be found with <code>sudo vtep-ctl list-ls</code> command.</p>

<figure class='code'><figcaption><span>Forward all BUM traffic to OpenStack network node</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo vtep-ctl add-mcast-remote 818b4779-645c-49bb-ae4a-aa9340604019 unknown-dst 10.0.3.10
</span></code></pre></td></tr></table></div></figure>


<p>At this stage all BUM traffic hits the network node and gets flooded to the DHCP and the virtual router namespaces. In order to force this traffic to also be replicated to all compute nodes we can use some of the existing tables of the tunnel bridge. Before we do anything let&rsquo;s have a look at the tables our ARP request has to go through inside the tunnel bridge.</p>

<figure class='code'><figcaption><span>Packet from Cumulus VTEP inside br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">2</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,4<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>4, <span class="nv">priority</span><span class="o">=</span>1,tun_id<span class="o">=</span>0x45 <span class="nv">actions</span><span class="o">=</span>mod_vlan_vid:1,resubmit<span class="o">(</span>,10<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>10,priority<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,cookie<span class="o">=</span>0x9f3e746b7ee48bbf,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:NXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span></code></pre></td></tr></table></div></figure>


<p>We also have a default head-end replication table 22 which floods all BUM traffic received from the integration bridge to all VTEPs:</p>

<figure class='code'><figcaption><span>BUM replication table</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>22, <span class="nv">dl_vlan</span><span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x45,output:2,output:4,output:6
</span></code></pre></td></tr></table></div></figure>


<p>So what we can do is create a new flow entry that would intercept all ARP packets inside Table 4 and resubmit them to tables 10 and 22. Table 10 will take our packet up to the integration bridge of the network node, since we still need to be able to talk the virtual router and the DHCP. Table 22 will receive a copy of the packet and flood it to all known VXLAN endpoints.</p>

<figure class='code'><figcaption><span>Manipulating OVS flows</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ovs-ofctl add-flow br-tun <span class="s2">&quot;table=4,arp,tun_id=0x45,priority=2,actions=mod_vlan_vid:1,resubmit(,10),resubmit(,22)&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can once again use the trace command to see the ARP request flow inside the tunnel bridge.</p>

<figure class='code'><figcaption><span>ARP request received from the Cumulus switch</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-appctl ofproto/trace br-tun <span class="nv">in_port</span><span class="o">=</span>2,arp,tun_id<span class="o">=</span>0x45 <span class="p">|</span> grep -E <span class="s2">&quot;Rule|actions=&quot;</span>
</span><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0x9f3e746b7ee48bbf <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>2
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,4<span class="o">)</span>
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">4</span> <span class="nv">cookie</span><span class="o">=</span><span class="m">0</span> <span class="nv">priority</span><span class="o">=</span>2,arp,tun_id<span class="o">=</span>0x45
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>mod_vlan_vid:1,resubmit<span class="o">(</span>,10<span class="o">)</span>,resubmit<span class="o">(</span>,22<span class="o">)</span>
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">10</span> <span class="nv">cookie</span><span class="o">=</span>0x9f3e746b7ee48bbf <span class="nv">priority</span><span class="o">=</span>1
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,cookie<span class="o">=</span>0x9f3e746b7ee48bbf,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:NXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span><span class='line'>                        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0x91b1a9a9b6e8d608 <span class="nv">priority</span><span class="o">=</span>0
</span><span class='line'>                        OpenFlow <span class="nv">actions</span><span class="o">=</span>NORMAL
</span><span class='line'>                                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xb36f6e358a37bea6 <span class="nv">priority</span><span class="o">=</span>2,in_port<span class="o">=</span>2
</span><span class='line'>                                OpenFlow <span class="nv">actions</span><span class="o">=</span>drop
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">22</span> <span class="nv">cookie</span><span class="o">=</span>0x9f3e746b7ee48bbf <span class="nv">dl_vlan</span><span class="o">=</span>1
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x45,output:2,output:4,output:6
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://networkop.github.io/images/neutron-l2gw-arp.png"></p>

<p>Now we should be able to clear the ARP cache on baremetal device and successfully ping both VM-2, VM-1 and the virtual router.</p>

<h2>Conclusion</h2>

<p>The workaround presented above is just a temporary solution for the problem. In order to fix the problem properly, OVS vtep schema needs to be updated to support source node replication. Luckily, the patch implementing this functionality has been <a href="https://github.com/openvswitch/ovs/commit/b351ac0c9bc270b3fff07ae8c7434c53d59b132c">merged</a> into master OVS branch only a few days ago. So hopefully, this update trickles down to Cumulus package repositories soon.</p>

<p>Despite all the issues, Neutron L2 gateway plugin is a cool project that provides a very important piece of functionality without having to rely on 3rd party SDN controllers. Let&rsquo;s hope it will continue to be supported and developed by the community.</p>

<h2>Coming up</h2>

<p>In the next post I was planning to examine another &ldquo;must have&rdquo; feature of any SDN solution - Distributed Virtual Routing. However due to my current circumstances I may need to take a few weeks' break before going on. Be back soon!</p>

<p><img class="center" src="http://networkop.github.io/images/be-back.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack SDN - Interconnecting VMs and Physical Devices With Cumulus VX L2 Gateway]]></title>
    <link href="http://networkop.github.io/blog/2016/05/18/neutron-l2gw/"/>
    <updated>2016-05-18T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2016/05/18/neutron-l2gw</id>
    <content type="html"><![CDATA[<p>One of the basic function of any data centre network is the ability to communicate with baremetal workloads. In this post we&rsquo;ll see how Neutron L2 Gateway plugin can be used to configure a Cumulus VX switch for VXLAN-VLAN bridging.</p>

<!--more-->


<p>Since I have all my OpenStack environment running inside UNetLab, it makes it really easy for me to extend my L3 fabric with a switch from another vendor. In my previous posts I&rsquo;ve used <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">Cisco</a> and <a href="http://networkop.github.io/blog/2016/05/11/neutron-routed-extnet/">Arista</a> switches to build a 4-leaf 2-spine CLOS fabric. For this task I&rsquo;ve decided to use a Cumulus VX switch which I&rsquo;ve <a href="https://cumulusnetworks.com/cumulus-vx/">downloaded</a> and imported into my lab.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-l2gw-overview.png"></p>

<p>To simulate the baremetal server (10.0.0.100) I&rsquo;ve VRF&rsquo;d an interface on Arista &ldquo;L4&rdquo; switch and connected it directly to a &ldquo;swp3&rdquo; interface of the Cumulus VX. This is not shown on the diagram.</p>

<h2>Solution overview</h2>

<p><a href="https://wiki.openstack.org/wiki/Neutron/L2-GW">L2 Gateway</a> is a relatively <a href="https://github.com/openstack/networking-l2gw/releases">new</a> service plugin for OpenStack Neutron.  It provides the ability to interconnect a given tenant network with a VLAN on a physical switch. There are three main components that comprise this solution:</p>

<ul>
<li><strong>Hardware switch</strong> implementing the OVSDB hardware vtep schema. This is a special &ldquo;flavour&rdquo; of OVSDB designed specifically to enable connectivity between logical (VXLAN VTEP) and physical (switchport) interfaces.</li>
<li><strong>L2GW agent</strong> running on a network node. This is the process responsible for connecting to OVSDB server running on a hardware switch and updating that database based on instructions received from a L2GW service plugin.</li>
<li><strong>L2GW Service Plugin</strong> residing on a control node. The task of this plugin is to notify the L2GW agent and normal L2 OVS agents running on compute hosts about network events and distribute VTEP IP address information between them.</li>
</ul>


<p>Note that in our case both network and control nodes are running on the same VM.</p>

<h2>Cumulux VX configuration</h2>

<p>Cumulux is a debian-based linux distribution, therefore most of the basic networking configuration will be similar to how things are done in Ubuntu. First, let&rsquo;s start by configuring basic IP addressing on Loopback (VTEP IP), Eth0 (OOB management), swp1 and swp2 (fabric) interfaces.</p>

<figure class='code'><figcaption><span>/etc/network/interfaces</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>iface lo inet loopback
</span><span class='line'>        address 10.0.0.5/32
</span><span class='line'>
</span><span class='line'>auto eth0
</span><span class='line'>iface eth0 inet static
</span><span class='line'>        address 192.168.91.21/24
</span><span class='line'>
</span><span class='line'>auto swp1
</span><span class='line'>iface swp1 inet static
</span><span class='line'>        address 169.254.51.5/24
</span><span class='line'>
</span><span class='line'>auto swp2
</span><span class='line'>iface swp2 inet static
</span><span class='line'>        address 169.254.52.5/24
</span><span class='line'>
</span><span class='line'>auto swp3
</span><span class='line'>iface swp3
</span></code></pre></td></tr></table></div></figure>


<p>Next, let&rsquo;s enable OSPF</p>

<figure class='code'><figcaption><span>Enable OSPF process</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo sed -i s/zebra<span class="o">=</span>no/zebra<span class="o">=</span>yes/ /etc/quagga/daemons
</span><span class='line'>sudo sed -i s/ospfd<span class="o">=</span>no/ospfd<span class="o">=</span>yes/ /etc/quagga/daemons
</span><span class='line'>sudo service quagga restart
</span></code></pre></td></tr></table></div></figure>


<p>Once OSPFd is running, we can use <code>sudo vtysh</code> to connect to local quagga shell and finalise the configuration.</p>

<figure class='code'><figcaption><span>show run</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>interface lo
</span><span class='line'> ip ospf area 0.0.0.0
</span><span class='line'> link-detect
</span><span class='line'>!
</span><span class='line'>interface swp1
</span><span class='line'> ip ospf area 0.0.0.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> link-detect
</span><span class='line'>!
</span><span class='line'>interface swp2
</span><span class='line'> ip ospf area 0.0.0.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> link-detect
</span><span class='line'>!
</span><span class='line'>router ospf
</span><span class='line'> ospf router-id 10.0.0.5
</span><span class='line'> passive-interface default
</span><span class='line'> no passive-interface swp1
</span><span class='line'> no passive-interface swp2
</span></code></pre></td></tr></table></div></figure>


<p>At this stage our Cumulus VX switch should be fully adjacent to both spines and its loopback IP (10.0.0.5) should be reachable from all OpenStack nodes.</p>

<p>The final step is to enable the hardware VTEP functionality. The <a href="https://docs.cumulusnetworks.com/display/CL22/Integrating+Hardware+VTEPs+with+Midokura+MidoNet+and+OpenStack">process</a> is faily simple and involves only a few commands.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sudo sed -i s/START<span class="o">=</span>no/START<span class="o">=</span>yes/g /etc/default/openvswitch-vtep
</span><span class='line'><span class="nv">$ </span>sudo service openvswitch-vtep start
</span><span class='line'><span class="nv">$ </span>sudo vtep-bootstrap L5 10.0.0.5 192.168.91.21 --no_encryption
</span></code></pre></td></tr></table></div></figure>


<p>The last commands runs a bootstrap script that does the following things:</p>

<ul>
<li>Creates a hardware VTEP OVSDB schema</li>
<li>Inside that schema creates a new physical switch called &ldquo;L5&rdquo;</li>
<li>Sets the VTEP IP to 10.0.0.5</li>
<li>Starts listening to incoming OVSDB connections on 192.168.91.21.</li>
</ul>


<h2>Hardware VTEP vs OpenvSwitch OVSDB schemas (Optional)</h2>

<p>By now you&rsquo;re probably wondering what&rsquo;s that hardware VTEP OVSDB schema and how it&rsquo;s different from a normal OVS schema. First of all, remember that OVSDB is just a database and the OVSDB protocol is just a set of JSON RPC <a href="https://tools.ietf.org/html/rfc7047">calls</a> to work with that database. As it is with any database, an information that can be stored in it is defined by a schema - a structure that represents tables, columns and their relations. Therefore, OVSDB can be used to store and manage <a href="https://twitter.com/ben_pfaff/status/453333818653417472">ANY</a> type of data which makes it very flexible. Specificallly OVS project defines two OVSDB schemas:</p>

<ul>
<li><strong>Open_vSwitch <a href="http://openvswitch.org/ovs-vswitchd.conf.db.5.pdf">schema</a></strong> - used to manage bridges, ports and controllers of OpenvSwitch. This schema is used by OVS inside every compute host we have in our OpenStack environment.</li>
<li><strong>Hardware_vtep <a href="http://openvswitch.org/docs/vtep.5.pdf">schema</a></strong> - designed to be used by physical switches. The goal of this schema is to extend the virtual L2 switch into a physical realm by providing the ability to map physical ports to logical networks. For each logical network the hardware VTEP database holds mappings of MAC addresses to VTEPs and physical switchport.</li>
</ul>


<p>The information from these databases is later consumed by another process that sets up the actual bridges and ports. The first schema is used by the <strong>ovs-vswitchd</strong> process running on all compute hosts to configure ports for VMs, integration and tunnel bridges and VTEP interfaces. In case of a Cumulus switch, the information from &ldquo;hardware_vtep&rdquo; OVSDB is used by a process called <strong>ovs-vtepd</strong> that is responsible for settings up VXLAN VTEP interfaces, provisioning of VLANs on physical switchports and interconnecting them with a linux bridge.</p>

<p>If you want to learn more check out this <a href="http://www.relaxdiego.com/2014/09/hardware_vtep.html">awesome post</a> about hardware VTEP and OVS.</p>

<h2>OpenStack Control node configuration</h2>

<p>Most of the following procedure has been borrowed from <a href="http://kimizhang.com/neutron-l2-gateway-hp-5930-switch-ovsdb-integration/">other blogs</a>. I included it here for the sake of completeness and also because I had to do some modifications.</p>

<ol>
<li><p>Clone the L2GW repository</p>

<pre><code class="`"> git clone -b stable/mitaka https://github.com/openstack/networking-l2gw.git
</code></pre></li>
<li><p>Use pip to install the plugin</p>

<pre><code class="`"> pip install ./networking-l2gw/
</code></pre></li>
<li><p>Enable L2GW service plugin</p>

<pre><code class="`"> sudo sed -ri 's/^(service_plugins.*)/\1,networking_l2gw.services.l2gateway.plugin.L2GatewayPlugin/' /etc/neutron/neutron.conf
</code></pre></li>
<li><p>Copy L2GW configuration files</p>

<pre><code class="`"> cp  /usr/etc/neutron/l2g* /etc/neutron/
</code></pre></li>
<li><p>Point L2GW plugin to our Cumulus VX switch</p>

<pre><code class="`"> sudo sed -ri "s/^#\s+(ovsdb_hosts).*/\1 = 'ovsdb1:192.168.91.21:6632'/" /etc/neutron/l2gateway_agent.ini
</code></pre></li>
<li><p>Update Neutron database with tables required for L2GW</p>

<pre><code class="`"> systemctl stop neutron-server
 neutron-db-manage --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/l2gw_plugin.ini  upgrade head
 systemctl start neutron-server
</code></pre></li>
<li><p>Update Neutron startup script include L2GW plugin</p>

<pre><code class="`"> sed -ri "s/(ExecStart=.*)/\1 --config-file \/etc\/neutron\/l2gw_plugin.ini /" /usr/lib/systemd/system/neutron-server.service
</code></pre></li>
<li><p>Create a L2GW systemd unit</p>

<pre><code class="`"> cat &gt;&gt; /usr/lib/systemd/system/neutron-l2gateway-agent.service &lt;&lt; EOF
 [Unit]
 Description=OpenStack Neutron L2 Gateway Agent
 After=neutron-server.service

 [Service]
 Type=simple
 User=neutron
 ExecStart=/usr/bin/neutron-l2gateway-agent --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/l2gateway_agent.ini
 KillMode=process

 [Install]
 WantedBy=multi-user.target
 EOF
</code></pre></li>
<li><p>Restart both L2GW and neutron server</p>

<pre><code class="`"> systemctl daemon-reload
 systemctl restart neutron-server.service
 systemctl start neutron-l2gateway-agent.service  
</code></pre></li>
<li><p>Enter the &ldquo;neutron configuration mode&rdquo;</p>

<pre><code>source ~/keystone_admin
neutron
</code></pre></li>
<li><p>Create a new L2GW</p>

<pre><code>l2-gateway-create --device name="L5",interface_names="swp3" CUMULUS-L2GW
</code></pre></li>
<li><p>Create a connection between a &ldquo;private_network&rdquo; and a native vlan of swp3 interface</p>

<pre><code>l2-gateway-connection-create --default-segmentation-id 0 CUMULUS-L2GW private_network
</code></pre></li>
</ol>


<h2>Verficiation and Traffic Flows</h2>

<p>At this stage everything should be ready for testing. We&rsquo;ll start by examining the traffic flow from a VM-2 (10.0.0.4) to the baremetal server (10.0.0.100).</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-l2gw-detailed.png"></p>

<p>The communication starts with VM-2 sending an ARP request for the MAC address of the baremetal server. Packet flow inside the compute host will be exactly the same <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">as before</a>, with packet being flooded from the VM to the intergration and tunnel bridges. Inside the tunnel bridge the packet gets resubmitted to table 22 where head-end replication of ARP request takes place. The only exception is that this time the frame will get replicated to a new VXLAN port pointing towards Cumulux VTEP IP. You can use the <code>ovs-appctl ofproto/trace</code> to see the full path a packet takes inside OVS, similiar to <code>packet-tracer</code> command on Cisco ASA.</p>

<figure class='code'><figcaption><span>ARP request</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-appctl ofproto/trace br-tun <span class="nv">in_port</span><span class="o">=</span>1,arp,dl_vlan<span class="o">=</span>1,arp_tpa<span class="o">=</span>10.0.0.100 <span class="p">|</span> grep -E <span class="s2">&quot;Rule|actions=&quot;</span>
</span><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>1
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">2</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">20</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">priority</span><span class="o">=</span>0
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,22<span class="o">)</span>
</span><span class='line'>                        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">22</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">dl_vlan</span><span class="o">=</span>1
</span><span class='line'>                        OpenFlow <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x45,output:9,output:4,output:6
</span></code></pre></td></tr></table></div></figure>


<p>The packet leaving port 9 will get encapsulated into a VXLAN header with destination IP of 10.0.0.5 and forwarded out the fabric-facing interface eth1.100. When VXLAN packet reaches the vxln69 interface of the Cumulus switch, the ARP frame will get forwarded to <strong>br-vxlan69</strong> Linux bridge, which will flood the frame out the connected physical interface swp3.</p>

<figure class='code'><figcaption><span>bridge fdb show</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>50:00:00:09:00:04 dev swp3 vlan <span class="m">0</span> master br-vxln69
</span><span class='line'>50:00:00:07:00:03 dev swp3 vlan <span class="m">0</span> master br-vxln69 permanent
</span><span class='line'>50:00:00:6b:2e:70 dev swp3 vlan <span class="m">0</span> master br-vxln69
</span><span class='line'>26:21:90:a8:8a:cc dev vxln69 vlan <span class="m">0</span> master br-vxln69 permanent
</span><span class='line'>fa:16:3e:57:1c:6c dev vxln69 dst 10.0.3.10 vlan <span class="m">65535</span> self permanent
</span><span class='line'>fa:16:3e:a4:12:e6 dev vxln69 dst 10.0.3.10 vlan <span class="m">65535</span> self permanent
</span><span class='line'>fa:16:3e:d7:0e:14 dev vxln69 dst 10.0.2.10 vlan <span class="m">65535</span> self permanent
</span><span class='line'>fa:16:3e:3c:51:d7 dev vxln69 dst 10.0.1.10 vlan <span class="m">65535</span> self permanent
</span></code></pre></td></tr></table></div></figure>


<p>The rest of the story is very simple. The ARP packet hits the baremetal server and populates its ARP cache. A unicast response travels all the way back to VM-2, populating the flow entries of all OVS switches along the way. These entries are then used by unicast message travelling from VM-2.</p>

<figure class='code'><figcaption><span>Unicast packet to baremetal server</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-appctl ofproto/trace br-tun <span class="nv">in_port</span><span class="o">=</span>1,dl_vlan<span class="o">=</span>1,dl_dst<span class="o">=</span>50:00:00:6b:2e:70 <span class="p">|</span> grep -E <span class="s2">&quot;Rule|actions=&quot;</span>
</span><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xb5625033061a8ae5 <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>1
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">2</span> <span class="nv">cookie</span><span class="o">=</span>0xb5625033061a8ae5 <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">20</span> <span class="nv">cookie</span><span class="o">=</span>0xb5625033061a8ae5 <span class="nv">priority</span><span class="o">=</span>1,vlan_tci<span class="o">=</span>0x0001/0x0fff,dl_dst<span class="o">=</span>50:00:00:6b:2e:70
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:0x45-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:9
</span></code></pre></td></tr></table></div></figure>


<p>It all looks fine until the ARP cache of the baremetal server expires and you get an ARP request coming from the physical into the virtual world. There is a <a href="https://drive.google.com/file/d/0Bx8nDIFktlzBRm0tV3pmYURnZ3M/view">known issue</a> with BUM forwarding which requires a special <a href="http://blog.scottlowe.org/2014/02/27/learning-nsx-part-10-adding-a-service-node/">service node</a> to perform the head-end replication. The idea is that a switch that requires a multicast packet to be replicated to multiple destinations, would send it to a service node, which keeps track of all active VTEPs on the network and performs packet replication on behalf of the sender. OpenStack doesn&rsquo;t have a dedicated service node however it is possible to trick the network node into performing a similar functionality, which is what I&rsquo;m going to demonstrate next.</p>

<h2>Programming Network Node as BUM replication service node</h2>

<p>First of all, we need to tell our Cumulus switch to send all multicast packets to the network node. To do that we need to modify an OVSDB table called &ldquo;Mcast_Macs_Remote&rdquo;. Let&rsquo;s first make sure that this table is empty:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ovsdb-client dump --pretty tcp:192.168.91.21:6632
</span></code></pre></td></tr></table></div></figure>


<p>Now let&rsquo;s modify OVSDB manually to force all BUM traffic (unknown-dst is the keyword) to go to 10.0.3.10. The UUID of the logical switch can be found with <code>sudo vtep-ctl list-ls</code> command.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo vtep-ctl add-mcast-remote 818b4779-645c-49bb-ae4a-aa9340604019 unknown-dst 10.0.3.10
</span></code></pre></td></tr></table></div></figure>


<p>At this stage all BUM traffic hits the network node and gets flooded to the DHCP and the virtual router. In order to force this traffic to be replicated to all compute nodes we can use some of the existing tables of the tunnel bridge. Before we do anything let&rsquo;s have a look at the tables our ARP request has to go through inside the tunnel bridge.</p>

<figure class='code'><figcaption><span>ARP from Cumulus VX inside br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">2</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,4<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>4, <span class="nv">priority</span><span class="o">=</span>1,tun_id<span class="o">=</span>0x45 <span class="nv">actions</span><span class="o">=</span>mod_vlan_vid:1,resubmit<span class="o">(</span>,10<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>10,priority<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,cookie<span class="o">=</span>0x9f3e746b7ee48bbf,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:NXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span></code></pre></td></tr></table></div></figure>


<p>We also have a default head-end replication table 22, which forwards all unmatched BUM traffic to all VTEPs:</p>

<figure class='code'><figcaption><span>BUM replication table</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>22, <span class="nv">dl_vlan</span><span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x45,output:2,output:4,output:6
</span></code></pre></td></tr></table></div></figure>


<p>So what we can do is create a new flow entry that would intercept all ARP packets inside table #4 and resubmit it to tables 10 and 22. Table 10 will take our packet to the intergration bridge of the network node and Table 22 will take a copy of the packet and replicate it to all known VXLAN endpoints.</p>

<figure class='code'><figcaption><span>Manipulating OVS flows</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ovs-ofctl add-flow br-tun <span class="s2">&quot;table=4,arp,tun_id=0x45,priority=2,actions=mod_vlan_vid:1,resubmit(,10),resubmit(,22)&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can once again use the trace command to see the ARP request flow inside the tunnel bridge.</p>

<figure class='code'><figcaption><span>Manipulating OVS flows</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-appctl ofproto/trace br-tun <span class="nv">in_port</span><span class="o">=</span>2,arp,tun_id<span class="o">=</span>0x45 <span class="p">|</span> grep -E <span class="s2">&quot;Rule|actions=&quot;</span>
</span><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0x9f3e746b7ee48bbf <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>2
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,4<span class="o">)</span>
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">4</span> <span class="nv">cookie</span><span class="o">=</span><span class="m">0</span> <span class="nv">priority</span><span class="o">=</span>2,arp,tun_id<span class="o">=</span>0x45
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>mod_vlan_vid:1,resubmit<span class="o">(</span>,10<span class="o">)</span>,resubmit<span class="o">(</span>,22<span class="o">)</span>
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">10</span> <span class="nv">cookie</span><span class="o">=</span>0x9f3e746b7ee48bbf <span class="nv">priority</span><span class="o">=</span>1
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,cookie<span class="o">=</span>0x9f3e746b7ee48bbf,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:NXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span><span class='line'>                        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0x91b1a9a9b6e8d608 <span class="nv">priority</span><span class="o">=</span>0
</span><span class='line'>                        OpenFlow <span class="nv">actions</span><span class="o">=</span>NORMAL
</span><span class='line'>                                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xb36f6e358a37bea6 <span class="nv">priority</span><span class="o">=</span>2,in_port<span class="o">=</span>2
</span><span class='line'>                                OpenFlow <span class="nv">actions</span><span class="o">=</span>drop
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">22</span> <span class="nv">cookie</span><span class="o">=</span>0x9f3e746b7ee48bbf <span class="nv">dl_vlan</span><span class="o">=</span>1
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x45,output:2,output:4,output:6
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://networkop.github.io/images/neutron-l2gw-arp.png"></p>

<p>Now we should be able to clear the ARP cache on the baremetal device and successfully ping both VM-2, VM-1 and a virtual router.</p>

<h2>Conclusion</h2>

<p>The workaround presented above is just a temporary solution to the problem. In order to fix the problem properly, OVS vtep schema needs to be updated to support source node replication. Luckily the patch has been implementing this functionality has been <a href="https://github.com/openvswitch/ovs/commit/b351ac0c9bc270b3fff07ae8c7434c53d59b132c">merged</a> into master OVS branch only a few days ago.
So hopefully, this update trickles down to Cumulus package respositories.</p>

<p>Nevertheless it&rsquo;s a cool project that provides a very important piece of functionality without having to rely on 3rd party SDN controllers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack SDN - Extending a L2 Provider Network Over a L3 Fabric]]></title>
    <link href="http://networkop.github.io/blog/2016/05/11/neutron-routed-extnet/"/>
    <updated>2016-05-11T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2016/05/11/neutron-routed-extnet</id>
    <content type="html"><![CDATA[<p>In the this post we&rsquo;ll tackle yet another Neutron scalability problem identified in my <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">earlier post</a> - a requirement to have a direct L2 adjacency between the external provider network and the network node.</p>

<!--more-->


<h2>Provider vs Tenant networks</h2>

<p>Before we start, let&rsquo;s recap the difference between the <a href="http://docs.openstack.org/mitaka/networking-guide/intro-os-networking-overview.html">two major</a> Neutron network types:</p>

<ul>
<li>Tenant networks are:

<ul>
<li>provisioned by tenants</li>
<li>used for inter-VM (east-west) communication</li>
<li>use Neutron virtual router as their default gateway</li>
</ul>
</li>
<li>Provider networks are:

<ul>
<li>provisioned by OpenStack administrator(for use by tenants)</li>
<li>match existing physical networks</li>
<li>can be either flat (untagged VLAN) or VLAN-based (multiple VLANs)</li>
<li>need to be L2 adjacent to network and/or compute nodes</li>
</ul>
</li>
</ul>


<p>These two network types are not mutually exclusive. In our case the <strong>admin tenant</strong> network is implemented as a VXLAN-based overlay whose only requirement is to have a layer-3 reachability in the underlay. However tenant network could also have been implemented using a VLAN-based provider network in which case a set of dot1Q tags pre-provisioned in the underlay would have been used for tenant network segregation.</p>

<h2>External provider network</h2>

<p>External network is used by VMs to communicate with the outside world (north-south). Since default gateway is located outside of OpenStack environment this, by definition, is a provider network. Normally, tenant networks will use the non-routable address space and will rely on a Neutron virtual router to perform some form of NAT translation. As we&rsquo;ve seen in the <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">earlier post</a>, Neutron virtual router is directly connected to the external bridge which allows it to &ldquo;borrow&rdquo; ip address from the external provider network to use for two types of NAT operations:</p>

<ul>
<li>SNAT - a source-based port address translation performed by the Neutron virtual router</li>
<li>DNAT - a static NAT created for every <a href="https://www.rdoproject.org/networking/difference-between-floating-ip-and-private-ip/">floating ip address</a> configured for a VM</li>
</ul>


<p>In default deployments all NATing functionality is performed by a network node, so external provider network only needs to be L2 adjacent with a limited number of physical hosts. In deployments where <abbr title=" Distributed Virtual Router">DVR</abbr> is used, the virtual router and NAT functionality gets distributed among all compute hosts which means that they, too, now need to be layer-2 adjacent to the external network.</p>

<h2>Solutions overview</h2>

<p>The direct adjacency requirement presents a big problem for deployments where layer-3 routed underlay is used for the tenant networks. There is a limited number of ways to satisfy this requirements, for example:</p>

<ul>
<li>Span a L2 segment across the whole DC fabric. This means that the fabric needs to be converted to layer-2, reintroducing spanning-tree and all the unique vendor solutions to overcome STP limitations(e.g. TRILL, Fabripath, SPB).</li>
<li>Build a dedicated physical network. This may not always be feasible, especially considering that it needs to be delivered to all compute hosts.</li>
<li>Extend the provider network over an existing L3 fabric with VXLAN overlay. This can easily be implemented with just a few commands, however it requires a border leaf switch capable of performing VXLAN-VLAN translation.</li>
</ul>


<h2>Detailed design</h2>

<p>As I&rsquo;ve said in my <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">earlier post</a>, I&rsquo;ve built the leaf-spine fabric out of Cisco IOU virtual switches, however the plan was to start introducing other vendors later in the series. So this time for the border leaf role I&rsquo;ve chosen Arista vEOS switch, however, technically, it could have been any other vendor capable of doing VXLAN-VLAN bridging (e.g. any hardware switch with <a href="http://blog.ipspace.net/2014/06/trident-2-chipset-and-nexus-9500.html">Trident 2</a> or similar ASIC).</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-extnet-l3.png"></p>

<h3>Arista vEOS configuration</h3>

<p>Configuration of Arista switches is very similar to Cisco IOS. In fact, I was able to complete all interface and OSPF routing configuration only with the help of CLI context help. The only bit that was new to me and that I had to lookup in the official guide was the <a href="https://eos.arista.com/vxlan-with-mlag-configuration-guide/">VXLAN configuration</a>. These similarities makes the transition from Cisco to Arista very easy and I can understand (but not approve!) why Cisco would file a lawsuit against Arista for copying its &ldquo;industry-standard CLI&rdquo;.</p>

<figure class='code'><figcaption><span>L4 configuration</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>interface Ethernet1
</span><span class='line'>   description SPINE-1:Eth0/3
</span><span class='line'>   no switchport
</span><span class='line'>   ip address 169.254.41.4/24
</span><span class='line'>   ip ospf network point-to-point
</span><span class='line'>!
</span><span class='line'>interface Ethernet2
</span><span class='line'>   description SPINE-2:Eth0/3
</span><span class='line'>   no switchport
</span><span class='line'>   ip address 169.254.42.4/24
</span><span class='line'>   ip ospf network point-to-point
</span><span class='line'>!
</span><span class='line'>interface Ethernet3
</span><span class='line'>   description VM-HOST-ONLY:PNET1
</span><span class='line'>   switchport access vlan 100
</span><span class='line'>   spanning-tree portfast
</span><span class='line'>!
</span><span class='line'>interface Loopback0
</span><span class='line'>   ip address 10.0.0.4/32
</span><span class='line'>!
</span><span class='line'>interface Vxlan1
</span><span class='line'>   vxlan source-interface Loopback0
</span><span class='line'>   vxlan udp-port 4789
</span><span class='line'>   vxlan vlan 100 vni 1000
</span><span class='line'>   vxlan vlan 100 flood vtep 10.0.3.10
</span><span class='line'>!
</span><span class='line'>router ospf 1
</span><span class='line'>   router-id 10.0.0.4
</span><span class='line'>   passive-interface default
</span><span class='line'>   no passive-interface Ethernet1
</span><span class='line'>   no passive-interface Ethernet2
</span><span class='line'>   network 0.0.0.0/0 area 0.0.0.0
</span><span class='line'>!
</span></code></pre></td></tr></table></div></figure>


<p>Interface VXLAN1 sets up VXLAN-VLAN bridging between VNI 1000 and VLAN 100. VLAN 100 is used to connect to VMware Workstation&rsquo;s host-only interface, the one that was <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">previously</a> connected directly to the L3 leaf switch. VXLAN interface does the multicast source replication by flooding unknown packets over the layer 3 fabric to the network node (10.0.3.10).</p>

<h3>OpenStack network node configuration</h3>

<p>Since we don&rsquo;t yet have the distributed routing feature enabled, the only OpenStack component that requires any changes is the network node. First, let&rsquo;s remove the physical interface from the external bridge, since it will no longer be used to connect to the external provider network.</p>

<figure class='code'><figcaption><span>Remove the physical interface from the external bridge</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-vsctl del-port br-ex eth1.300
</span></code></pre></td></tr></table></div></figure>


<p>Next let&rsquo;s add the VXLAN interface towards the Loopback IP address of the Arista border leaf switch. The key option sets the VNI which must be equal to the VNI defined on the border leaf.</p>

<figure class='code'><figcaption><span>add the VXLAN interface towards the Arista switch</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-vsctl add-port br-ex vxlan1 <span class="se">\</span>
</span><span class='line'>-- <span class="nb">set </span>interface vxlan1 <span class="se">\</span>
</span><span class='line'><span class="nb">type</span><span class="o">=</span>vxlan <span class="se">\</span>
</span><span class='line'>options:remote_ip<span class="o">=</span>10.0.0.4 <span class="se">\</span>
</span><span class='line'>options:key<span class="o">=</span>1000
</span></code></pre></td></tr></table></div></figure>


<p>Without any physical interfaces attached to the external bridge, the OVS will use the Linux network stack to find the outgoing interface. When a packet hits the <strong>vxlan1</strong> interface of the br-ex, it will get encapsulated in a VXLAN header and passed on to the OS network stack where it will follow the <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">pre-configured</a> static route forwarding all 10/8 traffic towards the leaf-spine fabric. Check out <a href="http://blog.scottlowe.org/2013/05/15/examining-open-vswitch-traffic-patterns/">this article</a> if you want to learn more about different types of interfaces and traffic forwarding behaviours in OpenvSwitch.</p>

<h3>Cleanup</h3>

<p>In order to make changes persistent and prevent the static interface configuration from interfering with OVS, remove all OVS-related configuration and shutdown interface eth1.300.</p>

<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-eth1.300</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">ONBOOT</span><span class="o">=</span>no
</span><span class='line'><span class="nv">VLAN</span><span class="o">=</span>yes
</span></code></pre></td></tr></table></div></figure>


<h2>Change in the packet flow</h2>

<p>None of the packet flows have changed as the result of this modification. All VMs will still use NAT to break out of the private environment, the NAT&rsquo;d packets will reach the external bridge <strong>br-ex</strong> as described in my <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">earlier post</a>. However this time <strong>br-ex</strong> will forward the packets out the <strong>vxlan1</strong> port which will deliver them to the Arista switch over the same L3 fabric used for east-west communication.</p>

<p>If we did a capture on the fabric-facing interface <strong>eth1</strong> of the control node while running a ping from one of the VMs to the external IP address, we would see a VXLAN-encapsulated packet destined for the Loopback IP of L4 leaf switch.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-provider-vxlan.png"></p>

<h2>Coming Up</h2>

<p>In the next post we&rsquo;ll examine the L2 gateway feature that allows tenant networks to communicate with physical servers through yet another VXLAN-VLAN hardware gateway.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack SDN - L2 Population and ARP Proxy]]></title>
    <link href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/"/>
    <updated>2016-05-06T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2016/05/06/neutron-l2pop</id>
    <content type="html"><![CDATA[<p>In the <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">previous post</a> we&rsquo;ve had a look at how native OpenStack SDN works and what are some of its limitations. In this post we&rsquo;ll tackle the first one of them - overhead created by multicast source replication.</p>

<!--more-->


<h2>MAC learning in a controller-less VXLAN overlay</h2>

<p>VXLAN <a href="https://tools.ietf.org/html/rfc7348">standard</a> does not specify any control plane protocol to exchange MAC-IP bindings between VTEPs. Instead it relies on data plane flood-and-learn behaviour, just like a normal switch. To force this behaviour in an underlay, the standard stipulates that each VXLAN network should be mapped to its own multicast address and each VTEP participating in a network should join the corresponding multicast group. That multicast group would be used to flood the <abbr title="Broadcast Unknown unicast and Multicast">BUM</abbr> traffic in an underlay to all subscribed VTEPs thereby populating dynamic MAC address tables.</p>

<p>Default OpenvSwitch implementation <a href="https://github.com/openvswitch/ovs/blob/master/FAQ.md#q-how-much-of-the-vxlan-protocol-does-open-vswitch-currently-support">does not support</a> VXLAN multicast flooding and uses unicast source replication instead. This decision comes with a number of tradeoffs:</p>

<ul>
<li>Duplicate packets consume additional bandwidth. Extra 100 bytes exchanged every 3 minutes in a 100-nodes environment generate around 500 kbit/s of traffic on average. This can be considered negligible inside modern high-speed DC fabrics.</li>
<li>Hardware VTEP gateways rely on multicast for MAC learning and VTEP discovery. As we&rsquo;ll see later in the series, these gateways can now be controlled by Neutron just like a normal OVS inside a compute host.</li>
<li>Duplicate packets are processed by hosts that do not need them, e.g. ARP request is processed by tunnel and integration bridges of all hosts that have VMs in the same broadcast domain. This presents some serious scaling limitation and is addressed by the L2 population feature described in this post.</li>
</ul>


<p>Despite all the tradeoffs, OVS with unicast source replication has become a de-facto standard in most recent OpenStack implementations. The biggest advantage of such approach is the lack of requirement for multicast in the underlay network.</p>

<h2>VXLAN MAC learning with an SDN controller</h2>

<p>Neutron server is aware of all active MAC and IP addresses within the environment. This information can be used to prepopulate forwarding entries on all tunnel bridges. This is accomplished by a <a href="https://github.com/openstack/neutron/tree/master/neutron/plugins/ml2/drivers/l2pop">L2 population</a> driver. However that in itself isn&rsquo;t enough. Whenever a VM doesn&rsquo;t know the destination MAC address, it will send a broadcast ARP request which needs to be intercepted and responded by a local host to stop it from being flooded in the network. The latter is accomplished by a feature called <a href="https://assafmuller.com/2014/05/21/ovs-arp-responder-theory-and-practice/">ARP responder</a> which simulates the functionality commonly known as <strong>ARP proxy</strong> inside the tunnel bridge.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-l2-arp.png"></p>

<h3>Configuration</h3>

<p>Configuration of these two features is <a href="https://kimizhang.wordpress.com/2014/04/01/how-ml2vxlan-works/">fairly straight-forward</a>. First, we need to add L2 population to the list of supported mechanism drivers on our control node and restart the neutron server.</p>

<figure class='code'><figcaption><span>Update on control node</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sed -ri <span class="s1">&#39;s/(mechanism_drivers.*)/\1,l2population/&#39;</span> /etc/neutron/plugin.ini
</span><span class='line'><span class="nv">$ </span>service neutron-server restart
</span></code></pre></td></tr></table></div></figure>


<p>Next we need to enable L2 population and ARP responder features on all 3 compute nodes.</p>

<figure class='code'><figcaption><span>Updates on all 3 compute nodes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sed -ri <span class="s1">&#39;s/.*(arp_responder).*/\1 = true/&#39;</span> /etc/neutron/plugins/ml2/openvswitch_agent.ini
</span><span class='line'><span class="nv">$ </span>sed -ri <span class="s1">&#39;s/.*(l2_population).*/\1 = true/&#39;</span> /etc/neutron/plugins/ml2/openvswitch_agent.ini
</span><span class='line'><span class="nv">$ </span>service neutron-openvswitch-agent restart
</span></code></pre></td></tr></table></div></figure>


<p>Since L2 population is triggered by the <a href="https://assafmuller.com/2014/02/23/ml2-address-population/">port_up</a> messages, we might need to restart both our VMs for the change to take effect.</p>

<h3>BUM frame from VM-1 for MAC address of VM-2 (Revisited)</h3>

<p>Now let&rsquo;s once again examine what happens when VM-1 issues an ARP request for VM-2&rsquo;s MAC address (1a:bf).</p>

<p>First, the frame hits the flood-and-learn rule of the integration bridge and gets flooded down to the tunnel bridge as desribed in the <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">previous post</a>. Once in the br-tun, the frames gets matched by the incoming port and resubmitted to table 2. In addition to a default unicast/multicast bit match, table 2 now also matches all ARP requests and resubmitts them to the new table 21. Note how the ARP entry has a higher priority to always match before the default catch-all multicast rule.</p>

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>1,arp,dl_dst<span class="o">=</span>ff:ff:ff:ff:ff:ff <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,21<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>01:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,22<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Inside table 21 are the entries created by the ARP responder feature. The following is an example entry that matches all ARP requests where target IP address field equals the IP of VM-2(10.0.0.9).</p>

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> <span class="nv">table</span><span class="o">=</span>21, <span class="nv">priority</span><span class="o">=</span>1,arp,dl_vlan<span class="o">=</span>1,arp_tpa<span class="o">=</span>10.0.0.9
</span><span class='line'> <span class="nv">actions</span><span class="o">=</span>move:NXM_OF_ETH_SRC<span class="o">[]</span>-&gt;NXM_OF_ETH_DST<span class="o">[]</span>,
</span><span class='line'> mod_dl_src:fa:16:3e:ab:1a:bf,
</span><span class='line'> load:0x2-&gt;NXM_OF_ARP_OP<span class="o">[]</span>,
</span><span class='line'> move:NXM_NX_ARP_SHA<span class="o">[]</span>-&gt;NXM_NX_ARP_THA<span class="o">[]</span>,
</span><span class='line'> move:NXM_OF_ARP_SPA<span class="o">[]</span>-&gt;NXM_OF_ARP_TPA<span class="o">[]</span>,
</span><span class='line'> load:0xfa163eab1abf-&gt;NXM_NX_ARP_SHA<span class="o">[]</span>,
</span><span class='line'> load:0xa000009-&gt;NXM_OF_ARP_SPA<span class="o">[]</span>,
</span><span class='line'> IN_PORT
</span></code></pre></td></tr></table></div></figure>


<p>The resulting action builds an ARP response by modifying the fields and headers on the original ARP request message, specifically OVS:</p>

<ol>
<li>Copies the source MAC address (VM-1) to the destination MAC address header</li>
<li>Spoofs the source MAC address to make it look like it comes from VM-2</li>
<li>Modifies the operation code of ARP message to 0x2, meaning <strong>reply</strong></li>
<li>Overwrites the target IP and MAC address fields inside the ARP packet with VM-1&rsquo;s values</li>
<li>Overwrites the source hardware address with VM-2&rsquo;s MAC</li>
<li>Overwrites the source IP address with the address of VM-2(0xa000009)</li>
<li>Sends the packet out the port from which it was received</li>
</ol>


<h3>Unicast frame from VM-1 to VM-2 (Revisited)</h3>

<p>Now that VM-1 has learned the MAC address of VM-2 it can start sending the unicast frames. The first few steps will again be the same. The frame hits the tunnel bridge, gets classified as a unicast and resubmitted to table 20. Table 20 will still have an entry generated by a <strong>learn</strong> action triggered by a packet coming from VM-2, however now it also has and identical entry with a higher priority(priority=2), which was preconfigured by a L2 population feature.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>20, <span class="nv">priority</span><span class="o">=</span>2,dl_vlan<span class="o">=</span>1,dl_dst<span class="o">=</span>fa:16:3e:ab:1a:bf <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x54,output:2
</span><span class='line'><span class="nv">table</span><span class="o">=</span>20, <span class="nv">priority</span><span class="o">=</span>1,vlan_tci<span class="o">=</span>0x0001/0x0fff,dl_dst<span class="o">=</span>fa:16:3e:ab:1a:bf <span class="nv">actions</span><span class="o">=</span>load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:0x54-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:2
</span></code></pre></td></tr></table></div></figure>


<h2>Other BUM traffic</h2>

<p>The two features described in this post only affect the ARP traffic to VMs <strong>known</strong> to the Neutron server. All the other BUM traffic will still be flooded as described in the <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">previous post</a>.</p>

<h2>Results</h2>

<p>As the result of enabling L2 population and ARP responder features we were able to reduce the amount of BUM traffic in the overlay network and reduce the eliminate processing on compute hosts incurred by ARP request flooding.</p>

<p>However one downside of this approach is the increased number of flow entries in tunnel bridges of compute hosts. Specifically, for each known VM there now will be two entries in the tunnel bridge with different priorities. This may have negative impact on performance and is something to keep in mind when designing OpenStack solutions for scale.</p>

<h2>Coming Up</h2>

<p>In the next post I&rsquo;ll show how to overcome the requirement of a direct L2 adjacency between the network node and external subnet. Specifically, I&rsquo;ll use Arista switch to extend a L2 provider network over a L3 leaf-spine Cisco fabric.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network Engineering Analysis of OpenStack SDN]]></title>
    <link href="http://networkop.github.io/blog/2016/04/22/neutron-native/"/>
    <updated>2016-04-22T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2016/04/22/neutron-native</id>
    <content type="html"><![CDATA[<p>Now that we have our 3-node OpenStack lab <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">up and running</a> we can start exploring how virtual networks are implemented under the hood.</p>

<!--more-->


<h2>Intro</h2>

<p>This is going to be quite a lengthy blogpost so I&rsquo;ll try to explain its structure first. I&rsquo;ll start with a high level overview of components used to build virtual networks by examining 3 types of traffic:</p>

<ul>
<li>Unicast traffic between VM1 and VM2</li>
<li>Unicast traffic between VM1 and the outside world (represented by an external subnet)</li>
<li>Broadcast, Unknown unicast and Multicast or BUM traffic from VM1</li>
</ul>


<p>Following that I&rsquo;ll give a brief overview of how to interpret the configuration and dynamic state of OpenvSwitch to manually trace the path of a packet. This will be required for the next section where I&rsquo;ll go over the same 3 types of traffic but this time corroborating every step with the actual outputs collected from the virtual switches. For the sake of brevity I&rsquo;ll abridge a lot of the output to only contain the relevant information.</p>

<h2>High Level Overview</h2>

<p><a href="http://www.innervoice.in/blogs/2015/03/31/openstack-neutron-plugins-and-agents/">Neutron</a> server, residing in a control node, is responsible for orchestrating and provisioning of all virtual networks within an OpenStack environment. Its goal is to enable end-to-end reachability among the VMs and between the VMs and external subnets. To do that, Neutron uses concepts that should be very familiar to every network engineer like subnet, router, firewall, DHCP and NAT. In the <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous post</a> we&rsquo;ve seen how to create a virtual router and attach it to public and private networks. We&rsquo;ve also attached both of our VMs to a newly created private network and verified connectivity by logging into those virtual machines. Now let&rsquo;s see how exactly these VMs communicate with each other and the outside world.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-high-level.png"></p>

<h3>Unicast frame between VM1 and VM2</h3>

<ol>
<li><p>As soon as the frame leaves the vNIC of VM1 it hits the firewall. The firewall is implemented on a <a href="http://www.innervoice.in/blogs/2013/12/08/tap-interfaces-linux-bridge/">tap interface</a> of the integration bridge. A set of <abbr title="Access Control List">ACL</abbr> rules, defined in a <strong>Security Group</strong> that VM belongs to, gets translated into Linux <a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TRAVERSINGOFTABLES">iptables</a> rules and attached to this tap interface. These simple reflexive access lists are what VMware and Cisco are calling microsegmentation and touting as one of the main use case of their SDN solutions.</p></li>
<li><p>Next our frame enters the integration bridge implemented using <a href="http://openvswitch.org/">OpenvSwitch</a>. Its primary function is to interconnect all virtual machines running on the host. Its secondary function is to provide isolation between different subnets and tenants by keeping them in different VLANs. VLAN IDs used for this are locally significant and don&rsquo;t propagate outside of the physical host.</p></li>
<li><p>A dot1q-tagged packet is forwarded down a layer 2 trunk to the tunnel bridge, also implemented using OpenvSwitch. It is programmed to strip the dot1q tags, replace them with VXLAN headers and forward an IP/UDP packet with VXLAN payload on to the physical network.</p></li>
<li><p>Our simple routed underlay delivers the packets to the destination host, where the tunnel bridge swaps the <abbr title=" VXLAN Network ID">VNI</abbr> with a dot1q tag and forwards the packet up to the integration bridge.</p></li>
<li><p>Integration bridge consults the local MAC table, finds the output interface, clears the dot1q tag and send the frame up to the VM.</p></li>
<li><p>The frame gets screened by incoming iptables rules and gets delivered to the VM2.</p></li>
</ol>


<h3>Unicast frame between VM1 and External host</h3>

<ol>
<li><p>The first 3 steps will still be the same. VM1 sends a frame with destination MAC address of a virtual router. This packet will get encapsulated in a VXLAN header and forwarded to the Network node.</p></li>
<li><p>The tunnel and integration bridges of the network node deliver the packet to the private interface of a virtual router. This virtual router lives in a <a href="http://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/">linux network namespaces</a> (similar to <abbr title="Virtual Routing and Forwarding">VRF</abbr>s) used to provide isolation between OpenStack tenants.</p></li>
<li><p>The router finds the outgoing interface (a port attached to the external bridge), and a next-hop IP which we have set when we configured a public subnet <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">earlier</a>.</p></li>
<li><p>The router then performs a source NAT on the packet before forwarding it out. This way the private IP of the VM stays completely hidden and hosts outside of OpenStack can talk back to the VM by sending packets to (publicly routable) external subnet.</p></li>
<li><p>External bridge (also an OpenvSwitch) receives the packet and forwards it out the attached physical interface (eth1.300).</p></li>
</ol>


<h3>BUM frame from VM1 for MAC address of VM2</h3>

<ol>
<li><p>VM1 sends a multicast frame, which gets examined by the iptables rules and enters the integration bridge.</p></li>
<li><p>The integration bridge follows the same process as for the unicast frame to assign the dot1q tag and floods the frame to the tunnel bridge.</p></li>
<li><p>The tunnel bridge sees the multicast bit in the destination MAC address and performs source replication by sending a duplicate copy of the frame to both compute host #2 and the network node.</p></li>
<li><p>Tunnel bridges of both receiving hosts strip the VXLAN header, add the dot1q tag and flood the frame to their respective integration bridges.</p></li>
<li><p>Integration bridges flood the frame within the VLAN identified by the dot1q header.</p></li>
<li><p>The response from VM2 follows the same process as the unicast frame.</p></li>
</ol>


<p>One thing worth noting is when an ARP packet enters the integration bridge, its source IP address (in case of IPv4) or source MAC address (in case of IPv6) gets examined to make sure it belong to that VM. This is how <strong>ARP spoofing protection</strong> is implemented in OpenStack.</p>

<h2>OpenvSwitch quick intro</h2>

<p>Before we dive deeper into the details of the packet flows inside OVS let me give a brief overview of how it works. There are two main protocols to configure OVS:</p>

<ul>
<li><p>OVSDB - a management protocol used to configure bridges, ports, VLANs, QoS, monitoring etc.</p></li>
<li><p>OpenFlow - used to install flow entries for traffic switching, similar to how you would configure a static route but allowing you to match on most of the L2-L4 protocol headers.</p></li>
</ul>


<p>Control node instructs all <a href="http://www.innervoice.in/blogs/2015/03/31/openstack-neutron-plugins-and-agents/">local OVS agents</a> about how to configure virtual networks. Each local OVS agent then uses these two protocols to configure OVS and install all the required forwarding entries. Each entry contains a set of matching fields (e.g. incoming port, MAC/IP addresses) and an action field which determines what to do with the packet. These forwarding entries are implemented as <a href="https://wiki.openstack.org/wiki/Ovs-flow-logic">tables</a>. This is how a packet traverses these tables:</p>

<ol>
<li><p>First packet always hits table 0. The entries are examined in order of their priority (highest first) to find the first match. Note that it&rsquo;s the first and not necessarily the more specific match. It&rsquo;s the responsibility of a controller to build tables so that more specific flows are matched first. Normally this is done by assigning a higher priority to a more specific flow. Exact matches (where all L2-L4 fields are specified) implicitly have the highest priority value of 65535.</p></li>
<li><p>When a flow is matched, the <strong>action</strong> field of that flow is examined. Here are some of the most commonly used actions:</p>

<table>
<thead>
<tr>
<th> Action </th>
<th></th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td> resubmit(X,) </td>
<td></td>
<td> Resubmit a packet to table X </td>
</tr>
<tr>
<td> output:Y </td>
<td></td>
<td> Send a packet out port Y </td>
</tr>
<tr>
<td> NORMAL </td>
<td></td>
<td> Use a standard flood-and-learn behaviour of a switch to populate a local dynamic MAC address table </td>
</tr>
<tr>
<td> learn(table=Z) </td>
<td></td>
<td> Create an exact-match entry for the matched flow in table Z (we&rsquo;ll see how its used later on) </td>
</tr>
</tbody>
</table>


<p> These actions can be combined in a sequence to create complex behaviours like sending the same packet to multiple ports for multicast source replication.</p></li>
<li><p>OVS also <a href="https://networkheresy.com/2014/11/13/accelerating-open-vswitch-to-ludicrous-speed/">implements</a> what Cisco calls <strong>Fast switching</strong>, where the first packet lookup triggers a cache entry to be installed in the kernel-space process to be used by all future packets from the same flow.</p></li>
</ol>


<h2>Detailed packet flow analysis</h2>

<p>Let&rsquo;s start by recapping what we know about our private virtual network. All these values can be obtained from Horizon GUI by examining the private network configuration under Project -> Network -> Networks -> private_network:</p>

<ul>
<li>VM1, IP=10.0.0.8, MAC=fa:16:3e:19:e4:91, port id = <strong>258336bc-4f</strong>38-4bec-9229-4bc76e27f568</li>
<li>VM2, IP=10.0.0.9, MAC=fa:16:3e:ab:1a:bf, port id = <strong>e5f7eaca-1a</strong>36-4b08-aa9b-14e9787f80b0</li>
<li>Router, IP=10.0.0.1, MAC=fa:16:3e:cf:89:47, port id = <strong>96dfc1d3-d2</strong>3f-4d28-a461-fa2404767df2</li>
</ul>


<p>The first 11 characters of port id will be used inside an integration bridge to build the port names, e.g.:</p>

<ul>
<li>tap258336bc-4f - interface connected to VM1</li>
<li>qr-96dfc1d3-d2 - interface connected to the router</li>
</ul>


<h3>Enumerating OVS ports</h3>

<p>In its forwarding entries OVS uses internal port numbers a lot, therefore it would make sense to collect all port number information before we start. This is how it can be done:</p>

<ul>
<li>Use <code>ovs-vsctl show</code> command to collect information about existing port names and their attributes (e.g. dot1q tag, VXLAN tunnel IPs, etc). This is the output collected on compute host #1:</li>
</ul>


<figure class='code'><figcaption><span>ovs-vsctl show | grep -E "Bridge|Port|tag|options"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Bridge br-tun
</span><span class='line'>    Port br-tun
</span><span class='line'>    Port patch-int
</span><span class='line'>            options: <span class="o">{</span><span class="nv">peer</span><span class="o">=</span>patch-tun<span class="o">}</span>
</span><span class='line'>    Port <span class="s2">&quot;vxlan-0a00020a&quot;</span>
</span><span class='line'>            options: <span class="o">{</span><span class="nv">df_default</span><span class="o">=</span><span class="s2">&quot;true&quot;</span>, <span class="nv">in_key</span><span class="o">=</span>flow, <span class="nv">local_ip</span><span class="o">=</span><span class="s2">&quot;10.0.1.10&quot;</span>, <span class="nv">out_key</span><span class="o">=</span>flow, <span class="nv">remote_ip</span><span class="o">=</span><span class="s2">&quot;10.0.2.10&quot;</span><span class="o">}</span>
</span><span class='line'>    Port <span class="s2">&quot;vxlan-0a00030a&quot;</span>
</span><span class='line'>            options: <span class="o">{</span><span class="nv">df_default</span><span class="o">=</span><span class="s2">&quot;true&quot;</span>, <span class="nv">in_key</span><span class="o">=</span>flow, <span class="nv">local_ip</span><span class="o">=</span><span class="s2">&quot;10.0.1.10&quot;</span>, <span class="nv">out_key</span><span class="o">=</span>flow, <span class="nv">remote_ip</span><span class="o">=</span><span class="s2">&quot;10.0.3.10&quot;</span><span class="o">}</span>
</span><span class='line'>Bridge br-int
</span><span class='line'>    Port br-int
</span><span class='line'>    Port <span class="s2">&quot;tap258336bc-4f&quot;</span>
</span><span class='line'>        tag: 5
</span><span class='line'>    Port patch-tun
</span><span class='line'>            options: <span class="o">{</span><span class="nv">peer</span><span class="o">=</span>patch-int<span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Use <code>ovs-ofctl dump-ports-desc &lt;bridge_ID&gt;</code> command to correlate port names and numbers. Example below is for integration bridge of compute host #1:</li>
</ul>


<figure class='code'><figcaption><span>ovs-ofctl dump-ports-desc br-int | grep addr</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> 2<span class="o">(</span>patch-tun<span class="o">)</span>: addr:5a:c5:44:fc:ac:72
</span><span class='line'> 7<span class="o">(</span>tap258336bc-4f<span class="o">)</span>: addr:fe:16:3e:19:e4:91
</span><span class='line'> LOCAL<span class="o">(</span>br-int<span class="o">)</span>: addr:46:fe:10:de:1b:4f
</span></code></pre></td></tr></table></div></figure>


<p>I&rsquo;ve put together a diagram showing all the relevant integration bridge (<strong>br-int</strong>) and tunnel bridge (<strong>br-tun</strong>) ports on all 3 hosts.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-port-details.png"></p>

<h3>Unicast frame between VM1 and VM2</h3>

<ol>
<li> Frame enters the br-int on port 7. Default iptables rules allow all outbound traffic from a VM.</li>

<li> Inside the br-int our frame is matched by the "catch-all" rule which triggers the flood-and-learn behaviour:

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>10,arp,in_port<span class="o">=</span><span class="m">7</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,24<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span><span class="m">0</span> <span class="nv">actions</span><span class="o">=</span>NORMAL
</span></code></pre></td></tr></table></div></figure></li>

<li> Since it's a unicast frame the MAC address table is already populated by ARP:

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">2</span>     <span class="m">5</span>  fa:16:3e:ab:1a:bf    1
</span></code></pre></td></tr></table></div></figure></li>

Target IP address is behind port 2 which is where the frame gets forwarded next.

<li> Inside the tunnel bridge the frame will match three different tables. The first table simply matches the incoming port and resubmits the frame to table 2. Table 2 will match the unicast bit of the MAC address (the least significant bit of the first byte) and resubmit the frame to unicast table 20:

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1, <span class="nv">in_port</span><span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0, <span class="nv">dl_dst</span><span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>20, <span class="nv">priority</span><span class="o">=</span>1, <span class="nv">vlan_tci</span><span class="o">=</span>0x0005/0x0fff,dl_dst<span class="o">=</span>fa:16:3e:ab:1a:bf <span class="nv">actions</span><span class="o">=</span>load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:0x54-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:2
</span></code></pre></td></tr></table></div></figure>

The final match is done on a VLAN tag and destination MAC address. Resulting action is a combination of three consecutive steps:
<ol>
  <li> Clear the dot1q tag - load:0->NXM_OF_VLAN_TCI[]</li>
  <li> Tag the frame with VNI 0x54 - load:0x54->NXM_NX_TUN_ID[]</li>
  <li> Send the frame to compute host 2 - output:2</li>
</ol>
This last match entry is quite interesting in a way that it contains the destination MAC address of VM2, which means this entry was created <b>after</b> the ARP process. In fact, as we'll see in the next step, this entry is populated by a <b>learn</b> action triggered by the ARP response coming from VM2.
</li>

<li>A VXLAN packet arrives at compute host 2 and enters the tunnel bridge through port 2. It's matched on the incoming port and resubmitted to a table where it is assigned with an internal VLAN ID 3 based on the matched tunnel id 0x54. 

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">2</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,4<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>4, <span class="nv">priority</span><span class="o">=</span>1,tun_id<span class="o">=</span>0x54 <span class="nv">actions</span><span class="o">=</span>mod_vlan_vid:3,resubmit<span class="o">(</span>,10<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>10, <span class="nv">priority</span><span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:NXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span></code></pre></td></tr></table></div></figure>

The last match does two things:
<ol>
  <li> Creates a mirroring entry in table 20 for the reverse packet flow. This is the entry similar to the one we've just seen in step 4.  </li>
  <li> Sends the packet towards the integration bridge.</li>
</ol>
</li>  
<li>The integration bridge checks the local dynamic MAC address table to find the MAC address of VM2(1a:bf).

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>port  VLAN  MAC                Age
</span><span class='line'>  <span class="m">5</span>     <span class="m">3</span>  fa:16:3e:ab:1a:bf    0
</span></code></pre></td></tr></table></div></figure>
</li>

<li>The frame is checked against the iptables rules configured on port 5 and gets sent up to VM2</li>
</ol>


<h3>Unicast frame to external host (192.168.247.1)</h3>

<ol>
  <li>
    The first 5 steps will be similar to the previous section. The only exception will be that the tunnel bridge of compute host 1 will send the VXLAN packet out port 3 towards the network node.
  </li>
  <li>
    The integration bridge of the network node consults the MAC address table to find the location of the virtual router (89:47) and forwards the packet out port 6.
<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">6</span>     <span class="m">1</span>  fa:16:3e:cf:89:47    1
</span></code></pre></td></tr></table></div></figure>
  </li>
  <li> The virtual router does the route lookup to find the outgoing interface (qg-18bff97b-57)
<figure class='code'><figcaption><span>ip route get 192.168.247.1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>192.168.247.1 dev qg-18bff97b-57  src 192.168.247.90
</span></code></pre></td></tr></table></div></figure>
Remember that since our virtual router resides in a network namespace all commands must be prepended with <code>ip netns exec qrouter-uuid</code>
  
  </li>
  <li> The virtual router performs the source IP translation to hide the private IP address: 
<figure class='code'><figcaption><span>iptables -t nat -S | grep qg-18bff97b-57</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>-A neutron-l3-agent-POSTROUTING ! -i qg-18bff97b-57 ! -o qg-18bff97b-57 -m conntrack ! --ctstate DNAT -j ACCEPT
</span><span class='line'>-A neutron-l3-agent-snat -o qg-18bff97b-57 -j SNAT --to-source 192.168.247.90
</span></code></pre></td></tr></table></div></figure>
By default all packets will get translated to the external address of the router. For each assigned floating IP address there will be a pair of source/destination NAT entries created in the same table. 

  </li>
  <li> The router consults its local ARP table to find the MAC address of the next hop:
<figure class='code'><figcaption><span>ip neigh show 192.168.247.1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>192.168.247.1 dev qg-18bff97b-57 lladdr 00:50:56:c0:00:01 DELAY
</span></code></pre></td></tr></table></div></figure>
  </li>
  <li> External bridge receives the frame from the virtual router on port 4, consults its own MAC address table built by ARP and forwards the packet to the final destination.
<figure class='code'><figcaption><span>ovs-appctl fdb/show br-ex</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">4</span>     <span class="m">0</span>  fa:16:3e:5c:90:e0    1
</span><span class='line'>    <span class="m">1</span>     <span class="m">0</span>  00:50:56:c0:00:01    1
</span></code></pre></td></tr></table></div></figure></li>
</ol>


<h3>BUM frame from VM1 for MAC address of VM2</h3>

<ol>
  <li>The integration bridge of the sending host will check the source IP of the ARP packet to make sure it hasn't been spoofed before flooding the packet within the local broadcast domain (VLAN 5).

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>10,arp,in_port<span class="o">=</span><span class="m">7</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,24<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>24, <span class="nv">priority</span><span class="o">=</span>2,arp,in_port<span class="o">=</span>7,arp_spa<span class="o">=</span>10.0.0.8 <span class="nv">actions</span><span class="o">=</span>NORMAL
</span></code></pre></td></tr></table></div></figure>
</li>
<li> The flooded packet reaches the tunnel bridge where it goes through 3 different tables. The first table matches the incoming interface, the second table matches the multicast bit of the MAC address.

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>01:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,22<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>22, <span class="nv">dl_vlan</span><span class="o">=</span><span class="m">5</span> <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x54,output:3,output:2
</span></code></pre></td></tr></table></div></figure>

The final table swaps the dot1q and VXLAN identifiers and does the source replication by forwarding the packet out ports 2 and 3.
</li>
<li> The following steps are similar to the unicast frame propagation with the exception that the local MAC table of the integration bridges will flood the packet to all interfaces in the same broadcast domain. That means that duplicate ARP requests will reach both the private interface of the virtual router and VM2. The latter, recognising its own IP, will send a unicast ARP response whose source IP will be verified by the ARP spoofing rule of the integration bridge. As the result of that process, both integration bridges on compute host 1 and 2 will populate their local MAC tables with addresses of VM1 and VM2.
</li>
</ol>


<h2>Native OpenStack SDN advantages and limitation</h2>

<p>Current implementation of OpenStack networking has several advantages compared to the traditional SDN solutions:</p>

<ul>
<li>Data-plane learning allows network to function even in the absence of the controller node</li>
<li>Multicast source replication does not rely on multicast support in the underlay network</li>
<li>ARP spoofing protection is the default security setting</li>
</ul>


<p>However at this point it should also be clear that there a number of limitations that can impact the overall network scalability and performance:</p>

<ul>
<li>Multicast source replication creates unnecessary overhead by flooding ARP packets to all hosts</li>
<li>All routed traffic has to go through the network node which becomes a bottleneck for the whole network</li>
<li>There is no ability to control physical devices, even the ones that support OVSDB/Openflow</li>
<li>Network node must be layer 2 adjacent with the external network segment</li>
</ul>


<h2>Things to explore next</h2>

<p>In the following posts I&rsquo;ll continue poking around Neutron and explore a number of features designed to address some of the limitations described above:</p>

<ul>
<li><a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">L2 population</a></li>
<li><a href="https://wiki.openstack.org/wiki/Neutron/DVR">Distributed Virtual Router</a></li>
<li><a href="https://wiki.openstack.org/wiki/Neutron/L2-GW">L2 hardware gateway</a></li>
<li><a href="https://wiki.openstack.org/wiki/Neutron/L3_High_Availability_VRRP">Network High Availability</a></li>
<li><a href="https://wiki.openstack.org/wiki/Neutron/LBaaS">Load-Balancing-as-a-Service</a></li>
<li><a href="https://github.com/openstack/networking-ovn">Open Virtual Network for OVS</a></li>
<li><a href="http://specs.openstack.org/openstack/neutron-specs/specs/mitaka/bgp-dynamic-routing.html">Neutron&rsquo;s dynamic BGP routing</a></li>
</ul>


<h2>C<sub>2</sub>O</h2>

<p>While writing this post I&rsquo;ve compiled a list of commands most useful to query the state of OpenvSwitch. So now, inspired by a similar  IOS to JUNOS (I2J) command <a href="http://www.net-gyver.com/?page_id=1166">conversion tables</a>, I&rsquo;ve put together my own Cisco to OVS conversion table, just for fun.</p>

<table>
<thead>
<tr>
<th> Action </th>
<th> Cisco </th>
<th> OpenvSwitch </th>
</tr>
</thead>
<tbody>
<tr>
<td> Show MAC address table </td>
<td> show mac address-table dynamic   </td>
<td> <code>ovs-appctl fdb/show &lt;bridge_id&gt;</code> </td>
</tr>
<tr>
<td> Clear MAC address table </td>
<td> clear mac address-table dynamic </td>
<td> <code>ovs-appctl fdb/flush &lt;bridge_id&gt;</code> </td>
</tr>
<tr>
<td> Show port numbers </td>
<td> show interface status </td>
<td> <code>ovs-ofctl dump-ports-desc &lt;bridge_ID&gt;</code> </td>
</tr>
<tr>
<td> Show OVS configuration </td>
<td> show run </td>
<td> <code>ovs-vsctl show</code> </td>
</tr>
<tr>
<td> Show packet forwarding rules </td>
<td> show ip route  </td>
<td> <code>ovs-ofctl dump-flows &lt;bridge_id&gt;</code> </td>
</tr>
<tr>
<td> Simulate packet flow </td>
<td> packet-tracer   </td>
<td> <code>ovs-appctl ofproto/trace &lt;bridge_id&gt; in_port=1</code> </td>
</tr>
<tr>
<td> View command history </td>
<td> show archive log config </td>
<td> <code>ovsdb-tool show-log -m</code> </td>
</tr>
</tbody>
</table>


<h2>References</h2>

<p>In this post I have glossed over some details like iptables and DHCP for the sake of brevity and readability. However this post wouldn&rsquo;t be complete if I didn&rsquo;t include references to other resources that contain a more complete, even if at times outdated, overview of OpenStack networking. This is also a way to pay tribute to blogs where I&rsquo;ve learned most of what I was writing about here:</p>

<ul>
<li><a href="https://www.rdoproject.org/networking/networking-in-too-much-detail/">Networking in too much detail</a></li>
<li><a href="http://www.opencloudblog.com/?p=300">Neutron using VXLAN</a></li>
<li><a href="http://docs.ocselected.org/openstack-manuals/kilo/networking-guide/content/under_the_hood_openvswitch.html">Under the hood of OVS</a></li>
<li><a href="https://kimizhang.wordpress.com/2014/04/01/how-ml2vxlan-works/">How ML2/VXLAN works</a></li>
<li><a href="http://docs.openstack.org/openstack-ops/content/network_troubleshooting.html">Official network troubleshooting guide</a></li>
<li><a href="http://therandomsecurityguy.com/openvswitch-cheat-sheet/">OVS commands cheat sheet</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Multi-node OpenStack Lab in UNetLab]]></title>
    <link href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/"/>
    <updated>2016-04-18T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2016/04/18/os-unl-lab</id>
    <content type="html"><![CDATA[<p>In the <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous post</a> I&rsquo;ve demonstrated how to get a working instance of a single-node OpenStack inside <a href="http://www.unetlab.com/">UNetLab</a>. In this post we&rsquo;ll continue building on that by adding two new compute nodes and redesigning our network to resemble something you might actually see in a real life.</p>

<!--more-->


<h2>OpenStack network requirements</h2>

<p>Depending on the number of deployed <a href="https://www.openstack.org/software/project-navigator/">components</a>, OpenStack physical network requirements could be different. In our case we&rsquo;re not going to deploy any storage solution and simply use the <strong>ephemeral</strong> storage, i.e. hard disk that&rsquo;s a part of a virtual machine. However, even in minimal installations, there are a number of networks that should be considered individually due to different connectivity requirements:</p>

<ul>
<li><p>Server <abbr title=" Out-Of-Band">OOB</abbr> <strong>management</strong> network - this is usually a dedicated physical network used mainly for server bootstrapping and OS deployment. It is a Layer 3 network with DHCP relays configured at each edge L3 interface and access to Internet package repositories.</p></li>
<li><p><strong>API</strong> network - used for internal communication between various OpenStack services. This can be a routed network without Internet access. The only requirement is any-to-any reachability within a single OpenStack environment.</p></li>
<li><p><strong>External</strong> network - used for public access to internal OpenStack virtual machines. This is the <em>outside</em> of OpenStack, with a pool of IP addresses used to NAT the internal IPs of public-facing virtual machines. This network <strong>must</strong> be Layer 2 adjacent <strong>only</strong> with a network control node.</p></li>
<li><p><strong>Tenant</strong> network - used for communication between virtual machines within OpenStack environment. Thanks to the use of VXLAN overlay, this can be a simple routed network that has any-to-any reachability between all Compute and Network nodes.</p></li>
</ul>


<h2>Building a lab network</h2>

<p>For labbing purposes it&rsquo;s possible to relax some of the above network requirements without seriously affecting the outcomes of our simulation. For example, it&rsquo;s possible to combine some of the networks and still satisfy the requirements stated above. These are the networks that will be configured inside UNetLab:</p>

<ul>
<li><p><strong>Management</strong> - this network will combine the functions of OOB and API networks. To isolate it from our data centre underlay I&rsquo;ll be using separate interfaces on virtual machines and connect them directly to Workstation&rsquo;s NAT interface (192.168.91.0/24 in my case)  to give them direct access to Internet.</p></li>
<li><p><strong>External</strong> - this network will be connected to Workstation&rsquo;s host-only NIC (192.168.247.0/24) through Vlan300 configured on one of the leaf switches. Since it must be L2 adjacent with the network control node our leaf switch will not perform any routing for this subnet.</p></li>
<li><p><strong>Tenant</strong> - this will be a routed leaf/spine <a href="https://en.wikipedia.org/wiki/Clos_network">Clos</a> fabric comprised of 3 leaf and 2 spine switches running a single-area OSPF process on all their links. Each server will have its own unique tenant subnet (Vlan100) terminated on the leaf switch and subnet injected into OSPF. The subnet used for this Vlan is going to be <code>10.0.X.0/24</code>, where X is the number of the leaf switch terminating the vlan.</p>

<p>  The links between switches are all L3 point-to-point with addresses borrowed from 169.254.0.0/16 range specifically to emphasize the fact that the internal addressing does not need to be known or routed outside of the fabric. The <strong>sole function of the fabric</strong> is to provide multiple equal cost paths between any pair of leafs, thereby achieving maximum link utilisation. Here&rsquo;s an example of a traceroute between Vlan100&rsquo;s of Leaf #1 and Leaf #3.</p></li>
</ul>


<figure class='code'><figcaption><span>Traceroute inside an ECMP routed Clos fabric</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>L3#traceroute 10.0.1.1 source 10.0.3.1
</span><span class='line'>Type escape sequence to abort.
</span><span class='line'>Tracing the route to 10.0.1.1
</span><span class='line'>VRF info: (vrf in name/id, vrf out name/id)
</span><span class='line'>  1 169.254.31.111 1 msec
</span><span class='line'>    169.254.32.222 0 msec
</span><span class='line'>    169.254.31.111 0 msec
</span><span class='line'>  2 169.254.12.1 1 msec
</span><span class='line'>    169.254.11.1 1 msec *
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>Building lab servers</h2>

<p>Based on my experience a standard server would have at least 3 physical interfaces - one for OOB management and a pair of interfaces for application traffic. The two application interfaces will normally be combined in a single <abbr title=" Link Aggregation Group">LAG</abbr> and connected to a pair of MLAG-capable TOR switches. Multi-chassis LAG or <a href="http://blog.ipspace.net/2010/10/multi-chassis-link-aggregation-basics.html">MLAG</a> is a pretty old and well-understood technology so I&rsquo;m not going to try and simulate it in the lab. Instead I&rsquo;ll simply assume that a server will be connected to a TOR switch via a single physical link. That link will be setup as a dot1q trunk to allow for multiple subnets to share it.</p>

<h2>Physical lab topology</h2>

<p>All the above requirements and assumptions result in the following topology that we need to build inside UNetLab:</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-native.png"></p>

<p>For servers I&rsquo;ll be using OpenStack node type that I&rsquo;ve described in my <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous post</a>. The two compute nodes do not need as much RAM as the control node, so I&rsquo;ll reduce it to just 2GB.</p>

<p>For switches I&rsquo;ll be using a Cisco&rsquo;s <a href="http://www.unetlab.com/2014/11/adding-cisco-iouiol-images/">L2 IOU</a> image for now, mainly due to the low resource requirements. In the future I&rsquo;ll try and swap it for something else. As you can see from the sample config below, fabric configuration is very basic and can be easily replaced by any other solution:</p>

<figure class='code'><figcaption><span>Leaf 1 configuration</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>interface Ethernet0/0
</span><span class='line'> no switchport
</span><span class='line'> ip address 169.254.11.1 255.255.255.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> duplex auto
</span><span class='line'>!
</span><span class='line'>interface Ethernet0/1
</span><span class='line'> no switchport
</span><span class='line'> ip address 169.254.12.1 255.255.255.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> duplex auto
</span><span class='line'>!
</span><span class='line'>interface Ethernet0/2
</span><span class='line'> switchport trunk allowed vlan 100
</span><span class='line'> switchport trunk encapsulation dot1q
</span><span class='line'> switchport mode trunk
</span><span class='line'>!
</span><span class='line'>interface Vlan100
</span><span class='line'> ip address 10.0.1.1 255.255.255.0
</span><span class='line'>!
</span><span class='line'>router ospf 1
</span><span class='line'> network 0.0.0.0 255.255.255.255 area 0
</span></code></pre></td></tr></table></div></figure>


<h2>Server configuration and OpenStack installation</h2>

<p>Refer to my <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous blogpost</a> for instructions on how to install OpenStack and follow the first 5 steps from &ldquo;Installing CentOS and Openstack&rdquo; section. Before doing the final step, we need to configure our VMs' new interfaces:</p>

<ul>
<li>Remove any IP configuration from <strong>eth1</strong> interface to make it look like this:</li>
</ul>


<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-eth1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="na">TYPE</span><span class="o">=</span><span class="s">Ethernet</span>
</span><span class='line'><span class="na">BOOTPROTO</span><span class="o">=</span><span class="s">none</span>
</span><span class='line'><span class="na">DEVICE</span><span class="o">=</span><span class="s">eth1</span>
</span><span class='line'><span class="na">ONBOOT</span><span class="o">=</span><span class="s">yes</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Configure <strong>Tenant network</strong>:</li>
</ul>


<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-eth1.100</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="na">VLAN</span><span class="o">=</span><span class="s">yes</span>
</span><span class='line'><span class="na">DEVICE</span><span class="o">=</span><span class="s">eth1.100</span>
</span><span class='line'><span class="na">BOOTPROTO</span><span class="o">=</span><span class="s">none</span>
</span><span class='line'><span class="na">IPADDR</span><span class="o">=</span><span class="s">10.0.X.10</span>
</span><span class='line'><span class="na">PREFIX</span><span class="o">=</span><span class="s">24</span>
</span><span class='line'><span class="na">ONBOOT</span><span class="o">=</span><span class="s">yes</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Setup a <strong>static route</strong> to all other leaf nodes:</li>
</ul>


<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/route-eth1.100</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="err">10.0.0.0/8</span> <span class="err">via</span> <span class="err">10.0.X.1</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>On Control node setup <strong>External network</strong> interface</li>
</ul>


<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/route-eth1.300</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="na">DEVICE</span><span class="o">=</span><span class="s">eth1.300</span>
</span><span class='line'><span class="na">IPADDR</span><span class="o">=</span><span class="s">192.168.247.100</span>
</span><span class='line'><span class="na">PREFIX</span><span class="o">=</span><span class="s">24</span>
</span><span class='line'><span class="na">ONBOOT</span><span class="o">=</span><span class="s">yes</span>
</span><span class='line'><span class="na">BOOTPROTO</span><span class="o">=</span><span class="s">none</span>
</span><span class='line'><span class="na">VLAN</span><span class="o">=</span><span class="s">yes</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now we&rsquo;re ready to kick off OpenStack installation. This can be done with a single command that needs to be executed on the Control node. Note that <code>eth1.100</code> interface is spelled as <code>eth1_100</code> in the last line.</p>

<figure class='code'><figcaption><span>Controller</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>packstack --allinone <span class="se">\</span>
</span><span class='line'>    --os-cinder-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-ceilometer-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-trove-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-ironic-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --nagios-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-swift-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-gnocchi-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-aodh-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-neutron-ovs-bridge-mappings<span class="o">=</span>extnet:br-ex <span class="se">\</span>
</span><span class='line'>    --os-neutron-ovs-bridge-interfaces<span class="o">=</span>br-ex:eth1.300 <span class="se">\</span>
</span><span class='line'>    --os-neutron-ml2-type-drivers<span class="o">=</span>vxlan,flat <span class="se">\</span>
</span><span class='line'>    --provision-demo<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-compute-hosts<span class="o">=</span>192.168.91.10,192.168.91.11,192.168.91.12 <span class="se">\</span>
</span><span class='line'>    --os-neutron-ovs-tunnel-if<span class="o">=</span>eth1_100
</span></code></pre></td></tr></table></div></figure>


<h2>Creating a virtual network for a pair of VMs</h2>

<p>Once again, follow all steps from &ldquo;Configuring Openstack networking&rdquo; section of my <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous blogpost</a>. Only this time when setting up a public subnet, update the subnet details to match our current environment:</p>

<figure class='code'><figcaption><span>Step 3 - Creating a public subnet</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>  neutron subnet-create --name public_subnet <span class="se">\</span>
</span><span class='line'>    --enable_dhcp<span class="o">=</span>False <span class="se">\</span>
</span><span class='line'>    --allocation-pool<span class="o">=</span><span class="nv">start</span><span class="o">=</span>192.168.247.90,end<span class="o">=</span>192.168.247.126 <span class="se">\</span>
</span><span class='line'>    --gateway<span class="o">=</span>192.168.247.1 external_network 192.168.247.0/24
</span></code></pre></td></tr></table></div></figure>


<h2>Nova-scheduler and setting up host aggregates</h2>

<p>OpenStack&rsquo;s Nova project is responsible for managing virtual machines. Nova controller views all available compute nodes as a single pool of resources. When a new VM is to be instantiated, a special process called nova-scheduler examines all available compute nodes and selects the &ldquo;best&rdquo; one based on a special algorithm, which normally takes into account amount of RAM, CPU and other host capabilities.</p>

<p>To make our host selection a little bit more deterministic, we can define a group of compute servers via <strong>host aggregates</strong>, which will be used by nova-scheduler in its selection algorithm. Normally it could include all servers in a single rack or a row of racks. In our case we&rsquo;ll setup two host aggregates each with a single compute host. This way we&rsquo;ll be able to select exactly which compute host to use when instantiating a new virtual machine.</p>

<p>To setup it up, from Horizon&rsquo;s dashboard navigate to Admin -> System and create two host aggregates <strong>comp-1</strong> and <strong>comp-2</strong>, each including a single compute host.</p>

<h2>Creating workloads and final testing</h2>

<p>Using a process described in &ldquo;Spinning up a VM&rdquo; section of my <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous blogpost</a>, create a couple of virtual machines assigning them to different host aggregates created earlier.</p>

<h2>Security and Remote access</h2>

<p>To access these virtual machines we need to give them a <a href="https://www.rdoproject.org/networking/floating-ip-range/">floating</a> ip address from the External subnet range. To do that navigate to Project -> Compute -> Instances and select <strong>Associate Floating IP</strong> from the Actions drop-down menu.</p>

<p>The final steps is to allow remote SSH access. Each new VM inherits ACLs from a default security group. So the easiest way to allow SSH is to go to Project -> Compute -> Access &amp; Security and add a rule to allow inbound SSH connections for the default security group.</p>

<h2>Verification</h2>

<p>At this stage you should be able to SSH into the floating IP addresses assigned to the two new VMs using the default credentials. Feel free to poke around and explore Horizon&rsquo;s interface a bit more. For example, try setting up an SSH key pair and re-build our two VMs to allow passwordless SSH access.</p>

<h2>What to expect next</h2>

<p>In the next post we&rsquo;ll explore some of the basic concepts of OpenStack&rsquo;s SDN. We&rsquo;ll peak inside the internal implementation of virtual networks and see what are some of their limitations and drawbacks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack on UNetlab]]></title>
    <link href="http://networkop.github.io/blog/2016/04/04/openstack-unl/"/>
    <updated>2016-04-04T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2016/04/04/openstack-unl</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;m going to show how to get a running instance of Openstack inside a UNetLab virtual machine.</p>

<!--more-->


<p><img class="center" src="http://networkop.github.io/images/unl-os.png"></p>

<h2>What the hell am I trying to do?</h2>

<p>I admit that running Openstack on anything other than baremetal is nonsense. So why would anyone want to run it with two layers of virtualisation underneath? My goal is to explore some of the new SDN/NFV technologies without leaving the confines on my home area network and/or racking up a triple-digit electricity bill. I also wanted to be able to swap underlay networks without spending hours trying to plumb together virtualized switches and servers from multiple vendors. That&rsquo;s why I&rsquo;ve decided to use UNetLab VM as a host for my Openstack lab. This would allow me to easily assemble any type of underlay, WAN or DCI network and with hardware virtualisation support I can afford to run Openstack double-nested inside Workstation and Qemu on my dual-core i7 without too much of a performance penalty. After all, <a href="https://www.ravellosystems.com/technology/hvx">some companies</a> even managed to turn similar things into a commercial product.</p>

<p>My interest in Openstack is strictly limited by networking, that&rsquo;s why a lot of the things you&rsquo;ll see in this and following posts will not be applicable to a real-life production environment. However, as far as networking is concerned, I&rsquo;ll try to stick as close to the official Openstack <a href="http://docs.openstack.org/openstack-ops/content/example_architecture.html">network design</a> as possible. I&rsquo;ll be using <a href="https://www.rdoproject.org">RDO</a> to deploy Openstack. The specific method will be Packstack which is a collection of Puppet modules used to deploy Openstack components.</p>

<p>Why have I not went the OpenDaylight/Mininet way if I wanted to play with SDN/NFV? Because I wanted something more realistic to play with, that wouldn&rsquo;t feel like vendor&rsquo;s powerpoint presentation. Plus there&rsquo;s plenty of resources on the &lsquo;net about it anyway.</p>

<p>So, without further ado, let&rsquo;s get cracking.</p>

<h2>Setting the scene</h2>

<p>On my Windows 8 laptop I&rsquo;ve got a UNL virtual machine running inside a VMWare Workstation.. I&rsquo;ve <a href="http://www.unetlab.com/download/">downloaded</a> and <a href="http://www.unetlab.com/2014/11/upgrade-unetlab-installation/">upgraded</a> a pre-built UNL VM image. I&rsquo;ve also downloaded a copy of the <a href="http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1511.iso">Centos 7 minimal ISO image</a> and copied it over to my UNL VM&rsquo;s home directory.</p>

<p>For network access I&rsquo;ll be using VMWware Workstation&rsquo;s NAT interface. It&rsquo;s currently configured with <code>192.168.91.0/24</code> subnet with DHCP range of <code>.128-.254</code>. Therefore I&rsquo;ll be using <code>.10-.126</code> to allocate IPs to my Openstack servers.</p>

<h2>Creating a custom node type in UNL</h2>

<p>Every node type inside UNL has its own unique settings. Some settings, like amount of RAM, CPU or number of network interfaces, can be changed during node instantiation, while some of them remain &ldquo;baked in&rdquo;. Say, for example, the default &ldquo;Linux&rdquo; template creates nodes with default <strong>Qemu Virtual CPU</strong> which doesn&rsquo;t support the hardware virtualisation (<strong>VT-X/AMD-V</strong>) <a href="http://docs.openstack.org/liberty/config-reference/content/kvm.html">required</a> by Openstack. In order to change that you can either edit the existing node template or follow these steps to create a new one:</p>

<ol>
<li><p>Add Openstack node definition to initialization file <code>/opt/unetlab/html/includes/init.php</code>.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'>    <span class="s1">&#39;linux&#39;</span>                 <span class="o">=&gt;</span>      <span class="s1">&#39;Linux&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s1">&#39;openstack&#39;</span>             <span class="o">=&gt;</span>      <span class="s1">&#39;Openstack&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s1">&#39;mikrotik&#39;</span>              <span class="o">=&gt;</span>      <span class="s1">&#39;MikroTik RouterOS&#39;</span><span class="p">,</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create a new Openstack node template based on existing linux node template.</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>cp /opt/unetlab/html/templates/linux.php /opt/unetlab/html/templates/openstack.php
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Edit the template file replacing all occurences of &lsquo;Linux&rsquo; with &lsquo;Openstack&rsquo;</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>sed -i <span class="s1">&#39;s/Linux/Openstack/g; s/linux/openstack/g&#39;</span> /opt/unetlab/html/templates/openstack.php
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Edit the template file to double the RAM and CPU and pass all host&rsquo;s CPU instructions to Openstack nodes</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>sed -i <span class="s1">&#39;s/2048/4096/; s/(cpu.*) = 1/\1 = 2/; s/(order=)dc/\1cd -cpu host/&#39;</span> /opt/unetlab/html/templates/openstack.php
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
</ol>


<p>At this point you should be able to navigate to UNL&rsquo;s web interface and find a new node of type Openstack. However you won&rsquo;t be able to create it until you have at least one image, which is what we&rsquo;re going to build next.</p>

<h2>Building a Linux VM inside UNetLab</h2>

<p>Now we need to create a CentOS image inside a UNL. One way to do it is build it inside a VMWare Workstation, copy it to UNL and convert the <strong>.vmdk</strong> to <strong>.qcow2</strong>. However, when I tried doing this I ran into a problem with CentOS not finding the correct disk partitions during bootup. The workaround was to boot into rescue mode and rebuild the initramfs. For those feeling adventurous, I would recommend checking out the following links [<a href="https://wiki.centos.org/TipsAndTricks/CreateNewInitrd">1</a>, <a href="http://advancelinux.blogspot.com.au/2013/06/how-to-rebuild-initrd-or-initramfs-in.html">2</a>, <a href="http://forums.fedoraforum.org/showthread.php?t=288020">3</a>] before trying this option.<br/>
The other option is to build CentOS inside UNL from scratch. This is how you can do it:</p>

<ol>
<li><p>Create a new directory for Openstack image</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>mkdir -p /opt/unetlab/addons/qemu/openstack-1
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create a link to CentOS ISO boot image from our new directory</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>ln -s ~/CentOS-7-x86_64-Minimal-1511.iso /opt/unetlab/addons/qemu/openstack-1/cdrom.iso
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create a blank 6Gb disk image</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>/opt/qemu/bin/qemu-img create -f qcow2 -o <span class="nv">preallocation</span><span class="o">=</span>metadata /opt/unetlab/addons/qemu/openstack-1/virtioa.qcow2 6G
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p> If you want to create <strong>snapshots</strong> at any stage of the process you&rsquo;d need to use a copy of this file under /opt/unetlab/tmp/pod_id/lab_uuid/node_id/ directory</p></li>
</ol>


<p>Now you should be able to successfully create an Openstack node and connect it to Internet. Create a new network that would have Internet connectivity (in my case it&rsquo;s <strong>pnet0</strong>) and connect it to Openstack&rsquo;s <strong>eth0</strong>.  At this stage we have everything ready to start installing Openstack, but before we move on let me take a quick detour to tell you about my ordeals with VNC integration.</p>

<h2>Optional: Integrating TightVNC with UNL</h2>

<p>For some unknown reason UltraVNC does not work well on my laptop. My sessions would often crash or start minimised with the only option to close the window. That&rsquo;s not the only thing not working properly on my laptop thanks to the corporate policies with half of the sh*t locked down for <em>security</em> reasons.<br/>
So instead of mucking around with <strong>Ultra</strong> I decided to give me old pal <strong>Tight</strong>VNC a go. The setup process is very similar to the <a href="http://www.unetlab.com/2015/03/url-telnet-ssh-vnc-integration-on-windows/">official VNC integration guide</a> with the following exceptions:</p>

<ol>
<li><p>The wrapper file simply strips the leading &lsquo;vnc://&rsquo; and trailing &lsquo;/&rsquo; off the passed argument</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='winbatch'><span class='line'>   <span class="k">SET</span> <span class="nv">arg</span><span class="o">=</span><span class="nv">%1</span>
</span><span class='line'>   <span class="k">SET</span> <span class="nv">arg</span><span class="o">=</span><span class="nv">%arg:~6%</span>
</span><span class='line'>   <span class="k">SET</span> <span class="nv">arg</span><span class="o">=</span><span class="nv">%arg:~0</span><span class="p">,</span><span class="m">-1</span>%
</span><span class='line'>   start <span class="s2">&quot;&quot;</span> <span class="s2">&quot;c:\Program Files\TightVNC\tvnviewer.exe&quot;</span> <span class="nv">%arg%</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>The registry entry now points to the TightVNC wrapper</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='registry'><span class='line'>   <span class="k">[</span><span class="nb">HKEY_CLASSES_ROOT</span><span class="k">\vnc\shell\open\command]</span>
</span><span class='line'>   <span class="na">@</span><span class="o">=</span><span class="s">&quot;\&quot;c:\Program Files\TightVNC\wrapper.bat\&quot; %1&quot;</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
</ol>


<h2>Installing CentOS and Openstack</h2>

<p>Finally, we&rsquo;ve got all our ducks lined up in a row and we&rsquo;re ready to shoot. Fire up the Openstack node inside UNL and click on it to open a vnc session. Proceed to install CentOS with default options. You need to confirm which <strong>hard disk</strong> to use and setup the <strong>hostname</strong> and the <strong>root password</strong> during installation process.
As I mentioned earlier, we&rsquo;ll be using RDO&rsquo;s Packstack to deploy all the necessary Openstack components. The whole installation process will be quite simple and can be found on the RDO&rsquo;s <a href="https://www.rdoproject.org/install/quickstart/">quickstart page</a>. Here is my slightly modified version of installation process:</p>

<ol>
<li><p>Disable Network Manager and SELinux.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>service NetworkManager stop
</span><span class='line'>    <span class="nv">$ </span>systemctl disable NetworkManager.service
</span><span class='line'>    <span class="nv">$ </span>setenforce 0
</span><span class='line'>    <span class="nv">$ </span>sed -i <span class="s1">&#39;s/enforcing/permissive/&#39;</span> /etc/selinux/config
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Configure static IP address <code>192.168.91.10</code> on the network interface. <br/>
 Assuming your interface name is <code>eth0</code> make sure you /etc/sysconfig/network-scripts/ifcfg-eth0 looks something like this:</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">TYPE</span><span class="o">=</span><span class="s2">&quot;Ethernet&quot;</span>
</span><span class='line'>    <span class="nv">BOOTPROTO</span><span class="o">=</span><span class="s2">&quot;static&quot;</span>
</span><span class='line'>    <span class="nv">IPADDR</span><span class="o">=</span>192.168.91.10
</span><span class='line'>    <span class="nv">PREFIX</span><span class="o">=</span>24
</span><span class='line'>    <span class="nv">GATEWAY</span><span class="o">=</span>192.168.91.2
</span><span class='line'>    <span class="nv">DNS1</span><span class="o">=</span>192.168.91.2
</span><span class='line'>    <span class="nv">NAME</span><span class="o">=</span><span class="s2">&quot;eth0&quot;</span>
</span><span class='line'>    <span class="nv">DEVICE</span><span class="o">=</span><span class="s2">&quot;eth0&quot;</span>
</span><span class='line'>    <span class="nv">ONBOOT</span><span class="o">=</span><span class="s2">&quot;yes&quot;</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  Issue a <code>service network restart</code> and reconnect to the new static IP address. Make sure that you still have access to Internet after making this change.</p></li>
<li><p>Setup RDO repositories</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>sudo yum install -y <a href="https://rdoproject.org/repos/rdo-release.rpm">https://rdoproject.org/repos/rdo-release.rpm</a>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Update your current packages</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>sudo yum update -y
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Install Packstack</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>sudo yum install -y openstack-packstack
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  That&rsquo;s where it&rsquo;d make sense to take a snapshot with <code>qemu-img snapshot -c pre-install virtioa.qcow2</code> command</p></li>
<li><p>Deploy a single-node Openstack environment</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>packstack <span class="se">-</span>-allinone <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-cinder-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-ceilometer-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-trove-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-ironic-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-nagios-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-swift-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-neutron-ovs-bridge-mappings<span class="o">=</span>extnet:br-ex <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-neutron-ovs-bridge-interfaces<span class="o">=</span>br-ex:eth0 <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-neutron-ml2-type-drivers<span class="o">=</span>vxlan,flat <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-provision-demo<span class="o">=</span>n
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  Here we&rsquo;re overriding some of the default Packstack options. We&rsquo;re not installing some of the components we&rsquo;re not going to use and setting up a name (<strong>extnet</strong>) for our external physical segment, which we&rsquo;ll use in the next section.</p></li>
</ol>


<p>At the end of these 4 steps you should be able to navigate to Horizon (Openstack&rsquo;s dashboard) by typing <code>http://192.168.91.10</code> in your browser. You can find login credentials in the <code>~/keystonerc_admin</code> file.</p>

<h2>Configuring Openstack networking</h2>

<p>At this stage we need to setup virtual networking infrastructure inside Openstack. This will be almost the same as described in RDO&rsquo;s external network <a href="https://www.rdoproject.org/networking/neutron-with-existing-external-network/">setup guide</a>. The only exceptions will be the <a href="https://www.rdoproject.org/networking/difference-between-floating-ip-and-private-ip/">floating IP range</a>, which will match our existing environment, and the fact that we&rsquo;re no going to setup any additional tenants yet. This is how our topology will look like:</p>

<p><img class="center" src="http://networkop.github.io/images/os-net-1.png"></p>

<ol>
<li><p>Switch to Openstack&rsquo;s <code>admin</code> user
 <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span><span class="nb">source</span> ~/keystonerc_admin
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create external network
 <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    neutron net-create external_network <span class="se">-</span>-provider:network_type flat <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-provider:physical_network extnet  <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-router:external <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-shared
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create a public subnet</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    neutron subnet-create <span class="se">-</span>-name public_subnet <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-enable_dhcp<span class="o">=</span>False <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-allocation-pool<span class="o">=</span><span class="nv">start</span><span class="o">=</span>192.168.91.90,end<span class="o">=</span>192.168.91.126 <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-gateway<span class="o">=</span>192.168.91.2 external_network 192.168.91.0/24
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  Default gateway is VMware&rsquo;s NAT IP address</p></li>
<li><p>Create a private network and subnet</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    neutron net-create private_network
</span><span class='line'>    neutron subnet-create <span class="se">-</span>-name private_subnet private_network 10.0.0.0/24 <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-dns-nameserver 8.8.8.8
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>   This network is not routable outside of Openstack and is used for inter-VM communication</p></li>
<li><p>Create a virtual router and attach it to both networks</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    neutron router-create router
</span><span class='line'>    neutron router-gateway-set router external_network
</span><span class='line'>    neutron router-interface-add router private_subnet
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
</ol>


<p>Make sure to check out the visualisation of our newly created network topology in Horizon, it&rsquo;s amazing.</p>

<h2>Spinning up a VM</h2>

<p>There&rsquo;s no point in installing Openstack just for the sake of it. Our final step would be to create a working virtual machine that would be able to connect to Internet.</p>

<ol>
<li><p>Download a test linux image</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    curl <a href="http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img">http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img</a> <span class="p">|</span> glance <span class="se">\</span>
</span><span class='line'>    image-create <span class="se">-</span>-name<span class="o">=</span><span class="s1">&#39;cirros image&#39;</span> <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-visibility<span class="o">=</span>public <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-container-format<span class="o">=</span>bare <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-disk-format<span class="o">=</span>qcow2
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>From Horizon&rsquo;s home page navigate to Project -> Compute -> Images.</p></li>
<li><p>Click on <code>Launch Instance</code> and give the new VM a name.</p></li>
<li><p>Make sure it&rsquo;s attached to <code>private_network</code> under the Networking tab.</p></li>
<li><p>Less then a minute later the status should change to <code>Active</code> and you can navigate to VM&rsquo;s console by clicking on its name and going to <code>Console</code> tab.</p></li>
<li><p>Login using the default credentials (<strong>cirros/cubswin:)</strong>) and verify Internet access by pinging google.com.</p></li>
</ol>


<p>Congratulations, we have successfully created a VM running inside a KVM inside a KVM inside a VMWare Workstation inside Windows!</p>

<h2>What to expect next</h2>

<p>Unlike my other post series, I don&rsquo;t have a clear goal at this stage so I guess I&rsquo;ll continue playing around with different underlays for multi-node Openstack and then move on to various SDN solutions available like OpenDayLight and OpenContrail. Unless I lose interest half way through, which happened in the past. But until that happens, stay tuned for more.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network-CI Part 3 - OSPF to BGP Migration in Active/Standby DC]]></title>
    <link href="http://networkop.github.io/blog/2016/03/23/network-ci-demo-large/"/>
    <updated>2016-03-23T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2016/03/23/network-ci-demo-large</id>
    <content type="html"><![CDATA[<p>The final post in a series demonstrates how to use the <strong>network-ci</strong> tools to safely replace a core routing protocol inside a small Active/Standby Data Centre.</p>

<!--more-->


<h2>Current network overview</h2>

<p>Let&rsquo;s start by taking a high-level look at our DC network routing topology. The core routing protocol is OSPF, it is responsible for distributing routing information between the Core and WAN layers of the network. WAN layer consists of two MPLS L3VPN services running BGP as PE-CE protocol and two DMVPN Hubs running EIGRP. All WAN layer devices perform mutual redistribution between the respective WAN protocol and OSPF.</p>

<p><img class="center" src="http://networkop.github.io/images/network-ci-dc-before.png" title="Current network topology" ></p>

<h2>Target network overview</h2>

<p>The task is to replace OSPF with BGP as the core routing protocol inside the Data Centre. There are many advantages to using BGP inside a DC, in our case they are:</p>

<ul>
<li>Enhanced traffic routing and filtering policies</li>
<li>Reduced number of redistribution points</li>
<li>Because Ivan Pepelnjak <a href="http://blog.ipspace.net/2016/02/using-bgp-in-data-center-fabrics.html">said so</a></li>
</ul>


<p>We&rsquo;re not going getting rid of OSPF completely, but rather reduce its function to a simple distribution of <em>internal</em> DC prefixes. BGP will be running on top of OSPF and distribute all the DC and WAN <em>summary</em> prefixes.</p>

<p><img class="center" src="http://networkop.github.io/images/network-ci-dc-after.png" title="Target network topology" ></p>

<h2>Physical topology overview</h2>

<p>Now let&rsquo;s take a closer look at the network that we&rsquo;re going to emulate. All green devices on the left-hand side constitute the <strong>Active</strong> Data Centre, that is where all the traffic will flow under normal conditions. All green devices have red <strong>Standby</strong> counterparts. These devices will pick up the function of traffic forwarding in case their green peer becomes unavailable.</p>

<p><img class="center" src="http://networkop.github.io/images/network-ci-dc-full.png" title="Full demo topology" ></p>

<p>When simulating a real-life network it&rsquo;s often impossible to fit an exact replica inside a network emulator. That&rsquo;s why using <strong>mock</strong> devices is a crucial part in every simulation. The function of a mock is to approximate a set of network devices. There&rsquo;s a number of mock devices on our diagram colour-coded in purple. These devices simulate the remaining parts of the network. For example, <strong>Cloud</strong> devices may represent <abbr title=" Top-Of-the-Rack">TOR</abbr> switches, while <strong>MPLS/DMVPN</strong> devices represent remote WAN sites. Normally these devices will have some made-up configuration that best reflects real life, but not necessarily a copy-paste from an existing network device.</p>

<p>It&rsquo;s also important to pick the right amount of mock devices to strike the balance between accuracy and complexity. For example, for WAN sites it may suffice to create one site per unique combination of WAN links to make sure WAN failover works as expected.</p>

<h2>Traffic flow definition</h2>

<p>Let&rsquo;s define how we would expect the traffic to flow through our network. Let&rsquo;s assume that we should always try to use MPLS links when possible and only use DMVPN when both MPLS links are down. This translates to the following order of WAN links' precedence:</p>

<ol>
<li>Primary MPLS link</li>
<li>Standby MPLS link</li>
<li>Primary DMVPN link</li>
<li>Standby DMVPN link</li>
</ol>


<p>Based on that we can create the following traffic flows definition for network working under normal conditions.</p>

<figure class='code'><figcaption><span>/network/tests/traffic_flows.txt</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>1 Failed None
</span><span class='line'>  From FW to MPLS-DMVPN via Primary-WAN, Primary-MPLS
</span><span class='line'>  From FW to DMVPN-ONLY via Primary-CORE-SW, Primary-DMVPN
</span><span class='line'>  From FW to MPLS-ONLY via Primary-WAN, Primary-MPLS
</span><span class='line'>  From Cloud-1 to FW Loopback0 via Primary-CORE-SW
</span><span class='line'>  From Cloud-2 to MPLS-DMVPN via Primary-WAN, Primary-MPLS
</span></code></pre></td></tr></table></div></figure>


<p>We expect all traffic to flow through active devices even when the path may be suboptimal, like it&rsquo;s the case with traffic from Cloud-2. Similarly, we can create traffic flows definitions for different failure conditions. The complete <a href="https://github.com/networkop/network-ci/blob/master/acme-large/network/tests/traffic_flows.txt">traffic flows definition file</a> contains 2 additional failure scenarios covering the outage of the primary MPLS link and a complete outage of the primary core switch.</p>

<h2>Workflow example</h2>

<p>This is how you would approach a project like this.</p>

<ol>
<li>Get a copy of network-ci <a href="http://networkop.github.io/blog/2016/02/25/network-ci-dev-setup/">VM</a></li>
<li>Get a local copy of network-ci <a href="https://github.com/networkop/network-ci/tree/master/acme-large">tools</a></li>
<li>Copy configuration from real-life devices into the <a href="https://github.com/networkop/network-ci/tree/master/acme-large/config">config directory</a></li>
<li>Add configuration files for mock devices to the same directory</li>
<li>Review the <a href="https://github.com/networkop/network-ci/blob/master/acme-large/network/topology.py">topology definition file</a> to make sure it reflects our physical diagram</li>
<li>Review the UNL <a href="https://github.com/networkop/network-ci/blob/master/acme-large/network/unetlab.yml">configuration file</a> to make sure it points to the correct IP address assigned to your network-ci VM</li>
<li>Kick-off topology build inside UNL by running <code>./0_built_topo.py</code> script</li>
<li>Verify that traffic flows as expected with <code>2_test.py</code> script</li>
<li>Start the real-time monitoring with <code>1_monitor.py</code> script</li>
<li>Implement required changes on individual devices (all required changes can be found in <a href="https://github.com/networkop/network-ci/blob/master/acme-large/network/ospf-bgp.txt">ospf-bgp.txt</a> file)</li>
<li>Make sure that the network still behaves as before by running <code>2_test.py</code> script</li>
<li>Destroy the topology in UNL by running <code>3_destroy_topo.py</code></li>
</ol>


<h2>Continuous Integration</h2>

<p>In the <a href="http://networkop.github.io/blog/2016/03/03/network-ci-demo-small/">previous post</a> I&rsquo;ve showed how to use Jenkins to setup the CI environment for a small demo network. The same method can be applied to setup the job for our small Data Centre. It is simply a matter of changing the directory name from <strong>acme-small</strong> to <strong>acme-large</strong> in the first build step.</p>

<h2>Source code</h2>

<p>All code from this and previous posts is available on <a href="https://github.com/networkop/network-ci/tree/master/acme-large">Github</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network-CI Part 2 - Small Network Demo]]></title>
    <link href="http://networkop.github.io/blog/2016/03/03/network-ci-demo-small/"/>
    <updated>2016-03-03T00:00:00-08:00</updated>
    <id>http://networkop.github.io/blog/2016/03/03/network-ci-demo-small</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;ll demonstrate how to use the network-ci tools to automate the build, test and upgrade of a small 4-node network topology.</p>

<!--more-->


<h2>Demo network overview</h2>

<p>The network consists of 4 nodes interconnected via point-to-point links and running EIGRP as a routing protocol.</p>

<p><img class="center" src="http://networkop.github.io/images/ci-acme-small.jpg" title="Small demo topology" ></p>

<p>To create a local development environment you can clone my <a href="https://github.com/networkop/network-ci/tree/master/acme-small">repository</a> and reset it to work with your own Github account using <code>git remote set-url origin https://github.com/USERNAME/OTHERREPOSITORY.git</code> command.<br/>
Local development environment contains the following files describing the modelled topology:</p>

<ol>
<li>Configuration files for each node under the <code>./config</code> directory</li>
<li>Network topology in <code>./network/topology.py</code> modelled as a list of pairs of interconnected devices</li>
<li>UNetLab configuration file containing the IP address and username/passwords to access the server</li>
<li>Traffic flow test definitions under <code>./network/test</code> directory</li>
</ol>


<h2>Test definitions</h2>

<p>Traffic flow test file contains an ordered set of test scenarios that will be performed automatically. The following is an example that illustrates main capabilities of our test tools:</p>

<figure class='code'><figcaption><span>./network/tests/traffic_flows.txt</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>## Normal operations
</span><span class='line'>1 Failed None
</span><span class='line'>  From R1 to R3 via R2 or R4, R3
</span><span class='line'>  From R2 to R3 via R3
</span><span class='line'>  From R2 to R4 via R1 or R3
</span><span class='line'>
</span><span class='line'># Failed link between R1 and R2
</span><span class='line'>2 Failed R1 Gig1/1, R2 Gig0/0
</span><span class='line'>  From R1 to R2 via not R2, R3
</span><span class='line'>  From R2 to R4 via not R1, R4
</span></code></pre></td></tr></table></div></figure>


<p>Each scenario starts with a <strong>failure definition</strong>. It could be either <em>None</em>, which represents normal network conditions, or it could contain a list of interfaces that need to be failed. Following the failure definition are the actual tests. On each line we define source, destination and the path we expect the traffic to take. Path definition (everything following the &lsquo;via&rsquo; keyword) contains an ordered set of nodes and can use simple boolean operators like <strong>or</strong> or <strong>not</strong>.</p>

<p>Ping flow definition file is a lot shorter and simply contains a list of source/destination pairs to run a ping test between. All ping tests will execute concurrently and issue only 2 pings, therefore we&rsquo;ll only be able to detect connectivity loss if it lasts for more than 4 seconds.</p>

<h2>Jenkins setup</h2>

<p>In the previous post we&rsquo;ve automatically built a VM with Jenkins and UNetLab pre-installed. Before we can start using Jenkins we need to install a Github plugin, which can be done very easily from Jenkins GUI. Power up your <strong>vm-network-ci</strong> and open Jenkins home page at <code>http://VM_IP:8080</code>. From there navigate to <strong>Manage Jenkins -> Manage Plugins -> Available</strong>, search for and install the <strong>GitHub plugin</strong>.</p>

<h2>A quick Jenkins intro</h2>

<p>Inside Jenkins, <strong>a job</strong> represents a set of tasks that need to be automated for a particular project. Each job first waits for a trigger, which can be either a manual or an automatic event. When triggered, it connects to Github repository, downloads all the code to a local machine and executes a set of build steps defined in this job. A very simple workflow would looks like this:</p>

<ol>
<li>Developer commits and pushes a change to a Github repository</li>
<li>Github notifies Jenkins server by sending an HTTP POST request</li>
<li>Jenkins identifies the job that needs to be run and clones Github repo into a local directory</li>
<li>It then goes through and executes a set of build steps defined for this job</li>
<li>At the end you can optionally configure Jenkins to update the status of the build as described <a href="http://stackoverflow.com/questions/14274293/show-current-state-of-jenkins-build-on-github-repo">here</a></li>
</ol>


<h2>Using Jenkins for network testing</h2>

<ol>
<li>From Jenkins home page click on <strong>create new jobs</strong> and create a <em>Freestyle project</em> called <strong>acme-small</strong>.</li>
<li>Select the <strong>Github project</strong> option and enter a url of your Github repository (in my case its <a href="https://github.com/networkop/network-ci">https://github.com/networkop/network-ci</a>).</li>
<li>Under <strong>Source Code Management</strong> select <em>Git</em> and enter the same repository URL.</li>
<li>Under <strong>Additional Behaviours</strong> add a <em>Polling ignores commits in certain paths</em>. <br/>
Since I&rsquo;m keeping multiple subprojects in the same Github repo, I need to make sure that this job is only triggered if commit affected a particular directory.</li>
<li>Under <strong>Included Regions</strong> add <code>acme-small/.*</code> to only trigger builds for changes made to <strong>acme-small</strong> directory.</li>
<li>Optionally you can specify the build triggers to either build periodically or wait for changes to be pushed to Github.</li>
<li><p>Under <strong>Build</strong> add a new build step with the following shell commands:</p>

<pre><code class="`bash"> export UNL_IP="unl_ip_address"
 export PYTHONUNBUFFERED=1
 cd acme-small
 chmod +x 0_built_topo.py
 chmod +x 2_test.py
 chmod +x 3_destroy_topo.py
 ./0_built_topo.py
 ./2_test.py
 ./3_destroy_topo.py
</code></pre>

<p>The first two env variables setup the UNL&rsquo;s IP address of and disable IO buffering so that we can see the output produced by our scripts in real time. The remaining steps simply execute the build, test and destroy scripts in order.</p></li>
<li><p>Save the job and click on the <strong>Build Now</strong> to trigger the build manually.</p></li>
<li>In the <strong>Build History</strong> pane click on the latest build number (should be #1) and go to <em>Console Output</em>.</li>
<li>Observe how Jenkins builds, tests and destroys our demo topology</li>
</ol>


<h2>Network upgrade workflow</h2>

<p>Now imagine that a new requirements has come in to make sure that traffic from R1 to R3&rsquo;s Gig0/1 does not traverse R4 and goes via R2 instead, only falling back to R4 when R1-R2 link is down. In the following video I&rsquo;ll show how to use network-ci tools locally to implement and test this traffic engineering requirement.</p>

<div class="embed-video-container"><iframe src="//www.youtube.com/embed/GLOG9KZzP90" allowfullscreen></iframe></div>


<h2>Coming up</h2>

<p>In the next post I&rsquo;ll show how to apply the same workflow to automate the build, test and ugprade of a large 14-node topology.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network-CI Part 1 - Automatically Building a VM With UNetLab and Jenkins]]></title>
    <link href="http://networkop.github.io/blog/2016/02/25/network-ci-dev-setup/"/>
    <updated>2016-02-25T00:00:00-08:00</updated>
    <id>http://networkop.github.io/blog/2016/02/25/network-ci-dev-setup</id>
    <content type="html"><![CDATA[<p>Traditionally, the first post in the series describes how to setup a development environment. This time I&rsquo;ll do it DevOps-style. I&rsquo;ll show how to use Packer to automatically create and configure a VM with UNetLab and Jenkins pre-installed.</p>

<!--more-->


<p><img class="center" src="http://networkop.github.io/images/packer-unl-jenkins.png" title="Packer-UNL-Jenkins" ></p>

<h2>Packer intro</h2>

<p><a href="https://www.packer.io/">Packer</a> is a tool that can automatically create virtual machines for different hypervisors and cloud platforms. The goal is to produce identically configured VMs for either VirtualBox, VMWare, Amazon or Google clouds based on a single template file. If you&rsquo;re familiar with <a href="https://www.vagrantup.com/docs/">Vagrant</a>, then you can also use Packer to create custom Vagrant boxes. In our case, however, we&rsquo;re only concerned about VMWare since it&rsquo;s the only <a href="https://en.wikipedia.org/wiki/Hypervisor">type-2 hypervisor</a> that supports nested hardware virtualisation (e.g. Intel VT-x), a feature required by UNetLab to run some of the emulated images.</p>

<p>Packer builds VMs using a special template file. At the very least, this file describes how to:</p>

<ul>
<li><p>Build a VM</p></li>
<li><p>Provision and configure apps on a VM</p></li>
</ul>


<p>These two actions correspond to the <code>builders</code> and <code>provisioners</code> sections of the template file.</p>

<p>The <code>builders</code> section contains a set of instructions for a particular hypervisor or platform on how to build a VM. For example, it might contain the amount of  RAM, CPU and disk sizes, number and type of interfaces, OS boot instructions and so on.</p>

<p>The <code>provisioners</code> section contains a set of instructions to configure a VM. This section may be as simple as a list of shell scripts or may include a reference to Ansible playbook which will be executed after the VM is built.</p>

<p>You can find my Packer templates along with Ubuntu preseed and provisioner scripts in my <a href="https://github.com/networkop/packer-unl-jenkins">Gihub repository</a>. For those looking for deeper insights about how to build a packer template I can recommend an official Packer <a href="https://www.packer.io/intro/index.html">introduction docs</a>.</p>

<h2>Building a VM with Packer</h2>

<p>As I&rsquo;ve mentioned previously, I&rsquo;m using Windows as my primary development environment and VMWare Workstation as my hypervisor. Before you begin you also need to have <a href="https://www.packer.io/intro/getting-started/setup.html">Packer</a> and <a href="https://git-scm.com/download/win">git</a> installed.</p>

<figure class='code'><figcaption><span>1. Clone git repository</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='winbatch'><span class='line'>git clone https:<span class="n">//github.com/networkop/packer-unl-jenkins</span>
</span><span class='line'><span class="k">cd</span> packer-unl-jenkins
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>2. Start the build</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='winbatch'><span class='line'>packer build vmware.json
</span></code></pre></td></tr></table></div></figure>


<p>With a bit of luck, approximately 30 minutes later you should have a fully configured VM inside your VMWare Workstation waiting to be powered on. These are some of the features of this new VM:</p>

<ul>
<li>4 GB of RAM, 20GB of disk space, 2 dual-core vCPUs</li>
<li>1 Host-only and 1 NAT ethernet interfaces both using DHCP</li>
<li>Jenkins and UNetLab installed</li>
<li>Git and Python PIP packages installed</li>
<li>Username/password are <code>unl/admin</code></li>
</ul>


<p>Once powered on, you should be able to navigate to UNetLab&rsquo;s home page at <code>http://vm_ip:80</code> and Jenkins' home page and <code>http://vm_ip:8080</code>, where <code>vm_ip</code> is the IP of your new VM.</p>

<h2>IOU images</h2>

<p>Unfortunately IOU images are not publicly available so you&rsquo;re gonna have to find them yourself, which shouldn&rsquo;t be too hard. You&rsquo;ll also need to generate a license file for these images which, again, I&rsquo;m not going to discuss in this blog, but I can guarantee that you won&rsquo;t have to look farther than the 1st page of Google search to find all your answers. These are the remaining steps that you need to do:</p>

<ol>
<li>Obtain L2 and L3 IOU images</li>
<li>Generate a license file</li>
<li>Follow <a href="http://www.unetlab.com/2014/11/adding-cisco-iouiol-images/">these instructions</a> to install those images on the UNetLab server</li>
</ol>


<h2>non-DevOps way</h2>

<p>In case you&rsquo;re struggling with Packer here are the list of steps to setup a similar VM manually:</p>

<ol>
<li><a href="http://www.ubuntu.com/download/server">Download</a> your favourite Ubuntu Server image. Recommended release at the time of writing is 14.04.4.</li>
<li>Create a VM with at least 4GB of RAM, VT-x support and boot it off the Ubuntu ISO image.</li>
<li>Following instructions <a href="http://www.unetlab.com/2015/08/installing-unetlab-on-a-physical-server/">install Ubuntu and UNetLab</a>.</li>
<li>Install Jenkins as described on <a href="https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+on+Ubuntu">their wiki website</a></li>
<li>Install additional packages like git and pip. Refer to my Packer <a href="https://github.com/networkop/packer-unl-jenkins/blob/master/scripts/packages.sh">packages script</a> for commands.</li>
</ol>


<h2>Coming up</h2>

<p>In the next post I&rsquo;ll show how to setup Jenkins to do automatic network testing and verification.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network Continuous Integration and Delivery]]></title>
    <link href="http://networkop.github.io/blog/2016/02/19/network-ci-intro/"/>
    <updated>2016-02-19T00:00:00-08:00</updated>
    <id>http://networkop.github.io/blog/2016/02/19/network-ci-intro</id>
    <content type="html"><![CDATA[<p>In this series of posts I&rsquo;ll introduce the tools I&rsquo;ve been using for continuous network development and how they can be used with automation servers like Jenkins for network continuous integration and delivery.</p>

<!--more-->


<h2>CI/CD vs ITIL</h2>

<p>How do you implement changes in your network? In today&rsquo;s world there&rsquo;s 95% chance that you have to write up an <abbr title=" Request For Change">RFC</abbr>, submit it at least a week before the planned implementation date, go through at least one <abbr title=" Change Admission Board">CAB</abbr> meeting and only then, assuming it got approved, can you implement it. But the most important question is &lsquo;how do you test&rsquo;? Do you simply content yourself with a few pings or do you make sure all main routes are in place? And how often do you get a call the next morning from a very nervous client asking you to &lsquo;please have a look at the network performance issues&rsquo;?</p>

<p>Software developers have solved most of these problems for themselves. DevOps movement has brought forth ideas of Continuous Integration and Delivery (CI/CD) to streamline the change process and &lsquo;embrace&rsquo; the change rather than protect against it. But how applicable are those ideas to the networks of today? Can we simply rip and replace our CAB meetings with a Jenkins server and live happily ever after?  As always, things are getting difficult as you move down from Layer 7.</p>

<h2>Problem #1 - How to test</h2>

<p>Ever since the dawn of networking, the only tools that engineers could use for testing were traceroutes and pings. It&rsquo;s not necessarily bad since, after all, networks are supposed to be a simple packet transports and shouldn&rsquo;t be endowed with application-layer knowledge. Note that I&rsquo;m talking about traditional or, in SDN-era terms, &lsquo;underlay&rsquo; networks. The biggest problem with network testability is not the lack of test tools but rather lack of automation. For every ping and every traceroute we had to login a device, carefully craft the command including source interface names, VRFs and other various options and then interpret the output.<br/>
I have already explored the idea of automated network testing in my previous blog posts - <a href="http://networkop.github.io/blog/2015/06/15/simple-tdd-framework/">Building Network TDD framework</a> and <a href="http://networkop.github.io/blog/2015/07/17/tdd-quickstart/">Network TDD quickstart</a>. I even got lucky enough to get invited to one of the <a href="http://blog.ipspace.net/2015/11/test-driven-network-development-with.html">greatest networking podcasts</a> hosted by Ivan Pepelnjak.</p>

<h2>Problem #2 - Where to test</h2>

<p>Another big problem is the lack of testable network software. We&rsquo;ve only had IOU, vSRX and vEOS for the past 3-4 years and even now a lot of the real-world functionality remains unvirtualizable. However having those images is a lot better than not, even though some of them tend to crash and behave unreliably from time to time.</p>

<h2>Network CI</h2>

<p>Here I&rsquo;ve come to the actual gist of my post. I want to demonstrate the tools that I&rsquo;ve built and how I use them to automate a lot of the repetitive tasks to prepare for network deployments and upgrades. This is what these tools can do:</p>

<ul>
<li>Create a replica of almost any real-world network topology inside a network emulation environment</li>
<li>Apply configuration to all built devices</li>
<li>Verify real-time connectivity between nodes</li>
<li>Verify traffic flows under various failure conditions against pre-defined set rules</li>
<li>Shutdown and delete the network topology</li>
</ul>


<p>All these steps can be done automatically without making a single click in a GUI or entering a single command in a CLI. This is a sneak peak of what to expect later in the series:</p>

<div class="embed-video-container"><iframe src="//www.youtube.com/embed/jiZs0969RWI" allowfullscreen></iframe></div>


<p>Please don&rsquo;t judge me too harshly, this is my first experience with screencasts.</p>

<h2>Coming up</h2>

<p>In the following posts I&rsquo;ll show how to:</p>

<ul>
<li><a href="http://networkop.github.io/blog/2016/02/25/network-ci-dev-setup/">Setup continuous delivery environment with Jenkins and UNetLab</a></li>
<li><a href="http://networkop.github.io/blog/2016/03/03/network-ci-demo-small/">Create test cases to enable automatic testing by Jenkins server</a></li>
<li><a href="http://networkop.github.io/blog/2016/03/03/network-ci-demo-large/">Safely replace a core routing protocol inside an Active/Standby DC</a></li>
</ul>


<p>If that sounds interesting to you - stay tuned.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[REST for Network Engineers Part 3 - Advanced Operations With UnetLab]]></title>
    <link href="http://networkop.github.io/blog/2016/01/17/rest-unl-advanced/"/>
    <updated>2016-01-17T00:00:00-08:00</updated>
    <id>http://networkop.github.io/blog/2016/01/17/rest-unl-advanced</id>
    <content type="html"><![CDATA[<p>In this post we&rsquo;ll look at how to create arbitrary topologies and push configuration to Nodes in UNetlab via REST SDK. We&rsquo;ll conclude by extending our sample application to create and configure a 3-node topology and enable full connectivity between all nodes.</p>

<!--more-->


<h2>Extracting Node&rsquo;s UUID</h2>

<p>In the <a href="http://networkop.github.io/blog/2016/01/06/rest-basic-operations/">previous post</a> we have learned how to create a Node. To perform further actions on it we need to know it&rsquo;s UUID. According to HTTP specification <code>201 - Created</code> response SHOULD return a <code>Location</code> header with resource URI, which would contain resource UUID. However, UNetLab&rsquo;s implementation does not return a Location header so we need to extract that information ourselves. To do that we&rsquo;ll use the previously defined <code>.get_nodes()</code> method which returns all attributes of all configured Nodes in the following format:</p>

<p><img class="centre" src="http://networkop.github.io/images/rest-unl-get-nodes.png" title="REST SDK GET ALL NODES" ></p>

<p>The best place to extract UUID would be when Node is being created. After the <code>Create</code> request has been sent to a server we&rsquo;ll send another <code>Read</code> request and extract all attributes of a Node based on its name.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">UnlNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lab</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
</span><span class='line'>      <span class="o">...</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="s">&#39;url&#39;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">_get_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s">&#39;data&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">get_obj_by_name</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p> To extract data from the payload we need to call <code>.json()</code> on the returned HTTP response and look for the <code>data</code> key inside that JSON object. The returned value will contain all attributes including the UUID and access URL which we&rsquo;ll use later. To help us find a Node object matching a name we&rsquo;ll use a helper function defined below:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/helper.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">get_obj_by_name</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">obj_id</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">objects</span><span class="p">[</span><span class="n">obj_id</span><span class="p">][</span><span class="s">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">objects</span><span class="p">[</span><span class="n">obj_id</span><span class="p">]</span>
</span><span class='line'>    <span class="k">return</span> <span class="bp">None</span>
</span></code></pre></td></tr></table></div></figure>


<p>Needless to say that we MUST have unique names for all nodes otherwise it won&rsquo;t be possible to do the matching. It&rsquo;s quite a safe assumption to make in most cases however no built-in error checking will be performed by the REST SDK to prevent you from doing it.</p>

<h2>UnlNet implementation</h2>

<p>Before we start connecting Nodes together we need to create a Network. As per the <a href="http://networkop.github.io/blog/2016/01/06/rest-basic-operations/">design</a>, UnlNet will be a class holding a pointer to the UnlLab object which created it. The structure of the class will be very similar to UnlNode.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">REST_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>              <span class="o">...</span> <span class="p">,</span>
</span><span class='line'>              <span class="s">&#39;create_net&#39;</span><span class="p">:</span> <span class="s">&#39;/labs/{lab_name}/networks&#39;</span><span class="p">,</span>
</span><span class='line'>              <span class="s">&#39;get_nets&#39;</span><span class="p">:</span> <span class="s">&#39;/labs/{lab_name}/networks&#39;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlLab</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">create_net</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UnlNet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">get_nets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;get_nets&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">api_url</span> <span class="o">=</span> <span class="n">api_call</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">api_call</span><span class="p">,</span> <span class="n">lab_name</span><span class="o">=</span><span class="n">append_unl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">api_url</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlNet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lab</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;create_net&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">unl</span><span class="p">,</span> <span class="n">lab</span><span class="p">,</span> <span class="n">name</span>
</span><span class='line'>        <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="s">&#39;bridge&#39;</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>
</span><span class='line'>        <span class="n">api_url</span> <span class="o">=</span> <span class="n">api_call</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">api_call</span><span class="p">,</span> <span class="n">lab_name</span><span class="o">=</span><span class="n">append_unl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="n">api_url</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_net</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">_get_net</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">nets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">get_nets</span><span class="p">()</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s">&#39;data&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">get_obj_by_name</span><span class="p">(</span><span class="n">nets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Connecting Nodes to a network</h2>

<p>Official <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/">Unetlab API guide</a> is still under development and doesn&rsquo;t specify how to connect a Node to a network. If you want to find out the syntax for this or any other unspecified API call you can always try that in a Web GUI while capturing traffic with Wireshark. That is how I&rsquo;ve discovered that to connect a Node to a network we need to send an Update request with payload containing mapping between Node&rsquo;s interface ID and Network ID.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">REST_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>                <span class="o">...</span> <span class="p">,</span>
</span><span class='line'>                <span class="s">&#39;connect_interface&#39;</span><span class="p">:</span> <span class="s">&#39;/labs/{lab_name}/nodes/{node_id}/interfaces&#39;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">connect_interface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intf_name</span><span class="p">,</span> <span class="n">net</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;connect_interface&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">api_url</span> <span class="o">=</span> <span class="n">api_call</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">api_call</span><span class="p">,</span> <span class="n">lab_name</span><span class="o">=</span><span class="n">append_unl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">node_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</span><span class='line'>        <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="n">get_intf_id</span><span class="p">(</span><span class="n">intf_name</span><span class="p">):</span> <span class="n">net</span><span class="o">.</span><span class="n">id</span><span class="p">}</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">update_object</span><span class="p">(</span><span class="n">api_url</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span></code></pre></td></tr></table></div></figure>


<p>The ID of an interface &ldquo;Ethernet x/y” of an IOU device can be easily calculated based on the formula <code>id = x + (y * 16)</code> as described <a href="http://evilrouters.net/2011/01/09/creating-a-netmap-file-for-iou/">here</a>. This will be accomplished with yet another helper function:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/helper.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">get_intf_id</span><span class="p">(</span><span class="n">intf_name</span><span class="p">):</span>
</span><span class='line'>    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;\d+&#39;</span><span class="p">,</span> <span class="n">intf_name</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Connecting Nodes to each other</h2>

<p>To create multi-access topologies we would need to maintain an internal mapping between Node&rsquo;s interface and the network it&rsquo;s attached to. However, if we assume that all links are point-to-point, we can not only simplify our implementation but also enable REST client to ignore the notion of a network all together.  We&rsquo;ll simply assume that when device A connects to B our implementation will create a network called <code>A_B</code> in the background and connect both devices to it. This method will perform two separate REST calls and thus will return both responses in a tuple:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">UnlNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">connect_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">local_intf</span><span class="p">,</span> <span class="n">other_node</span><span class="p">,</span> <span class="n">other_intf</span><span class="p">):</span>
</span><span class='line'>    <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">create_net</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">other_node</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">name</span><span class="p">]))</span>
</span><span class='line'>    <span class="n">resp1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_interface</span><span class="p">(</span><span class="n">local_intf</span><span class="p">,</span> <span class="n">net</span><span class="p">)</span>
</span><span class='line'>    <span class="n">resp2</span> <span class="o">=</span> <span class="n">other_node</span><span class="o">.</span><span class="n">connect_interface</span><span class="p">(</span><span class="n">other_intf</span><span class="p">,</span> <span class="n">net</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">resp1</span><span class="p">,</span> <span class="n">resp2</span>
</span></code></pre></td></tr></table></div></figure>


<p>Assuming all links are point-to-point certainly decreases visibility of created networks and we would not be able to perform selective changes on them in the future. However it is a safe assumption to make for 99% of the networks that I&rsquo;m dealing with.</p>

<h2>Node Start, Stop and Delete</h2>

<p>These simple actions can easily be coded using TDD. I will omit the actual implementation and simply provide unit tests for readers to exercise their TDD skills again.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/tests/test_unl.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">AdvancedUnlNodeTest</span><span class="p">(</span><span class="n">UnlTests</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">(</span><span class="n">AdvancedUnlNodeTest</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">setUp</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">device_one</span> <span class="o">=</span> <span class="n">Router</span><span class="p">(</span><span class="s">&#39;R1&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">device_two</span> <span class="o">=</span> <span class="n">Router</span><span class="p">(</span><span class="s">&#39;R2&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">lab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">create_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">node_one</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device_one</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">node_two</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device_two</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">delete_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">(</span><span class="n">AdvancedUnlNodeTest</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">tearDown</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_start_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">stop_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">start_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_stop_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">start_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">stop_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_delete_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">delete_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_one</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_del_all_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">del_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">resp_2</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s">&#39;data&#39;</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_lab_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">resp_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">stop_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">del_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="n">resp_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp_1</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">resp_2</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s">&#39;data&#39;</span><span class="p">]))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The final, <code>lab_cleanup()</code> method is simply a shortcut to <code>stop_nodes()</code> followed by <code>del_all_nodes()</code>.<br/>
As always, link to full code is available at the end of this post.</p>

<h2>Pushing configuration to Nodes</h2>

<p>At this point of time UnetLab does not support configuration import so we&rsquo;re stuck with the only access method available - telnet. To push configuration into the Node we&rsquo;re gonna have to establish a telnet session to Node&rsquo;s URI (which we&rsquo;ve extracted earlier) and write all configuration into that session.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">UnlNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">send_config</span><span class="p">(</span><span class="n">wrap_conf</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Another helper function <code>wrap_conf()</code> prepends <code>enable</code> and appends <code>end</code> to make configuration suitable for pasting into the new IOU device.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/device.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">Router</span><span class="p">(</span><span class="n">Device</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">send_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
</span><span class='line'>        <span class="n">session</span> <span class="o">=</span> <span class="n">telnetlib</span><span class="o">.</span><span class="n">Telnet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url_ip</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">url_port</span><span class="p">)</span>
</span><span class='line'>        <span class="n">send_and_wait</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">result</span> <span class="o">=</span> <span class="n">send_and_wait</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>
</span><span class='line'>        <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span>
</span></code></pre></td></tr></table></div></figure>


<p>The biggest problem is that Nodes, when started, take some time to boot before we can access the CLI prompt. To overcome that I had to implement a dirty hack in a form of <code>send_and_wait()</code> helper function that simulates pressing the <code>Enter</code> button every 0.1 second until it sees a CLI prompt (either <code>&gt;</code> or <code>#</code>).</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/helper.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">send_and_wait</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
</span><span class='line'>        <span class="n">session</span><span class="o">.</span><span class="n">read_very_eager</span><span class="p">()</span>
</span><span class='line'>        <span class="n">result</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
</span><span class='line'>        <span class="n">session</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</span><span class='line'>        <span class="k">while</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">stop_char</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="k">for</span> <span class="n">stop_char</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;#&#39;</span><span class="p">]):</span>
</span><span class='line'>            <span class="n">session</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">result</span> <span class="o">+=</span> <span class="n">session</span><span class="o">.</span><span class="n">read_very_eager</span><span class="p">()</span>
</span><span class='line'>            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let&rsquo;s hope that UNL team will implement config import soon so that we can get rid of this kludgy workaround.</p>

<h2>Extending our sample app</h2>

<p>At this stage we&rsquo;ve got all the code to finish our sample app. The goal is to create and configure the following 3-node topology:</p>

<p><img class="centre" src="http://networkop.github.io/images/rest-sample-app.png" title="REST SDK SAMPLE TOPO" ></p>

<p>We&rsquo;ll assume that all configs will be stored as text files under the <code>./config</code> directory and will have device names as their filename. A helper function <code>read_file</code> will read the contents of a configuration text file into a Python string.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">TOPOLOGY</span> <span class="o">=</span> <span class="p">{(</span><span class="s">&#39;R1&#39;</span><span class="p">,</span> <span class="s">&#39;Ethernet0/0&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s">&#39;R2&#39;</span><span class="p">,</span> <span class="s">&#39;Ethernet0/0&#39;</span><span class="p">),</span>
</span><span class='line'>            <span class="p">(</span><span class="s">&#39;R2&#39;</span><span class="p">,</span> <span class="s">&#39;Ethernet0/1&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s">&#39;R3&#39;</span><span class="p">,</span> <span class="s">&#39;Ethernet0/0&#39;</span><span class="p">),</span>
</span><span class='line'>            <span class="p">(</span><span class="s">&#39;R1&#39;</span><span class="p">,</span> <span class="s">&#39;Ethernet0/1&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s">&#39;R3&#39;</span><span class="p">,</span> <span class="s">&#39;Ethernet0/1&#39;</span><span class="p">)}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">app_1</span><span class="p">():</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="k">try</span><span class="p">:</span>
</span><span class='line'>        <span class="c"># Creating topology in UnetLab</span>
</span><span class='line'>        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">a_name</span><span class="p">,</span> <span class="n">a_intf</span><span class="p">),</span> <span class="p">(</span><span class="n">b_name</span><span class="p">,</span> <span class="n">b_intf</span><span class="p">)</span> <span class="ow">in</span> <span class="n">TOPOLOGY</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
</span><span class='line'>            <span class="c"># Create a mapping between a Node&#39;s name and an object</span>
</span><span class='line'>            <span class="k">if</span> <span class="ow">not</span> <span class="n">a_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
</span><span class='line'>                <span class="n">nodes</span><span class="p">[</span><span class="n">a_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="n">Router</span><span class="p">(</span><span class="n">a_name</span><span class="p">))</span>
</span><span class='line'>                <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** NODE {} CREATED&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a_name</span><span class="p">))</span>
</span><span class='line'>            <span class="k">if</span> <span class="ow">not</span> <span class="n">b_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
</span><span class='line'>                <span class="n">nodes</span><span class="p">[</span><span class="n">b_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="n">Router</span><span class="p">(</span><span class="n">b_name</span><span class="p">))</span>
</span><span class='line'>                <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** NODE {} CREATED&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b_name</span><span class="p">))</span>
</span><span class='line'>            <span class="c"># Extract Node objects using their names and connect them</span>
</span><span class='line'>            <span class="n">node_a</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">a_name</span><span class="p">]</span>
</span><span class='line'>            <span class="n">node_b</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">b_name</span><span class="p">]</span>
</span><span class='line'>            <span class="n">node_a</span><span class="o">.</span><span class="n">connect_node</span><span class="p">(</span><span class="n">a_intf</span><span class="p">,</span> <span class="n">node_b</span><span class="p">,</span> <span class="n">b_intf</span><span class="p">)</span>
</span><span class='line'>            <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** NODES {0} and {1} ARE CONNECTED&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a_name</span><span class="p">,</span> <span class="n">b_name</span><span class="p">))</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** TOPOLOGY IS BUILT&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">lab</span><span class="o">.</span><span class="n">start_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** NODES STARTED&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="c"># Reading and pushing configuration</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
</span><span class='line'>            <span class="n">conf</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="s">&#39;..</span><span class="se">\\</span><span class="s">config</span><span class="se">\\</span><span class="s">{}.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_name</span><span class="p">))</span>
</span><span class='line'>            <span class="n">nodes</span><span class="p">[</span><span class="n">node_name</span><span class="p">]</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>
</span><span class='line'>            <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** NODE {} CONFIGURED&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_name</span><span class="p">))</span>
</span><span class='line'>        <span class="nb">raw_input</span><span class="p">(</span><span class="s">&#39;PRESS ANY KEY TO STOP THE LAB&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** APP FAILED : {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
</span><span class='line'>    <span class="k">finally</span><span class="p">:</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** CLEANING UP THE LAB&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">lab</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
</span><span class='line'>        <span class="n">unl</span><span class="o">.</span><span class="n">delete_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>When you run this app for the first time, the lab with 3 nodes will be spun up and configured. When you get to the <code>PRESS ANY KEY</code> prompt you can login into Web GUI and navigate to lab <code>test_1</code> and validate that all configs have been pushed and devices can ping each other&rsquo;s loopbacks.</p>

<h2>Source code</h2>

<p>All code from this post can be found in my <a href="https://github.com/networkop/rest-blog-unl-client/tree/2e847b8a809a1c9c4c0962b61c1c72325a405090">public repository on Github</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[REST for Network Engineers Part 2 - Basic Operations With UnetLab]]></title>
    <link href="http://networkop.github.io/blog/2016/01/06/rest-basic-operations/"/>
    <updated>2016-01-06T00:00:00-08:00</updated>
    <id>http://networkop.github.io/blog/2016/01/06/rest-basic-operations</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;ll show how to build REST SDK to authenticate, create labs and nodes in <a href="http://www.unetlab.com/">UnetLab</a>. I&rsquo;ll briefly cover the difference between composition and inheritance design patterns and demonstrate how to use test-driven development.</p>

<!--more-->


<h2>REST SDK Design</h2>

<p>As it is with networks, design is a very crucial part of programming. I won&rsquo;t pretend to be an expert in that field and merely present the way I&rsquo;ve built REST SDK. Fortunately, a lot of design will mimic the objects and their relationship on the server side. I&rsquo;ll slightly enhance it to improve code re-use and portability. Here are the basic objects:</p>

<ol>
<li>RestServer - implements basic application-agnostic HTTP CRUD logic</li>
<li>UnlServer - an extension of a RestServer with specific authentication method (cookie-based) and several additional methods</li>
<li>Device - an instance of a network device with specific attributes like type, image name, number of CPUs</li>
<li>UnlLab - a lab instance existing inside a UnlServer</li>
<li>UnlNode - a node instance existing inside a UnlLab</li>
<li>UnlNet - a network instance also existing inside a UnlLab object</li>
</ol>


<p>All these objects and their relationships are depicted on the following simplified <abbr title="Unified Modeling Language">UML</abbr> diagram. If you&rsquo;re interested in what different connections mean you can read <a href="http://www.codeproject.com/Articles/618/OOP-and-UML">this guide</a>.</p>

<p><img class="centre" src="http://networkop.github.io/images/rest-oop-design.png" title="REST SDK UML Diagram" ></p>

<p>Here I&rsquo;ve used inheritance to <em>extend</em> RestServer functionality to make a UnlServer. This makes sense because UnlServer object will re-use a lot of the methods from the RestServer. I could have combined them in a single object but I&rsquo;ve decided to split the application-agnostic bit into a separate component to allow it to be re-used by other RESTful clients in the future.</p>

<p>The other objects are aggregated and interact through code composition, where Lab holds a pointer to the UnlServer where it was created, Nodes and Nets point to the Lab in which they live. Composition creates loose coupling between objects, while still allowing method delegation and code re-use.</p>

<p>For additional information about Composition vs Inheritance you can go <a href="http://learnpythonthehardway.org/book/ex44.html">here</a>, <a href="http://lgiordani.com/blog/2014/08/20/python-3-oop-part-3-delegation-composition-and-inheritance/">here</a> or <a href="http://python-textbok.readthedocs.org/en/latest/Object_Oriented_Programming.html#avoiding-inheritance">here</a>.</p>

<h2>REST SDK Implementation</h2>

<blockquote><p>Throughout this post I&rsquo;ll be omitting a lot of the non-important code. For full working code refer to the link at the end of this post.</p></blockquote>

<h3>RestServer implementation</h3>

<p>When RestServer object is created, <code>__init__()</code> function takes the server IP address and constructs a <code>base_url</code>, a common prefix for all API calls. The 4 CRUD actions are encoded into names of the methods implementing them, for example to send an Update one would need to call <code>.update_object()</code>. This convention will make the implementation of UnlServer a lot more readable. Each of the 4 CRUD methods call <code>_send_request()</code> with correct HTTP verb preset (the leading underscore means that this method is private and should only be called from within the RestServer class).</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/server.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">RestServer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">cookies</span> <span class="o">=</span> <span class="bp">None</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">base_url</span> <span class="o">=</span> <span class="s">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;http:/&#39;</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="s">&#39;api&#39;</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">_send_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</span><span class='line'>        <span class="n">response</span> <span class="o">=</span> <span class="bp">None</span>
</span><span class='line'>        <span class="n">url</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_url</span> <span class="o">+</span> <span class="n">path</span>
</span><span class='line'>        <span class="k">try</span><span class="p">:</span>
</span><span class='line'>            <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span>  <span class="n">json</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">cookies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cookies</span><span class="p">)</span>
</span><span class='line'>        <span class="k">except</span> <span class="n">requests</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span class='line'>            <span class="k">print</span><span class="p">(</span><span class="s">&#39;*** Error calling </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">response</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">get_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_request</span><span class="p">(</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">add_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_request</span><span class="p">(</span><span class="s">&#39;POST&#39;</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">update_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_request</span><span class="p">(</span><span class="s">&#39;PUT&#39;</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">del_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_request</span><span class="p">(</span><span class="s">&#39;DELETE&#39;</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">set_cookies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cookie</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">cookies</span> <span class="o">=</span> <span class="n">cookie</span>
</span></code></pre></td></tr></table></div></figure>


<p>At this stage RestServer does very simple exception and no HTTP response error handling. I&rsquo;ll show how to extend it to do authentication error handling in the future posts.</p>

<h3>UnlServer implementation</h3>

<p>At the very top of the <code>unetlab.py</code> file we have a <code>REST_SCHEMA</code> global variable providing mapping between actions and their respective <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/">API calls</a>. This improves code readability (at least to me) and makes future upgrades to API easier to implement.<br/>
UnlServer class is extending the functionality of a RestServer by implementing UNetLab-specific methods. For example, <code>login()</code> sends username and password using the <code>add_object()</code> method of the parent class and sets the cookies extracted from the response to allow all subsequent methods to be authenticated.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">REST_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="s">&#39;login&#39;</span><span class="p">:</span> <span class="s">&#39;/auth/login&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&#39;logout&#39;</span><span class="p">:</span> <span class="s">&#39;/auth/logout&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&#39;status&#39;</span><span class="p">:</span> <span class="s">&#39;/status&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&#39;list_templates&#39;</span><span class="p">:</span> <span class="s">&#39;/list/templates/&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlServer</span><span class="p">(</span><span class="n">RestServer</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">(</span><span class="n">UnlServer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">login</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">pwd</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;login&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>            <span class="s">&quot;username&quot;</span><span class="p">:</span> <span class="n">user</span><span class="p">,</span>
</span><span class='line'>            <span class="s">&quot;password&quot;</span><span class="p">:</span> <span class="n">pwd</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">set_cookies</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">cookies</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">logout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;logout&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">api_call</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;status&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">api_call</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">get_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;list_templates&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">api_call</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span></code></pre></td></tr></table></div></figure>


<p>As you can see all methods follow the same pattern:</p>

<ol>
<li>Extract an API url from <code>REST_SCHEMA</code> global variable</li>
<li>Send a request using one of the 4 CRUD methods of the parent RestServer class</li>
<li>Return the response</li>
</ol>


<p>Now let&rsquo;s see how we can use TDD approach to build out the rest of the code.</p>

<h2>Test-driven development</h2>

<p>The easiest way to test RESTful application is by observing the status code of the returned HTTP response. If it is 200 or 201 then it can be considered successful. The biggest challenge is to make sure each test case is independent from one another. One option is to include all the code required by a test case inside the function that implements it. This, however, may lead to long and unwieldy spaghetti-code and breaks the <abbr title="Do Not Repeat Yourself">DRY</abbr> principle.<br/>
To help avoid that, TDD frameworks often have <code>fixtures</code> - functions that are run before and after every test case, designed to setup and cleanup the test environment. In our case we can use fixtures to login before each test case is run and logoff after it&rsquo;s finished. Let&rsquo;s see how we can use Python&rsquo;s built-in <a href="https://docs.python.org/2/library/unittest.html">unittest</a> framework to drive the REST SDK development process.<br/>
First let&rsquo;s define our base class <code>UnlTests</code> who&rsquo;s sole purpose will be to implement authentication fixtures. All the test cases will go into child classes that can either reuse and extend these fixtures. This is how test cases for the already existing code look like:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/tests/test_unl.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">UnlTests</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span> <span class="o">=</span> <span class="n">UnlServer</span><span class="p">(</span><span class="n">UNETLAB_ADDRESS</span><span class="p">)</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="n">USERNAME</span><span class="p">,</span> <span class="n">PASSWORD</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">logout</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">BasicUnlTests</span><span class="p">(</span><span class="n">UnlTests</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">get_status</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">get_templates</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>At this point if you add all the necessary import statements and populate global variables with correct IP addresses and credentials all tests should pass. Now let&rsquo;s add another test case to retrieve <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/#toc2">user information</a> from UNL:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/tests/test_unl.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">BasicUnlTests</span><span class="p">(</span><span class="n">UnlTests</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_user_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">get_user_info</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Rerun the tests and watch the last one fail saying <code>'UnlServer' object has no attribute 'get_user_info'</code>. Now let&rsquo;s go back to our UNL SDK code and add that attribute:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">REST_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">...</span> <span class="p">,</span>
</span><span class='line'>    <span class="s">&#39;get_user_info&#39;</span><span class="p">:</span> <span class="s">&#39;/auth&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnetLab</span><span class="p">(</span><span class="n">RestServer</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">get_user_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;get_user_info&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">api_call</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span></code></pre></td></tr></table></div></figure>


<p>Rerun the <code>test_unl.py</code> now and watch all tests succeed again. The same iterative approach can be used to add any number of new methods at the same time making sure none of the existing functionality is affected.<br/>
Note that these are very simple tests and they only verify the response code and not its contents. The better approach would be to look inside the payload and verify, for example, that username is <code>admin</code>.</p>

<h3>UnlLab and UnlNode implementation</h3>

<p>Now let&rsquo;s revert back to normal coding style for a second and create classes for Labs and Nodes. As per the design, these should be separate objects but they should contain a pointer to the context in which they exist. Therefore, it makes sense to instantiate a Lab inside a UnlServer, a Node inside a Lab and pass in the <code>self</code> (UnlServer or Lab) as an argument. For example, here is how a lab will be created:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">REST_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">...</span> <span class="p">,</span>
</span><span class='line'>    <span class="s">&#39;create_lab&#39;</span><span class="p">:</span> <span class="s">&#39;/labs&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlServer</span><span class="p">(</span><span class="n">RestServer</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">create_lab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UnlLab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlLab</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unl</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;create_lab&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>           <span class="s">&quot;path&quot;</span><span class="p">:</span> <span class="s">&quot;/&quot;</span><span class="p">,</span>
</span><span class='line'>           <span class="s">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
</span><span class='line'>           <span class="s">&quot;version&quot;</span><span class="p">:</span> <span class="s">&quot;1&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span> <span class="o">=</span> <span class="n">unl</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>So to create a Lab we need to issue a <code>.create_lab()</code> call on UnlServer object and give it a labname. That function will return a new Lab object with the following attributes preset:</p>

<ul>
<li>Lab name - <code>self.name</code></li>
<li>UnlServer that created it - <code>self.unl</code></li>
<li>HTTP response returned by the server after the Create CRUD action - <code>self.resp</code></li>
</ul>


<p>The latter can be used to check if the creation was successful (and potentially throw an error if it wasn&rsquo;t). The structure of the payload can be found in <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/#toc30">API docs</a>.</p>

<p>Nodes will be created in a similar way with a little exception. Apart from the name, Node also needs to know about the particulars of the device it will represent (like device type, image name etc.). That&rsquo;s where Device class comes in. The implementation details are very easy and can be found on <a href="https://github.com/networkop/rest-blog-unl-client/blob/c72f7bdc11427ac5efe9ec18401f0d63c57221ba/restunl/device.py">Github</a> so I won&rsquo;t provide them here. The only function of a Device at this stage is to create a dictionary that can be used as a payload in <code>create_node</code> <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/#toc34">API request</a>.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">REST_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">...</span> <span class="p">,</span>
</span><span class='line'>    <span class="s">&#39;create_node&#39;</span><span class="p">:</span> <span class="s">&#39;/labs/{lab_name}/nodes&#39;</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlLab</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">create_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UnlNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lab</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">unl</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">lab</span> <span class="o">=</span> <span class="n">lab</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;create_node&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">api_url</span> <span class="o">=</span> <span class="n">api_call</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">api_call</span><span class="p">,</span> <span class="n">lab_name</span><span class="o">=</span><span class="n">append_unl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</span><span class='line'>        <span class="n">payload</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="n">api_url</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Take a quick look at how the <code>api_url</code> is created. We&rsquo;re using <code>.format()</code> method (built-into <code>string</code> module) to substitute a named variable <code>{format}</code> with the actual name of the lab (<code>self.lab.name</code>). That labname gets appended with an extension by a helper function <code>append_unl</code>. That helper function, along with the others we&rsquo;ll define in the future, can also be found on <a href="https://github.com/networkop/rest-blog-unl-client/blob/c72f7bdc11427ac5efe9ec18401f0d63c57221ba/restunl/helper.py">Github</a>.</p>

<h2>Back to TDD</h2>

<p>Let&rsquo;s use TDD again to add the last two actions we&rsquo;ll cover in this post.</p>

<ul>
<li>Get list of all Nodes</li>
<li>Delete a lab</li>
</ul>


<figure class='code'><figcaption><span>/rest-blog-unl-client/tests/test_unl.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">BasicUnlLabTest</span><span class="p">(</span><span class="n">UnlTests</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_create_lab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">delete_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">create_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span><span class="o">.</span><span class="n">resp</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">delete_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_delete_lab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">create_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">delete_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_get_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">lab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">create_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">delete_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>As a challenge, try implementing the SDK logic for the last two failing methods yourself using <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/">UNL API</a> as a reference. You can always refer the the link at the end of the post if you run into any problems.</p>

<h2>Simple App</h2>

<p>So far we&rsquo;ve created and deleted objects with REST API but haven&rsquo;t seen the actual result. Let&rsquo;s start writing an app that we&rsquo;ll continue to expand in the next post. In this post we&rsquo;ll simply login and create a lab containing a single node.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/samples/app-1.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">restunl.unetlab</span> <span class="kn">import</span> <span class="n">UnlServer</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">restunl.device</span> <span class="kn">import</span> <span class="n">Router</span>
</span><span class='line'>
</span><span class='line'><span class="n">LAB_NAME</span> <span class="o">=</span> <span class="s">&#39;test_1&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">app_1</span><span class="p">():</span>
</span><span class='line'>    <span class="n">unl</span> <span class="o">=</span> <span class="n">UnlServer</span><span class="p">(</span><span class="s">&#39;192.168.247.20&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">unl</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="s">&#39;unl&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;*** CONNECTED TO UNL&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">lab</span> <span class="o">=</span> <span class="n">unl</span><span class="o">.</span><span class="n">create_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;*** CREATED LAB&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">node_1</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="n">Router</span><span class="p">(</span><span class="s">&#39;R1&#39;</span><span class="p">))</span>
</span><span class='line'>    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;*** CREATED NODE&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">app_1</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>Run this once, then login the UNL web GUI and navigate to <code>test_1</code> lab. Examine how node <strong>R1</strong> is configured and compare it to the defaults set in a <a href="https://github.com/networkop/rest-blog-unl-client/blob/c72f7bdc11427ac5efe9ec18401f0d63c57221ba/restunl/device.py">Device module</a>.</p>

<h2>Source code</h2>

<p>All code from this post can be found in my <a href="https://github.com/networkop/rest-blog-unl-client/tree/c72f7bdc11427ac5efe9ec18401f0d63c57221ba">public repository on Github</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[REST for Network Engineers Part 1 - Development Environment Setup]]></title>
    <link href="http://networkop.github.io/blog/2016/01/03/dev-env-setup-rest/"/>
    <updated>2016-01-03T00:00:00-08:00</updated>
    <id>http://networkop.github.io/blog/2016/01/03/dev-env-setup-rest</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;ll show how to setup environment for <a href="http://www.unetlab.com/">UnetLab</a> REST SDK development on Windows. I&rsquo;ll be running UNL inside a VM and using PyCharm as Python IDE on the host OS.</p>

<!--more-->


<h2>UnetLab Installation</h2>

<p>Since UNL is a separate project with its own evolving documentation I won&rsquo;t try to reproduce it in my blog and I&rsquo;ll simply refer all my readers to <a href="http://www.unetlab.com/download/index.html">UNL download page</a>, <a href="http://www.unetlab.com/documentation/index.html">UNL installation instructions</a> and <a href="http://www.unetlab.com/2014/11/first-unetlab-boot-configuration/">UNL first boot configuration</a>.<br/>
At the time of writing UNL is distributed as an image packaged in Open Virtualization Format. I&rsquo;m using VMWare Workstation as a type-2 hypervisor to import and run this image. Check with the <a href="http://www.unetlab.com/documentation/index.html">UNL how-to page</a> for the list of currently supported hypervisors.<br/>
I&rsquo;ll be using Cisco IOU as a network device emulator in my topologies. Similarly, you can find IOU installation instructions on <a href="http://www.unetlab.com/2014/11/adding-cisco-iouiol-images/">UNL website</a>. The rest of this post assumes you&rsquo;ve got UNL up and running and you can successfully create, start and connect to an IOU device by navigating through native GUI interface.</p>

<h2>Installing Python and Dependencies</h2>

<p>For development purposes I&rsquo;ll be using <a href="https://www.python.org/downloads/release/python-2711/">Python 2.7</a>. You&rsquo;ll need to install a package management system <a href="https://pip.pypa.io/en/latest/installing/">pip</a> to gain access to <a href="http://docs.python-requests.org/en/latest/user/install/">requests</a> library that we&rsquo;ll be using to talk HTTP to our REST server. To install <strong>requests</strong> or any other package using <strong>pip</strong> on a Windows machine, you can use the following command:</p>

<figure class='code'><figcaption><span>Installing Python HTTP library</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='powershell'><span class='line'><span class="n">python</span> <span class="n">-m</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">requests</span>
</span></code></pre></td></tr></table></div></figure>


<h2>PyCharm and Github integration</h2>

<p>There&rsquo;s a plethora of <abbr title="Intergrated Development Environment">IDE</abbr>s <a href="https://wiki.python.org/moin/IntegratedDevelopmentEnvironments">available for Python</a>. My personal choice is <a href="https://www.jetbrains.com/pycharm/">PyCharm</a> - an open-source IDE with built-in debugger, syntax checker, code completion and GIT integration. Here is how you setup PyCharm to work with Github:</p>

<ol>
<li><strong>Create</strong> a new repository on <a href="https://github.com">Github</a>.</li>
<li>In PyCharm navigate to <code>VCS -&gt; Checkout from Version Control -&gt; Github</code>, paste in the link to a newly created repository and click <code>Clone</code>. This will <strong>create a clone</strong> of an empty code repository on your local machine. From now on you&rsquo;ll see two VCS buttons in PyCharm toolbar to pull and push code to Github.</li>
<li><strong>Add</strong> newly created files and directories to git by right-clicking on them and selecting <code>Git -&gt; Add</code></li>
<li>At the end of your work <strong>push</strong> the code to Github by clicking the green VCS button, write your comment in <code>Commit message</code> window, enter your Github username in <code>Author</code> field and select <code>Commit and Push</code>.</li>
<li>To get the latest version of code from Github click the blue VCS button to <strong>pull</strong> changes to local directory.</li>
</ol>


<p>Just remember that your Github repository is your source of truth and you need to push changes to it every time you finish work and pull code from it every time you restart it. It makes sense even if you work alone since it creates a good habit which may come very useful in the future.  <br/>
For additional information about git workflow and working with Github you can check out (no pun intended) <a href="https://help.github.com/categories/bootcamp/">Github help</a> and <a href="https://guides.github.com/">Github guides</a>.</p>

<h2>Project Skeleton</h2>

<p>Now that we&rsquo;ve fully integrated with Github we can setup our basic directory structure. In project Navigation Bar under the project&rsquo;s main directory create 3 subdirectories:</p>

<ul>
<li><code>restunl</code> - to store all code implementing REST SDK logic</li>
<li><code>samples</code> - to store sample applications</li>
<li><code>tests</code> - to store test cases for REST SDK</li>
</ul>


<p>Next we need to tell git which files we DON&rsquo;T want to track. To do that add filename patterns to <code>.gitignore</code> file and put this file into every directory. Rule of thumb is to only track your code and not your auxiliary files like compiled python code (.pyc), PyCharm settings (.idea) or local git files (.git).</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/.gitignore</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>.idea
</span><span class='line'>.git
</span><span class='line'>*.pyc
</span></code></pre></td></tr></table></div></figure>


<p>Finally, in order to be able to import code between different directories within the project, we need to add an empty <code>__init__.py</code> file to each non-root directory which tells Python to treat that directory as <a href="https://docs.python.org/2/tutorial/modules.html#packages">a package</a>. The final version of skeleton will look like this:</p>

<p><img class="centre" src="http://networkop.github.io/images/restunl-skeleton.png" title="Project Skeleton" ></p>

<h2>Before you REST</h2>

<p>Here are a few things you need to know about the REST server before you start working with it:</p>

<ol>
<li>IP address and Port - the same IP address you use to access UNL from your web browser (in my case it&rsquo;s 192.168.247.20:80)</li>
<li>Username and password for authentication - default UNL credentials (admin/unl)</li>
<li>REST API documentation - in our case it&rsquo;ll be <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/">UnetLab API documentation</a></li>
</ol>


<h2>Using REST for the first time</h2>

<p>Let&rsquo;s try to query the status of our UnetLab server. According <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/">UNL documentation</a> the correct request should look like this:</p>

<figure class='code'><figcaption><span>UNL status API call</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>curl -s -c /tmp/cookie -b /tmp/cookie -X GET -H <span class="s1">&#39;Content-type: application/json&#39;</span> http://127.0.0.1/api/status
</span></code></pre></td></tr></table></div></figure>


<p>Take note of the HTTP method (GET) and URL (<a href="http://ip_address/api/status">http://ip_address/api/status</a>), we&rsquo;ll use these values in our test program. Disregard the cookies and Content-type headers for now, we&rsquo;ll get back to them in the future posts. In our project&rsquo;s root directory create a <code>test.py</code> file with the following code:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/test.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">requests</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">json</span>
</span><span class='line'>
</span><span class='line'><span class="n">url</span> <span class="o">=</span> <span class="s">&#39;http://192.168.247.20/api/status&#39;</span>
</span><span class='line'><span class="n">method</span> <span class="o">=</span> <span class="s">&#39;GET&#39;</span>
</span><span class='line'><span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
</span><span class='line'><span class="n">payload</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">payload</span><span class="p">[</span><span class="s">&#39;code&#39;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This code calls <code>.request</code> method of requests library and passes in an HTTP method type and the URL. The value returned by this call would be an HTTP response. Since payload is encoded as JSON we need to parse the content of the HTTP response (<code>response.content</code>) by calling a <code>.loads</code> method of json library. Once parsed, we can work with any part of JSON payload same way we would with a Python dictionary. If you&rsquo;ve done everything right, the result of the last print statement should be <code>200</code>. Feel free to experiment and print, for example, the current version of UNL. Refer to <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/">API documentation</a> for the exact structure of the payload.</p>

<h2>Conclusion</h2>

<p>Now that we&rsquo;ve setup our development environment we&rsquo;ll move on to the actual REST SDK development in the next post. Don&rsquo;t forget to add all your newly created files and directories to git and push them to Github.</p>

<p>All code from this post can be found in my <a href="https://github.com/networkop/rest-blog-unl-client/tree/63d8d13e48e61e896185eb7afee3759c1f2cd5a9">public repository on Github</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[REST API for Network Engineers]]></title>
    <link href="http://networkop.github.io/blog/2016/01/01/rest-for-neteng/"/>
    <updated>2016-01-01T00:00:00-08:00</updated>
    <id>http://networkop.github.io/blog/2016/01/01/rest-for-neteng</id>
    <content type="html"><![CDATA[<p>This is the first, introductory, post in a series dedicated to REST APIs for Network Engineers. In this post we&rsquo;ll learn what REST API is, what are the most common tools and ways to consume it. Later in the series I&rsquo;ll show how to build a REST client to control <a href="http://www.unetlab.com/">UnetLab</a>, a very popular network emulation environment.</p>

<!--more-->


<h2>Management interface evolution</h2>

<p>Since the early dawn of networking, devices have been configured through <abbr title="Virtual Terminal User Interface">VTY</abbr>s. The transport has evolved from telnet to ssh but the underlying rule still maintained that network is configured manually, device-by-device by a human administrator. It&rsquo;s obvious that this approach does not scale and is prone to human error, however it still remains the most prevalent method of network device configuration. <br/>
The first attempt to tackle these issues has been made in 1988 with the introduction of SNMP. The basic idea was to monitor and manage network devices using a strictly-defined data structures called <abbr title="Management Information Base">MIB</abbr>s. Unfortunately, due to several architectural issues and poor vendor implementation, SNMP has ended up being used mainly for basic monitoring tasks.<br/>
The idea of programmatic management of network devices later resulted in the creation of NETCONF protocol. Despite being almost 10 years old, this protocol is still not widely used due to limited vendor support, however things may improve as the <abbr title="Yet Another Next Generation">YANG</abbr>-based network configuration gains greater adoption.<br/>
Finally, with the advent of SDN, REST has become a new de-facto standard for network provisioning. It is supported by most of the latest products of all the major vendors. Let&rsquo;s take a closer look at what REST is and how it works.</p>

<h2>REpresentational State Transfer overview</h2>

<p>Technically speaking, REST is not a protocol but a <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">software architectural pattern</a>. To put it in simple words, it describes <strong>a way</strong> to exchange information rather than the structure of that information. Think of it as another transport (like telnet or ssh for VTY) for payloads of any format. Most commonly payload will get encoded as <abbr title="JavaScript Object Notation">JSON</abbr>, however the structure of JSON is not defined and is different for each application. This rather <em>weak</em> definition opens up huge opportunities for potential use cases:</p>

<ol>
<li><p>The most basic use case is a Web application with client retrieving and updating information on a server. A good example in networking world would be the native interfaces of Cisco ACI or VMWare NSX. Each time you create an object (a network or a tenant) in a Web GUI, your client sends a request to server&rsquo;s REST interface.</p></li>
<li><p>The more advanced use case is for communication between distributed software components over a network environment. This is how all management and control plane communications are designed inside OpenStack. For example, every time a new VM is created, <abbr title="Compute controller">Nova</abbr> sends a request to <abbr title="Network controller">Neutron</abbr>&rsquo;s REST API interface to allocate an IP address and a port for that VM.</p></li>
</ol>


<h2>REST under the hood</h2>

<p>REST is an API that allows clients to perform read/write operations on data stored on the server. REST uses HTTP to perform a set of actions commonly known as <strong>CRUD</strong>:</p>

<ul>
<li>Create</li>
<li>Read</li>
<li>Update</li>
<li>Delete</li>
</ul>


<p>Assuming we want to manipulate a &lsquo;device&rsquo; object on a server we can send an <code>HTTP GET</code> request to <code>/api/devices</code> and get a response with a payload containing a full list of known devices.<br/>
If we want to add a new device, we need to construct a payload with device attributes (e.g. IP address, Hostname) and send it attached to an <code>HTTP POST</code> request.<br/>
To update a device we need to send the full updated payload with <code>HTTP PUT</code> method.</p>

<p><img class="centre" src="http://networkop.github.io/images/rest-crud.png" title="Basic REST actions" ></p>

<p>Note that both Update and Delete API calls refer to a specific number in url <code>/api/devices/{ID}</code>. That is a <abbr title="Universally Unique IDentifier">UUID</abbr> that server assigns to every new object and is returned in <code>Location</code> header of <code>201 Created</code> message sent in response to Create request.</p>

<h2>REST API Constraints</h2>

<p>For API to be considered <strong>RESTful</strong> it needs comply with a number of <a href="http://www.restapitutorial.com/lessons/whatisrest.html">formal constraints</a>. One of the most important constraint of all is the stateless nature of the interface. That means that no cookie or session information should be stored on the server, and every request is treated independently from every other request. The implication here is that all state needs to be maintained on the client and information needs to be cacheable in order to improve interface responsiveness.</p>

<p>It&rsquo;s worth noting that an API can still be considered RESTful even if a server <em>does</em> store a session cookie, however all requests must still be treated independently. The last point means there&rsquo;s no <em>configuration modes</em> like we&rsquo;ve seen in traditional CLIs where all commands issued in &ldquo;interface configuration mode&rdquo; will be applied to that specific interface. With RESTful API each request from a client must reference a full path to an object including its UUID within the system.</p>

<h2>Using REST</h2>

<h3>cURL</h3>

<p>cURL is a light-weight Linux command-line tool for transferring data. It&rsquo;s very simple to get started and very frequently used to make HTTP requests. For example, this is how you would issue a Read request to get a list of devices configured on an imaginary SDN controller:</p>

<figure class='code'><figcaption><span>Get all devices using cURL</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>curl -X GET http://sdn-controller.org:8181/api/devices
</span></code></pre></td></tr></table></div></figure>


<p>Obviously this tool is very good for fast prototyping and troubleshooting but becomes too cumbersome for anything involving more than a few commands.</p>

<h3>Browser plugins</h3>

<p>There&rsquo;s plenty of GUI-based clients that can be added-on to most popular browsers. <a href="https://www.getpostman.com/">Postman</a> and <a href="https://addons.mozilla.org/en-us/firefox/addon/restclient/">RESTClient</a> are amongst the most popular ones. In addition to basic functionality, these plugins allow you to store and issue sequence of requests which can be very handy for live demonstrations. Unfortunately that&rsquo;s where most of the people stop learning about REST API and assume this is the intended way to interact with a server.</p>

<h3><abbr title="Software Development Kit">SDK</abbr></h3>

<p>SDK is a collection of tools and libraries that allow users to build a full-blown applications with complex internal logic. Instead of caring about the exact syntax of API calls, SDK libraries provide a simple programming interface. For example, this is how you would run the same command we did earlier with cURL:</p>

<figure class='code'><figcaption><span>Get all devices using SDK</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">controller</span> <span class="o">=</span> <span class="n">sdk</span><span class="o">.</span><span class="n">Controller</span><span class="p">(</span><span class="s">&#39;sdn-controller.org&#39;</span><span class="p">,</span> <span class="mi">8181</span><span class="p">)</span>
</span><span class='line'><span class="n">response</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">get_devices</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>We first create an instance of a controller with specific hostname and port number and then issue a <code>.get_devices()</code> call on it to obtain the list of all known devices. SDK library will do all the dirty work constructing HTTP request in the background and return the parsed information from HTTP response. We can then use that information to perform some complex logic, like start only Router devices (but not switches and firewalls):</p>

<figure class='code'><figcaption><span>Start all Routers using SDK</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">routers_started</span> <span class="o">=</span> <span class="p">[</span><span class="n">device</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">get_payload</span><span class="p">()</span> <span class="k">if</span> <span class="n">device</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&#39;Router&#39;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>As you can see, we can use all capabilities of a programming language to write a succinct and powerful code, something that would be extremely difficult to do with cURL or Postman. That&rsquo;s why the focus of this series of posts will be on the SDK, how to build one from scratch and how to use it.</p>

<h2>UNetLab REST SDK</h2>

<p>In the upcoming posts I&rsquo;ll show how to develop a REST SDK to control UnetLab. My final goal would be to be able to create and fully configure an arbitrary network topology. The whole series will be broken up into several posts going over:</p>

<ol>
<li><a href="http://networkop.github.io/blog/2016/01/03/dev-env-setup-rest/">UnetLab SDK development environment setup</a>.
I&rsquo;ll show how to setup PyCharm to work with UNL running in a hypervisor on a Windows machine.</li>
<li><a href="http://networkop.github.io/blog/2016/01/06/rest-basic-operations/">First steps with REST API for UNetLab</a>.
In this post I&rsquo;ll show how to work with HTTP and perform basic operations like login/logoff and object creation in UNL.</li>
<li><a href="http://networkop.github.io/blog/2016/01/17/rest-unl-advanced/">Advanced actions with UNetLab SDK</a>.
The final post will demonstrate how to push configuration to devices inside UNL. To wrap up I&rsquo;ll write a sample app to spin up and provision a three-node topology without making a single GUI click.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automating the Build of FlexVPN Network]]></title>
    <link href="http://networkop.github.io/blog/2015/11/13/automating-flexvpn-config/"/>
    <updated>2015-11-13T00:00:00-08:00</updated>
    <id>http://networkop.github.io/blog/2015/11/13/automating-flexvpn-config</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;ll show how to automatically build configuration files for Hubs and Spokes in FlexVPN network topology. I will also introduce two concepts that are frequently used in software development world - <abbr title="Do Not Repeat Yourself">DRY</abbr> and &ldquo;Convention over Configuration&rdquo;. This post is a precursor to the upcoming FlexVPN configuration post on <a href="http://packetpushers.com">Packetpushers</a>.</p>

<!--more-->


<h2>FlexVPN network overview</h2>

<p>FlexVPN topology will consist of two FlexVPN &ldquo;clouds&rdquo;. Each cloud has a Hub router and multiple Spokes. Each Spoke is connected to each of the two Hubs thereby participating in both FlexVPN clouds. The two Hubs are interconnected by a direct site-to-site FlexVPN tunnel. To provide additional redundancy one Hub (HUB-1) and one Spoke (SPOKE-1) will have dual WAN links.</p>

<p><img class="centre" src="http://networkop.github.io/images/flexvpn-topo.png" title="FlexVPN topology" ></p>

<h2>Assumptions</h2>

<p>All FlexVPN devices will be using PKI-based authentication. However, in this post I will not cover the setup of PKI infrastructure and simply assume that all Hubs and Spokes are already enrolled with the appropriate CA. Following are the assumptions about the specifics of PKI setup on each router:</p>

<ul>
<li>Each FlexVPN cloud is defined by a unique domain name (e.g. cloud.one for HUB-1)</li>
<li>Each Spoke has one X.509 certificate per FlexVPN cloud</li>
<li>Spokes encode their WAN bandwidth in X.509 Organizational Unit (OU) attribute (e.g. RED corresponds to 50Mpbs)</li>
<li>Each certificate&rsquo;s trustpoint will be called &ldquo;PKI-CLOUD-X&rdquo;, where X is 1 or 2 depending on FlexVPN cloud</li>
</ul>


<p>As an example, SPOKE-3 will have the following trustpoint configured for FlexVPN cloud #1:</p>

<figure class='code'><figcaption><span>PKI trustpoint #1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>crypto pki trustpoint PKI-CLOUD-1
</span><span class='line'> enrollment url http://120.0.0.2:80
</span><span class='line'> serial-number
</span><span class='line'> fingerprint 2BE13A4FF167CEB770A24B2D6716033E
</span><span class='line'> subject-name CN=SPOKE-3.cloud.one,OU=GREEN
</span><span class='line'> vrf FVRF
</span><span class='line'> revocation-check crl
</span><span class='line'> rsakeypair CLOUD-1
</span><span class='line'> auto-enroll
</span></code></pre></td></tr></table></div></figure>


<h2>Convention over Configuration</h2>

<p>This is where it&rsquo;d make sense to introduce the concept of Convention over Configuration. The fact that we&rsquo;ve assumed that all trustpoints will have the prefix of &ldquo;PKI-CLOUD-&rdquo; (convention) makes configuration templates a lot easier. Without it we could have allowed ANY naming of PKI trustpoint but then it should have been defined as a separate variable for every Spoke. Effectively we&rsquo;re sacrificing some level flexibility in favour of brevity (and simplicity). This principle has been popularised by Ruby on Rails web framework and is widely used in other modern web frameworks.</p>

<h2>FlexVPN inventory file</h2>

<p>Before we start working with Ansible, we need to populate host inventory file. A parent &ldquo;FLEXVPN&rdquo; group will include two children groups - &ldquo;HUBS&rdquo; and &ldquo;SPOKES&rdquo;. The latter will be subdivided into three groups - &ldquo;GREEN&rdquo;, &ldquo;BLUE&rdquo; or &ldquo;RED&rdquo;. Each spoke will be assigned to a group base on its X.509 OU value. Additionally, in order to keep configuration templates simpler, we&rsquo;ll treat multi-vrf SPOKE-1 as two different routers - SPOKE1_1 and SPOKE1_2:</p>

<figure class='code'><figcaption><span>./hosts </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="p-Indicator">[</span><span class="nv">FLEXVPN</span><span class="p-Indicator">:</span><span class="nv">children</span><span class="p-Indicator">]</span>
</span><span class='line'><span class="l-Scalar-Plain">HUBS</span>
</span><span class='line'><span class="l-Scalar-Plain">SPOKES</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">[HUBS]</span>
</span><span class='line'><span class="l-Scalar-Plain">HUB-1</span>
</span><span class='line'><span class="l-Scalar-Plain">HUB-2</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">[SPOKES:children]</span>
</span><span class='line'><span class="l-Scalar-Plain">GREEN</span>
</span><span class='line'><span class="l-Scalar-Plain">BLUE</span>
</span><span class='line'><span class="l-Scalar-Plain">RED</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">[RED]</span>
</span><span class='line'><span class="l-Scalar-Plain">SPOKE-1_1</span>
</span><span class='line'><span class="l-Scalar-Plain">SPOKE-1_2</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">[BLUE]</span>
</span><span class='line'><span class="l-Scalar-Plain">SPOKE-2</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">[GREEN]</span>
</span><span class='line'><span class="l-Scalar-Plain">SPOKE-3</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Front-door VRF configuration</h2>

<p>Another assumption is that all routers will have their Front-door VRF configured. Normally this would imply configuring an IP address on Internet-facing interface and a vrf-specific default route. In case of HUB-1, where there are two physical links in a single VRF, it is assumed that appropriate SLA-tied static routes are configured to enable dynamic failover between the two links. Here&rsquo;s the example of how it&rsquo;s done on HUB-1:</p>

<figure class='code'><figcaption><span>show run vrf FVRF-1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>interface Ethernet0/0
</span><span class='line'> vrf forwarding FVRF-1
</span><span class='line'> ip address 120.0.0.2 255.0.0.0
</span><span class='line'>!
</span><span class='line'>interface Ethernet0/1
</span><span class='line'> vrf forwarding FVRF-1
</span><span class='line'> ip address 121.0.0.2 255.0.0.0
</span><span class='line'>!
</span><span class='line'>ip route vrf FVRF-1 0.0.0.0 0.0.0.0 120.0.0.1 track 1
</span><span class='line'>ip route vrf FVRF-1 0.0.0.0 0.0.0.0 121.0.0.1 250
</span></code></pre></td></tr></table></div></figure>


<h2>Environment variables and the DRY principle</h2>

<p>One of the most obvious things to turn into a variable is the FVRF name and interface. We&rsquo;ll put it into an Ansible&rsquo;s global variable file <code>./group_vars/all</code>. The same file will have a default BGP AS number for iBGP routing and a table mapping different OU values to their corresponding bandwidth in Kbps.</p>

<figure class='code'><figcaption><span>./group_vars/all</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="nn">---</span>
</span><span class='line'><span class="l-Scalar-Plain">bgp_asn</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">1</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">fvrf</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">FVRF</span>
</span><span class='line'>  <span class="l-Scalar-Plain">interface</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Ethernet0/0</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">bandwidth</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">RED</span><span class="p-Indicator">:</span>   <span class="l-Scalar-Plain">50000</span>
</span><span class='line'>  <span class="l-Scalar-Plain">GREEN</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">20000</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BLUE</span><span class="p-Indicator">:</span>  <span class="l-Scalar-Plain">10000</span>
</span></code></pre></td></tr></table></div></figure>


<p>Each of these variables can be overridden by a more specific host variable located in <code>./host_vars/</code> directory like it is the case with <a href="https://github.com/networkop/flexvpn/blob/master/host_vars/SPOKE-1_1">SPOKE1</a>.  All host-specific variables, like domain names, FlexVPN subnets, public addresses for Hub devices are also being stored in the same directory. Here&rsquo;s an example of how HUB-1 overrides the default FVRF name and defines a few variables of its own:</p>

<figure class='code'><figcaption><span>./host_vars/HUB-1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="nn">---</span>
</span><span class='line'><span class="l-Scalar-Plain">primary</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">domain_name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">cloud.one</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">nbma_ip</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">dynamic</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">dynamic</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">120.0.0.2</span>
</span><span class='line'>  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">121.0.0.2</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">vpn_ip</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">169.254.1.1</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">subnet</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">169.254.1.0/24</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">fvrf</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">FVRF-1</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Here it makes sense to talk about the <strong>DRY principle</strong>. All Spokes in their configuration files will use information like Hub&rsquo;s NBMA address and domain name. So, in theory, we could have created a host variable file for each Spoke and stored that information there. However, in that case we would have multiple duplicate variables all storing the same value. This, obviously, creates a lot of problems when it comes to updating those variables. Instead of updating a value in a single place we now have to go and update every single Spoke&rsquo;s host variables file. That&rsquo;s why it&rsquo;s important to NOT have ANY duplicates of ANY information in ANY part of your code, even if it comes at a price of an increased code complexity. This is widely accepted as best practice and used in almost every programming language and CS discipline.</p>

<h2>FlexVPN configuration templates</h2>

<p>I will omit the actual configuration templates for the sake of brevity. Those who are interested can check out my <a href="https://github.com/networkop/flexvpn">FlexVPN Github repository</a>. Here&rsquo;s how you can generate a full-blown config for FlexVPN network:</p>

<figure class='code'><figcaption><span>1. Clone Github repository</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git clone https://github.com/networkop/flexvpn.git
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>2. Update variables to match the network design</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>./hosts
</span><span class='line'>./group_vars/all
</span><span class='line'>./host_vars/
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>3. Generate configuration files</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ansible-playbook site.yml
</span></code></pre></td></tr></table></div></figure>


<p>All generated configuration files will be stored in <code>./files/</code> directory.</p>

<h2>Conclusion</h2>

<p>Thanks to DRY and Convention over Configuration principles it&rsquo;s possible to devise a configuration template that will be the same for all Spokes. The actual configuration will consist of multiple components like IKEv2, dynamic VTI, AAA and BGP configuration. I&rsquo;ll try to explain how they all tie together in my upcoming post on <a href="http://packetpushers.com">Packetpushers</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automating New Network Build - Part 2 (BGP)]]></title>
    <link href="http://networkop.github.io/blog/2015/09/03/automating-bgp-config/"/>
    <updated>2015-09-03T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2015/09/03/automating-bgp-config</id>
    <content type="html"><![CDATA[<p>In this post we&rsquo;ll have a look at how to automate a typical BGP setup. This is where configuration may get particularly messy especially in presence of backdoor links and complex routing failover policies. However, as I will show, it is still possible to create a standard set of routing manipulation policies and selectively apply them to the required adjacencies to achieve the desired effect.</p>

<!--more-->


<h2>Requirements and assumptions</h2>

<p>The new office network is designed with several layers of WAN redundancy. Primary WAN link is the preferred option to reach all other WAN destination except for the Main office which is connected via a dedicated high-throughput link. Secondary WAN link should only be used in case both primary and backdoor links are unavailable.<br/>
All routed devices within Branch-2 will be running iBGP AS#3 with BR2-CORE playing a role of route-reflector for the two WAN routers. iBGP convergence timers should rely on IGP&rsquo;s timers (OSPF default timers of 10 and 40 seconds). Site&rsquo;s core switch should originate a site summary prefix as well as any other non-standard prefixes falling outside of the standard site summary (e.g. links to 3rd Parties, DMZ etc.). All prefixes originated by the site should be tagged with specific community values in order to be easily identifiable at the remote end.</p>

<p><img class="centre" src="http://networkop.github.io/images/full-network-topo.png" title="Full network topology" ></p>

<h2>eBGP configuration automation</h2>

<p>Each site will have a unique set of eBGP peers, hence, it is logical to put all eBGP-related variables into a site-specific directory <code>group_vars/branch-2/</code>. In order to understand how to configure each eBGP neighbor the following values need to be defined for each eBGP neighbor:</p>

<ol>
<li>IP addresses</li>
<li>AS number</li>
<li>(optional) Routing manipulation policies</li>
</ol>


<p>The above values correspond to the following Ansible variables:</p>

<figure class='code'><figcaption><span>./group_vars/branch-2/bgp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">ebgp_peers</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BR2-WAN1</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">1.1.1.2</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">remote-as 1000</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BR2-WAN2</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">2.2.3.2</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">remote-as 2000</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">route-map RM-BGP-PREPEND-OUT out</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BR2-CORE</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">10.0.2.49</span><span class="p-Indicator">:</span>
</span><span class='line'>       <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">remote-as 2</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here <code>ebgp_peers</code> variable contains a mapping between network devices and their eBGP neighbors identified by their IP addresses. BGP path manipulation policies ideally should belong to global variables and are defined under the company-wide <code>routing</code> group</p>

<figure class='code'><figcaption><span>./group_vars/routing/route-maps</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">bgp_out_rmap_prepend</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">set as-path prepend {{ site_ASN }} {{ site_ASN }} {{ site_ASN }} {{ site_ASN }} {{ site_ASN }} {{ site_ASN }} {{ site_ASN }}</span>
</span></code></pre></td></tr></table></div></figure>


<p>All information defined above will be reused by the <code>bgp</code> template of the <code>routing</code> ansible roles:</p>

<figure class='code'><figcaption><span>./roles/routing/template/bgp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">route-map RM-BGP-PREPEND-OUT permit 10</span>
</span><span class='line'><span class="l-Scalar-Plain">{%- for clause in bgp_out_rmap_prepend %}</span>
</span><span class='line'>  <span class="l-Scalar-Plain">{{ clause }}</span>
</span><span class='line'><span class="l-Scalar-Plain">{% endfor -%}</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">router bgp {{ site_ASN }}</span>
</span><span class='line'><span class="l-Scalar-Plain">{%- if inventory_hostname in ebgp_peers %}</span>
</span><span class='line'>  <span class="l-Scalar-Plain">{%- for neighbor_ip in ebgp_peers[inventory_hostname] %}</span>
</span><span class='line'>    <span class="l-Scalar-Plain">{%- for option in ebgp_peers[inventory_hostname][neighbor_ip] %}</span>
</span><span class='line'>  <span class="l-Scalar-Plain">neighbor {{ neighbor_ip }} {{ option }}</span>
</span><span class='line'>    <span class="l-Scalar-Plain">{% endfor -%}</span>
</span><span class='line'>  <span class="l-Scalar-Plain">{% endfor -%}</span>
</span><span class='line'><span class="l-Scalar-Plain">{% endif -%}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>iBGP configuration automation</h2>

<p>Each site will be running a simple iBGP topology with a single route-reflector with two clients. Each routed device within the new branch will need to have it&rsquo;s iBGP role  defined (server or client).</p>

<figure class='code'><figcaption><span>./group_vars/branch-2/bgp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">ibgp_topo</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">route_reflector</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="nv">BR2-CORE</span><span class="p-Indicator">]</span>
</span><span class='line'>  <span class="l-Scalar-Plain">rr_clients</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="nv">BR2-WAN1</span><span class="p-Indicator">,</span> <span class="nv">BR2-WAN2</span><span class="p-Indicator">]</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">bgp_originate_redistribute</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BR2-CORE</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">summary</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">static</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">bgp_originate_network</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BR2-WAN1</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">Loopback0</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BR2-WAN2</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">Loopback0</span>
</span></code></pre></td></tr></table></div></figure>


<p>Special variables that start with <code>bgp_originate_</code> define which subnets should be originated by which router. RR-server will originate site-wide summary and any 3rd party subnets while WAN routers will inject their own loopbacks in order to be remotely accessible even if BR2-CORE goes down. Specific route maps responsible for prefix origination should be defined in the global scope:</p>

<figure class='code'><figcaption><span>./group_vars/routing/route-maps</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="l-Scalar-Plain">bgp_redistr_route_maps</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">static</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">match tag {{ tags.static }}</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">set community {{ bgp_comm_static }}</span>
</span><span class='line'>  <span class="l-Scalar-Plain">summary</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">match tag {{ tags.summary }}</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">set community {{ bgp_comm_summary }}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The resulting configuration for BR2-CORE will looks like this:</p>

<figure class='code'><figcaption><span>./files/BR2-CORE.bgp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>route-map RM-BGP-FROM-STATIC permit 10
</span><span class='line'>  match tag 110
</span><span class='line'>  set community 3:1
</span><span class='line'>route-map RM-BGP-FROM-SUMMARY permit 10
</span><span class='line'>  match tag 210
</span><span class='line'>  set community 3:0
</span><span class='line'>
</span><span class='line'>route-map RM-BGP-PREPEND-OUT permit 10
</span><span class='line'>  set as-path prepend 3 3 3 3 3 3 3
</span><span class='line'>!
</span><span class='line'>ip prefix-list PL-ALL-LOOPBACKS permit 0.0.0.0/0 le 32 ge 32
</span><span class='line'>!
</span><span class='line'>route-map RM-BGP-FALLOVER permit 10
</span><span class='line'>  match ip address prefix PL-ALL-LOOPBACKS
</span><span class='line'>!
</span><span class='line'>router bgp 3
</span><span class='line'>  redistribute static route-map RM-BGP-FROM-SUMMARY
</span><span class='line'>  redistribute static route-map RM-BGP-FROM-STATIC
</span><span class='line'>  neighbor 10.0.2.49 remote-as 2
</span><span class='line'>  neighbor RR-CLIENTS peer-group
</span><span class='line'>  neighbor RR-CLIENTS remote-as 3
</span><span class='line'>  neighbor RR-CLIENTS update-source Loopback0
</span><span class='line'>  neighbor RR-CLIENTS fall-over route-map RM-BGP-FALLOVER
</span><span class='line'>  neighbor RR-CLIENTS route-reflector-client
</span><span class='line'>  neighbor 10.0.3.2 peer-group RR-CLIENTS
</span><span class='line'>  neighbor 10.0.3.3 peer-group RR-CLIENTS
</span></code></pre></td></tr></table></div></figure>


<h2>Conclusion</h2>

<p>This post concludes the series of articles describing how to automate enteprise network configuration. We first looked at how to automate <a href="http://networkop.github.io/blog/2015/08/14/automating-legacy-networks/">legacy network configuration</a>, interface and OSPF configuration for the <a href="http://networkop.github.io/blog/2015/08/26/automating-network-build-p1/">new network build</a> and, finally, BGP configuration. Full version of files and scripts can be found in <a href="https://github.com/networkop/cisco-ansible-provisioning">my github repository</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automating New Network Build - Part 1]]></title>
    <link href="http://networkop.github.io/blog/2015/08/26/automating-network-build-p1/"/>
    <updated>2015-08-26T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2015/08/26/automating-network-build-p1</id>
    <content type="html"><![CDATA[<p>This post will demonstrate how to automate the build of a typical enterprise branch network consisting of a pair of WAN routers, a core switch and 3 access layer switches. I will show how to create the initial bootstrap configuration and enable basic routing with OSPF.</p>

<!--more-->


<h2>Prerequisites</h2>

<p>It is assumed that by this time all detailed network design information is known including interfaces numbers, VLANs, IP addresses and <abbr title="Link Aggregation Group">LAGs</abbr>. This information will be used as an input to configuration automation scripts.</p>

<p><img class="centre" src="http://networkop.github.io/images/new-office-design.png" title="New Office Network Topology" ></p>

<p>The inventory file is updated with a new <code>branch-2</code> group</p>

<figure class='code'><figcaption><span>./hosts</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>[branch-2]
</span><span class='line'>BR2-CORE ansible_ssh_host=10.0.3.1
</span><span class='line'>BR2-WAN1 ansible_ssh_host=10.0.3.2
</span><span class='line'>BR2-WAN2 ansible_ssh_host=10.0.3.3
</span><span class='line'>BR2-AS01 ansible_ssh_host=10.0.3.130
</span><span class='line'>BR2-AS02 ansible_ssh_host=10.0.3.131
</span><span class='line'>BR2-AS03 ansible_ssh_host=10.0.3.132
</span></code></pre></td></tr></table></div></figure>


<h2>Creating device bootstrap configuration</h2>

<p>A lot of times when building a new network it is required to create a bootstrap config that would have some basic AAA configuration along with the layer 2 and layer 3 links configuration. Since we went through the AAA configuration in the <a href="http://networkop.github.io/blog/2015/08/14/automating-legacy-networks/">previous post</a> I will omit that bit and get straight to the configuration of L2/L3 links. My personal rule of thumb is to configure all intra-site links as layer 2 trunks, including the links between the routed devices. This allows for greater flexibility in the future in case some traffic will need to get steered through a particular device.<br/>
The goal is to have configuration that would be copy-paste-friendly and would not require re-ordering or re-running. Therefore, it is important to apply configuration in the specific order:</p>

<ol>
<li>Layer 2 LAGs</li>
<li>Layer 2 port configuration</li>
<li>Layer 3 ip addressing</li>
</ol>


<p>The input information will be provided through a file called <code>interconnects</code> stored in the site-specific variable directory <code>branch-2</code>. Below is an abridged version of the file demonstrating the configuration of interfaces on the core switch. As always full version is available in my <a href="https://github.com/networkop/cisco-ansible-provisioning">github repository</a>.</p>

<figure class='code'><figcaption><span>./group_vars/branch-2/interconnects</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="nn">---</span>
</span><span class='line'><span class="l-Scalar-Plain">link_aggregation</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BR2-CORE</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Po11</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="nv">Eth0/2</span><span class="p-Indicator">,</span> <span class="nv">Eth0/3</span><span class="p-Indicator">]</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">l2_links</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BR2-CORE</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Eth0/0</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">11</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Eth0/1</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">12</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Eth1/0</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10,20,30,40,50</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Eth1/1</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">except 40</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Po11</span><span class="p-Indicator">:</span>   <span class="l-Scalar-Plain">10-50</span>
</span><span class='line'>
</span><span class='line'><span class="l-Scalar-Plain">l3_intf</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BR2-CORE</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Loopback0</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10.0.3.1/32</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Vlan11</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10.0.1.38/29</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Vlan12</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10.0.1.46/29</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Vlan10</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10.0.3.65/27</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Vlan20</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10.0.3.97/27</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Vlan30</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10.0.3.129/27</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Vlan40</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10.0.3.193/27</span>
</span><span class='line'>    <span class="l-Scalar-Plain">Vlan50</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">10.0.3.161/27</span>
</span></code></pre></td></tr></table></div></figure>


<p>This information is used by the <code>bootstrap</code> Ansible role to construct an interface configuration script. Here&rsquo;s the example of LAG configuration template. It iterates over all devices in <code>link_aggregation</code> variable and configures LACP protocol on each participating interface.</p>

<figure class='code'><figcaption><span>./roles/bootstrap/templates/bootstrap.conf.j2</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='jinja'><span class='line'><span class="cp">{%</span> <span class="k">if</span> <span class="nv">inventory_hostname</span> <span class="k">in</span> <span class="nv">link_aggregation</span> <span class="cp">%}</span><span class="x"></span>
</span><span class='line'><span class="x">  </span><span class="cp">{%</span> <span class="k">for</span> <span class="nv">channel_number</span> <span class="k">in</span> <span class="nv">link_aggregation</span><span class="o">[</span><span class="nv">inventory_hostname</span><span class="o">]</span> <span class="cp">%}</span><span class="x"></span>
</span><span class='line'><span class="x">    </span><span class="cp">{%</span> <span class="k">for</span> <span class="nv">interface</span> <span class="k">in</span> <span class="nv">link_aggregation</span><span class="o">[</span><span class="nv">inventory_hostname</span><span class="o">][</span><span class="nv">channel_number</span><span class="o">]</span> <span class="cp">%}</span><span class="x"></span>
</span><span class='line'><span class="x">interface </span><span class="cp">{{</span> <span class="nv">interface</span> <span class="cp">}}</span><span class="x"></span>
</span><span class='line'><span class="x">  channel-group </span><span class="cp">{{</span> <span class="nv">channel_number.split</span><span class="o">(</span><span class="s2">&quot;Po&quot;</span><span class="o">)[</span><span class="m">1</span><span class="o">]</span> <span class="cp">}}</span><span class="x"> mode active</span>
</span><span class='line'><span class="x">  no shutdown</span>
</span><span class='line'><span class="x">   </span><span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span><span class="x"></span>
</span><span class='line'><span class="x">  </span><span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span><span class="x"></span>
</span><span class='line'><span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span><span class="x"></span>
</span></code></pre></td></tr></table></div></figure>


<p>When configuring IP address information it&rsquo;s handy to use the built-in Ansible&rsquo;s <code>ipaddr</code> filter which can translate a prefix notation into Cisco&rsquo;s standard <code>ip_address netmask</code> as shown below:</p>

<figure class='code'><figcaption><span>./roles/bootstrap/templates/bootstrap.conf.j2</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='jinja'><span class='line'><span class="x"> </span><span class="cp">{%</span> <span class="k">if</span> <span class="nv">inventory_hostname</span> <span class="k">in</span> <span class="nv">l3_intf</span> <span class="k">and</span> <span class="nv">inventory_hostname</span> <span class="k">in</span> <span class="nv">groups</span><span class="o">[</span><span class="s1">&#39;routers&#39;</span><span class="o">]</span> <span class="k">and</span> <span class="k">not</span> <span class="nv">inventory_hostname</span> <span class="k">in</span> <span class="nv">groups</span><span class="o">[</span><span class="s1">&#39;switches&#39;</span><span class="o">]</span> <span class="cp">%}</span><span class="x"></span>
</span><span class='line'><span class="x">  </span><span class="cp">{%</span> <span class="k">for</span> <span class="nv">interface</span> <span class="k">in</span> <span class="nv">l3_intf</span><span class="o">[</span><span class="nv">inventory_hostname</span><span class="o">]</span> <span class="cp">%}</span><span class="x"></span>
</span><span class='line'><span class="x">interface </span><span class="cp">{{</span> <span class="nv">interface</span> <span class="cp">}}</span><span class="x"></span>
</span><span class='line'><span class="x">  ip address </span><span class="cp">{{</span> <span class="nv">l3_intf</span><span class="o">[</span><span class="nv">inventory_hostname</span><span class="o">][</span><span class="nv">interface</span><span class="o">]</span> <span class="o">|</span> <span class="nf">ipaddr</span><span class="o">(</span><span class="s1">&#39;address&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="x"> </span><span class="cp">{{</span> <span class="nv">l3_intf</span><span class="o">[</span><span class="nv">inventory_hostname</span><span class="o">][</span><span class="nv">interface</span><span class="o">]</span> <span class="o">|</span> <span class="nf">ipaddr</span><span class="o">(</span><span class="s1">&#39;netmask&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="x"></span>
</span><span class='line'><span class="x">  no shutdown</span>
</span><span class='line'><span class="x">  </span><span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span><span class="x"></span>
</span><span class='line'><span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span><span class="x"></span>
</span></code></pre></td></tr></table></div></figure>


<h2>Creating OSPF routing configuration</h2>

<p>OSPF configuration will adhere to the following simple conventions:</p>

<ul>
<li>All routed devices participate in OSPF</li>
<li>Every device advertises all its directly connected links</li>
<li>All links are passive by default with the exception of inter-device links</li>
<li>A single OSPF area 0 is used</li>
</ul>


<p>Another important aspect is separation of site-specific from enterprise-global configuration. The rule of thumb in this case would be to put as much information as possible into the global scope, keeping the site scope small. In our case all global variables and settings should reside under <code>./group_vars/routing</code> directory:</p>

<figure class='code'><figcaption><span>./group_vars/routing/igp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'> <span class="l-Scalar-Plain">---</span>
</span><span class='line'><span class="l-Scalar-Plain">ospf</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">global</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">default auto-cost reference-bandwidth 100000</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">router-id </span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">network 0.0.0.0 255.255.255.255 area 0</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">passive-interface default</span>
</span></code></pre></td></tr></table></div></figure>


<p>Site-specific OSPF variables will only contain a list of <em>active</em> interfaces that should form OSPF adjacencies:</p>

<figure class='code'><figcaption><span>./group_vars/branch-2/igp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="nn">---</span>
</span><span class='line'><span class="l-Scalar-Plain">ospf_intf_list</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BR2-CORE</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="nv">Vlan11</span><span class="p-Indicator">,</span> <span class="nv">Vlan12</span><span class="p-Indicator">]</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BR2-WAN1</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="nv">Eth0/1.11</span><span class="p-Indicator">]</span>
</span><span class='line'>  <span class="l-Scalar-Plain">BR2-WAN2</span><span class="p-Indicator">:</span> <span class="p-Indicator">[</span><span class="nv">Eth0/1.12</span><span class="p-Indicator">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Once again, a special <code>routing</code> role is created with a template making use of all of the configured variables:</p>

<figure class='code'><figcaption><span>./roles/routing/templates/igp.j2</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='jinja'><span class='line'><span class="x">router ospf 1</span>
</span><span class='line'><span class="cp">{%</span> <span class="k">for</span> <span class="nv">option</span> <span class="k">in</span> <span class="nv">ospf.global</span> <span class="cp">%}</span><span class="x"></span>
</span><span class='line'><span class="x">  </span><span class="cp">{{</span> <span class="nv">option</span> <span class="cp">}}</span><span class="x"></span>
</span><span class='line'><span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span><span class="x"></span>
</span><span class='line'><span class="cp">{%</span> <span class="k">for</span> <span class="nv">interface</span> <span class="k">in</span> <span class="nv">ospf_intf_list</span><span class="o">[</span><span class="nv">inventory_hostname</span><span class="o">]</span> <span class="cp">%}</span><span class="x"></span>
</span><span class='line'><span class="x">  no passive-interface </span><span class="cp">{{</span> <span class="nv">interface</span> <span class="cp">}}</span><span class="x"></span>
</span><span class='line'><span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span><span class="x"></span>
</span></code></pre></td></tr></table></div></figure>


<p>The resulting configuration for the core switch would like like this:</p>

<figure class='code'><figcaption><span>./files/BR2-CORE.igp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>router ospf 1
</span><span class='line'>  default auto-cost reference-bandwidth 100000
</span><span class='line'>  router-id 10.0.3.1
</span><span class='line'>  network 0.0.0.0 255.255.255.255 area 0
</span><span class='line'>  passive-interface default
</span><span class='line'>  no passive-interface Vlan11
</span><span class='line'>  no passive-interface Vlan12
</span></code></pre></td></tr></table></div></figure>


<p>Just a reminder that full versions of templates, files and playbooks can be found on <a href="https://github.com/networkop/cisco-ansible-provisioning">github</a>.</p>

<hr />

<p>That&rsquo;s it for the basic L2/L3 and routing configuration. In the next post I will show how to automate a standard BGP configuration.</p>
]]></content>
  </entry>
  
</feed>
