<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Network-oriented programming]]></title>
  <link href="http://networkop.github.io/atom.xml" rel="self"/>
  <link href="http://networkop.github.io/"/>
  <updated>2017-09-15T14:25:41+01:00</updated>
  <id>http://networkop.github.io/</id>
  <author>
    <name><![CDATA[Michael Kashin]]></name>
    <email><![CDATA[mmkashin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Openstack SDN - Skydiving Into Service Function Chaining]]></title>
    <link href="http://networkop.github.io/blog/2017/09/15/os-sfc-skydive/"/>
    <updated>2017-09-15T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2017/09/15/os-sfc-skydive</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;ll show how to configure Neutron&rsquo;s service function chaining,
troubleshoot it with Skydive and how SFC is implemented in OVS forwarding pipeline.</p>

<!--more-->


<hr />

<p><abbr title="Service Function Chaining">SFC</abbr> is another SDN feature that for a long time only used to be available in proprietary SDN solutions and that has recently become available in vanilla OpenStack. It serves as another proof that proprietary SDN solutions are losing the competitive edge, especially for Telco SDN/NFV use cases. Hopefully, by the end of this series of posts I&rsquo;ll manage do demonstrate how to build a complete open-source solution that has feature parity (in terms of major networking features) with all the major proprietary data centre SDN platforms. But for now, let&rsquo;s just focus on SFC.</p>

<h2>SFC High-level overview</h2>

<p>In most general terms, SFC refers to packet forwarding technique that uses more than just destination IP address to decide how to forward packets. In more specific terms, SFC refers to &ldquo;steering&rdquo; of traffic through a specific set of endpoints (a.k.a Service Functions), overriding the default destination-based forwarding. For those coming from a traditional networking background, think of SFC as a set of policy-based routing instances orchestrated from a central element (SDN controller). Typical use cases for SFC would be things like firewalling, IDS/IPS, proxying, NAT'ing, monitoring.</p>

<p>SFC is usually modelled as a directed (acyclic) graph, where the first and the last elements are the source and destination respectively and each vertex inside the graph represents a SF to be chained. IETF RFC7665 defines the reference architecture for SFC implementations and establishes some of the basic terminology. A simplified SFC architecture consists of the following main components:</p>

<ul>
<li>Classifier - a network element that matches and redirects traffic flows to a chain</li>
<li>Service Function - an element responsible for packet processing</li>
<li>Service Function Forwarder - a network element that forwards traffic to and from a directly connected SF</li>
</ul>


<p><img class="center" src="http://networkop.github.io/images/sfc-overview.png"></p>

<p>One important property of a SF is elasticity. More instances of the same type can be added to a pool of SF and SFF will load-balance the traffic between them. This is the reason why, as we&rsquo;ll see in the next section, SFF treats connections to a SF as a group of ports rather than just a single port.</p>

<h2>Configuring Neutron SFC</h2>

<p> We&rsquo;ll pick up where we left off in the <a href="http://networkop.github.io/blog/2017/09/08/os-lab-docker/">previous post</a>. All Neutron and ML2 configuration files have already been updated thanks to the <code>enable_sfc="yes"</code> setting in the global Kolla-Ansible configuration file. If not, you can change it in <code>/etc/kolla/globals.yaml</code> and re-run kolla-ansible deployment script.</p>

<p> First, let&rsquo;s generate OpenStack credentials using a post-deployment script. We later can use a default bootstrap script to downloads the cirros image and set up some basic networking and security rules.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>kolla-ansible post-deploy
</span><span class='line'><span class="nb">source</span> /etc/kolla/admin-openrc.sh
</span><span class='line'>/usr/share/kolla-ansible/init-runonce
</span></code></pre></td></tr></table></div></figure>


<p>The goal for this post is to create a simple uni-directional SFC to steer the ICMP requests from VM1 to its default gateway through another VM that will be playing the role of a firewall.</p>

<p><img class="center" src="http://networkop.github.io/images/sfc-example.png"></p>

<p>The network was already created by the bootstrap script so all what we have to do is create a test VM. I&rsquo;m creating a port in a separate step simply so that I can refer to it by name instead of UUID.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>openstack port create --network demo-net P0
</span><span class='line'>openstack server create --image cirros --flavor m1.tiny --port P0 VM1
</span></code></pre></td></tr></table></div></figure>


<p>I&rsquo;ll go over all the necessary steps to setup SFC, but will only provide a brief explanation. Refer to the official OpenStack <a href="https://docs.openstack.org/newton/networking-guide/config-sfc.html">Networking Guide</a> for a complete SFC configuration guide.</p>

<p>First, let&rsquo;s create a FW VM with two ports - P1 and P2.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>openstack port create --network demo-net P1
</span><span class='line'>openstack port create --network demo-net P2
</span><span class='line'>openstack server create --image cirros --flavor m1.tiny --port P1 --port P2 FW
</span></code></pre></td></tr></table></div></figure>


<p>Next, we need create an ingress/egress port pair and assign it to a port pair group.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>openstack sfc port pair create --ingress P1 --egress P2 PPAIR
</span><span class='line'>openstack sfc port pair group create --port-pair PPAIR PPGROUP
</span></code></pre></td></tr></table></div></figure>


<p>Finally, we can create a flow classifier for ICMP traffic coming from VM1&rsquo;s port P0 and tie it together with a previously created port pair group.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>openstack sfc flow classifier create --protocol icmp --logical-source-port P0 FLOW-ICMP
</span><span class='line'>openstack sfc port chain create --port-pair-group PPGROUP --flow-classifier FLOW-ICMP PCHAIN
</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s all the configuration needed to setup SFC. However if you login VM1&rsquo;s console and try pinging default gateway, it will fail. Next, I&rsquo;m going to give a quick demo of how to use a real-time network analyzer tool called Skydive to troubleshoot this issue.</p>

<h2>Using Skydive to troubleshoot SFC</h2>

<p><a href="https://skydive-project.github.io/skydive/">Skydive</a> is a new open-source distributed network probing and traffic analyzing tool. It consists of a set of agents running on compute nodes, collecting topology and flow information and forwarding it to a central element for analysis.</p>

<p>The idea of using Skydive to analyze and track SFC is not new. In fact, for anyone interested in this topic I highly recommend the <a href="http://blog.cafarelli.fr/2017/02/tracking-service-function-chaining-with-skydive/">following blogpost</a>. In my case I&rsquo;ll show how to use Skydive from a more practical perspective - troubleshooting multiple SFC issues.</p>

<p>Skydive CLI client is available inside the <code>skydive_analyzer</code> container. We need to start an interactive bash session inside this container and set some environment variables:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>docker <span class="nb">exec</span> -it skydive_analyzer bash
</span><span class='line'><span class="nb">export </span><span class="nv">SKYDIVE_ANALYZERS</span><span class="o">=</span>192.168.133.100:8085
</span><span class='line'><span class="nb">export </span><span class="nv">SKYDIVE_USERNAME</span><span class="o">=</span>admin
</span><span class='line'><span class="nb">export </span><span class="nv">SKYDIVE_PASSWORD</span><span class="o">=</span>admin
</span></code></pre></td></tr></table></div></figure>


<p>The first thing we can do to troubleshoot is see if ICMP traffic is entering the <code>ingress</code> port of the FW VM. Based on the output of <code>openstack port list</code> command I know that P1 has got an IP of <code>10.0.0.8</code>. Let&rsquo;s if we can identify a tap port corresponding to P1:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>skydive client topology query --gremlin <span class="s2">&quot;G.V().Has(&#39;Neutron.IPs&#39;, &#39;10.0.0.8&#39;, &#39;Type&#39;, &#39;tun&#39;).Values(&#39;Neutron&#39;)&quot;</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="s2">&quot;IPs&quot;</span>: <span class="s2">&quot;10.0.0.8&quot;</span>,
</span><span class='line'>  <span class="s2">&quot;NetworkID&quot;</span>: <span class="s2">&quot;8eabb451-b026-417c-b54b-8e79ee6e71c3&quot;</span>,
</span><span class='line'>  <span class="s2">&quot;NetworkName&quot;</span>: <span class="s2">&quot;demo-net&quot;</span>,
</span><span class='line'>  <span class="s2">&quot;PortID&quot;</span>: <span class="s2">&quot;e6334df9-a5c4-4e86-a5f3-671760c2bbbe&quot;</span>,
</span><span class='line'>  <span class="s2">&quot;TenantID&quot;</span>: <span class="s2">&quot;bd5829e0cb5b40b68ab4f8e7dc68b14d&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The output above proves that skydive agent has successfully read the configuration of the port and we can start a capture on that object to see any packets arriving on P1.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>skydive client capture create --gremlin <span class="s2">&quot;G.V().Has(&#39;Neutron.IPs&#39;, &#39;10.0.0.8&#39;, &#39;Type&#39;, &#39;tun&#39;)&quot;</span>
</span><span class='line'>skydive client topology query --gremlin <span class="s2">&quot;G.V().Has(&#39;Neutron.IPs&#39;, &#39;10.0.0.8&#39;, &#39;Type&#39;, &#39;tun&#39;).Flows().Has(&#39;Application&#39;,&#39;ICMPv4&#39;).Values(&#39;Metric.ABPackets&#39;)&quot;</span>
</span><span class='line'><span class="o">[</span>
</span><span class='line'>  7
</span><span class='line'><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you <code>watch</code> the last command for several seconds you should see that the number in brackets is increasing. That means that packets are hitting the ingress port of the FW VM. Now let&rsquo;s repeat the same test on <code>egress</code> port P2.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>skydive client capture create --gremlin <span class="s2">&quot;G.V().Has(&#39;Neutron.IPs&#39;, &#39;10.0.0.4&#39;, &#39;Type&#39;, &#39;tun&#39;)&quot;</span>
</span><span class='line'>skydive client topology query --gremlin <span class="s2">&quot;G.V().Has(&#39;Neutron.IPs&#39;, &#39;10.0.0.4&#39;, &#39;Type&#39;, &#39;tun&#39;).Flows()&quot;</span>
</span><span class='line'><span class="o">[]</span>
</span></code></pre></td></tr></table></div></figure>


<p>The output above tells us that there are no packets coming out of the FW VM. This is expected since we haven&rsquo;t done any changes to the blank cirros image to make it forward the packets between the two interfaces. If we examine the IP configuration of the FW VM, we would see that it doesn&rsquo;t have an IP address configured on the second interface. We would also need to create a source-based routing policy to force all traffic from VM1 (<code>10.0.0.6</code>) to egress via interface <code>eth2</code> and make sure IP forwarding is turned on. The following commands would need to be executed on FW VM:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo cirros-dhcpc up eth1
</span><span class='line'>sudo ip rule add from 10.0.0.6 table default
</span><span class='line'>sudo ip route add default via 10.0.0.1 dev eth1 table default
</span><span class='line'>sudo sysctl -w net.ipv4.ip_forward<span class="o">=</span>1
</span></code></pre></td></tr></table></div></figure>


<p>Having done that, we should see some packets coming out of <code>egress</code> port P2.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>skydive client topology query --gremlin <span class="s2">&quot;G.V().Has(&#39;Neutron.IPs&#39;, &#39;10.0.0.4&#39;, &#39;Type&#39;, &#39;tun&#39;).Flows().Has(&#39;Application&#39;,&#39;ICMPv4&#39;).Values(&#39;Metric.ABPackets&#39;)&quot;</span>
</span><span class='line'><span class="o">[</span>
</span><span class='line'>  7
</span><span class='line'><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>However form the VM1&rsquo;s perspective the ping is still failing. Next step would be to see if the packets are hitting the integration bridge that port P2 is attached to:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>skydive client capture create --gremlin <span class="s2">&quot;G.V().Has(&#39;Neutron.IPs&#39;, &#39;10.0.0.4&#39;, &#39;Type&#39;, &#39;veth&#39;)&quot;</span>
</span><span class='line'>skydive client topology query --gremlin <span class="s2">&quot;G.V().Has(&#39;Neutron.IPs&#39;, &#39;10.0.0.4&#39;, &#39;Type&#39;, &#39;veth&#39;).Flows()&quot;</span>
</span><span class='line'><span class="o">[]</span>
</span></code></pre></td></tr></table></div></figure>


<p>No packets means they are getting dropped somewhere between the P2 and the integration bridge. This can only be done by security groups. In fact, source MAC/IP anti-spoofing is enabled by default which would only allow packets matching the source MAC/IP addresses assigned to P2 and would drop any packets coming from VM1&rsquo;s IP address. The easiest fix would be to disable security groups for P2 completely:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>openstack port <span class="nb">set</span> --no-security-group --disable-port-security P2
</span></code></pre></td></tr></table></div></figure>


<p>After this step the counters should start incrementing and the ping from VM1 to its default gateway is resumed.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>skydive client topology query --gremlin <span class="s2">&quot;G.V().Has(&#39;Neutron.IPs&#39;, &#39;10.0.0.4&#39;, &#39;Type&#39;, &#39;veth&#39;).Flows().Has(&#39;Application&#39;,&#39;ICMPv4&#39;).Values(&#39;Metric.ABPackets&#39;)&quot;</span>
</span><span class='line'><span class="o">[</span>
</span><span class='line'>  79
</span><span class='line'><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>SFC implementation in OVS forwarding pipeline</h2>

<p>There are several ways to implement SFC, each unique to its own domain. In service provider WAN it can be accomplished by Segment Routing, in DC underlay it can be done with PBR policies. When it comes to OVS there are two major implementations. One approach, implemented in Opendaylight, uses Network Service Header (NSH) as a shim between VXLAN-GPE and the encapsulated packet. The benefit of this approach is that each SF, as well as the sender, can read and write NSH&rsquo;s metadata, making the service function path more transparent. Another approach, currently implemented in ML2&rsquo;s OVS-agent, is based on MPLS header. The only element being affected in this case is the integration bridge. Refer to my <a href="http://networkop.co.uk/blog/2016/04/22/neutron-native/">older post</a> about vanilla OpenStack networking for a refresher of the vanilla OVS-agent architecture.</p>

<p>Normally, I would start by collecting all port and flow details from the integration bridge with the following commands:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ovs-ofctl dump-ports-desc br-int  <span class="p">|</span> grep addr
</span><span class='line'>ovs-ofctl dump-flows br-int <span class="p">|</span> cut -d <span class="s1">&#39;,&#39;</span> -f3-
</span></code></pre></td></tr></table></div></figure>


<p>However, for the sake of brevity, I will omit the actual outputs and only show graphical representation of forwarding tables and packet flows. The tables below have two columns - first showing what is being matched and second showing the resulting action. Let&rsquo;s start with the OpenFlow rules in an integration bridge before SFC is configured:</p>

<p><img class="center" src="http://networkop.github.io/images/sfc-before-tables.png"></p>

<p>As we can see, the table structure is quite simple, since integration bridge mostly relies on data-plane MAC learning. A couple of MAC and ARP anti-spoofing tables will check the validity of a packet and send it to table 60 where <code>NORMAL</code> action will trigger the &ldquo;flood-and-learn&rdquo; behaviour. Therefore, an ICMP packet coming from VM1 will take the following path:</p>

<p><img class="center" src="http://networkop.github.io/images/sfc-before-packet.png"></p>

<p>After we&rsquo;ve configured SFC, the forwarding pipeline is changed and now looks like this:</p>

<p><img class="center" src="http://networkop.github.io/images/sfc-after-tables.png"></p>

<p>First, we can see that table 0 acts as a classifier, by redirecting the &ldquo;interesting&rdquo; packets towards <code>group 1</code>. This groups is an <a href="https://floodlight.atlassian.net/wiki/spaces/floodlightcontroller/pages/7995427/How+to+Work+with+Fast-Failover+OpenFlow+Groups">OpenFlow Group</a> of type <code>select</code>, which load-balances traffic between multiple destinations. This is where SF scale-out that I mentioned earlier is implemented. In our case we&rsquo;ve only got a single SF, so the packet gets its destination MAC updated to that of SF&rsquo;s ingress port and is forwarded to a new table 5.</p>

<p>Table 5 is where all packets destined for a SF are aggregated with a single MPLS label which uniquely identifies the next SF in the chain. The packet is then forwarded to table 10, which I&rsquo;ve called <code>SFC Ingress</code>. This is where the packets are distributed to all SF&rsquo;s ingress ports based on the assigned MPLS label.</p>

<p><img class="center" src="http://networkop.github.io/images/sfc-after-packet.png"></p>

<p>After being processed by a SF, the packet leaves the <code>egress</code> port and re-enters the integration bridge. This time table 0 knows that the packet has already been processed by a SF and, since the anti-spoofing rules have been disabled, simply floods the packet out of all ports in the same VLAN. The packet gets flooded to the tunnel bridge where it gets replicated and delivered to the <code>qrouter</code> sitting on the controller node as per the <a href="http://networkop.co.uk/blog/2016/04/22/neutron-native/">default behaviour</a>.</p>

<h2>Coming Up</h2>

<p>SFC is one of the major features in Telco SDN and, like many things, it&rsquo;s not meant to be configured manually. In fact, Telco SDN have their own framework for management and orchestration of VNFs (a.k.a. VMs) and VNF forwarding graphs (a.k.a. SFCs) called ETSI MANO. As it is expected from a Telco standard, it abounds with acronyms and confuses the hell out of anyone who&rsquo;s name is not on the list of authors or contributors. That&rsquo;s why in the next post I will try to provide a brief overview of what Telco SDN is and use Tacker, a software implementation of NFVO and VNFM, to automatically build a firewall VNF and provision a SFC, similar to what has been done in this post manually.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack SDN - Building a Containerized OpenStack Lab]]></title>
    <link href="http://networkop.github.io/blog/2017/09/08/os-lab-docker/"/>
    <updated>2017-09-08T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2017/09/08/os-lab-docker</id>
    <content type="html"><![CDATA[<p>I&rsquo;m returning to my OpenStack SDN series to explore some of the new platform features like service function chaining, network service orchestration, intent-based networking and dynamic WAN routing. To kick things off I&rsquo;m going to demonstrate my new fully-containerized OpenStack Lab that I&rsquo;ve built using an OpenStack project called Kolla.</p>

<!--more-->


<hr />

<p>For quite a long time installation and deployment have been deemed as major barriers for OpenStack adoption. The classic &ldquo;install everything manually&rdquo; approach could only work in small production or lab environments and the ever increasing number of project under the <a href="https://governance.openstack.org/tc/reference/projects/">&ldquo;Big Tent&rdquo;</a> made service-by-service installation infeasible. This led to the rise of automated installers that over time evolved from a simple collection of scripts to container management systems.</p>

<h2>Evolution of automated OpenStack installers</h2>

<p>The first generation of automated installers were simple utilities that tied together a collection of Puppet/Chef/Ansible scripts. Some of these tools could do baremetal server provisioning through Cobbler or Ironic (Fuel, Compass) and some relied on server operating system to be pre-installed (Devstack, Packstack). In either case the packages were pulled from the Internet or local repository every time the installer ran.</p>

<p>The biggest problem with the above approach is the time it takes to re-deploy, upgrade or scale the existing environment. Even for relatively small environments it could be hours before all packages are downloaded, installed and configured. One of the ways to tackle this is to pre-build an operating system with all the necessary packages and only use Puppet/Chef/Ansible to change configuration files and turn services on and off. Redhat&rsquo;s TripleO is one example of this approach. It uses a &ldquo;golden image&rdquo; with pre-installed OpenStack packages, which is dd-written bit-by-bit onto the baremetal server&rsquo;s disk. The undercloud then decides which services to turn on based on the overcloud server&rsquo;s role.</p>

<p>Another big problem with most of the existing deployment methods was that, despite their microservices architecture, all OpenStack services were deployed as static packages on top of a shared operating system. This made the ongoing operations, troubleshooting and ugprades really difficult. The obvious thing to do would be to have all OpenStack services (e.g. Neutron, Keyston, Nova) deployed as containers and managed by a container management system. The first company to implement that, as far as I know, was Canonical. The deployment process is quite complicated, however the end result is a highly flexible OpenStack cloud deployed using LXC containers, managed and orchestrated by Juju controller.</p>

<p>Today (September 2017) deploying OpenStack services as containers is becoming mainstream and in this post I&rsquo;ll show how to use Kolla to build container images and Kolla-Ansible to deploy them on a pair of &ldquo;baremetal&rdquo; VMs.</p>

<h2>Lab overview</h2>

<p>My lab consists of a single controller and a single compute VM. The goal was to make them as small as possible so they could run on a laptop with limited resources. Both VMs are connected to three VM bridged networks - provisioning, management and external VM access.</p>

<p><img class="center" src="http://networkop.github.io/images/kolla-lab.png"></p>

<p>I&rsquo;ve written some bash and Ansible scripts to automate the deployment of VMs on top of any Fedora derivative (e.g. Centos7). These scripts should be run directly from the hypervisor:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git clone https://github.com/networkop/kolla-odl-bgpvpn.git <span class="o">&amp;&amp;</span> <span class="nb">cd </span>kolla-odl-bgpvpn
</span><span class='line'>./1-create.sh <span class="k">do</span>
</span><span class='line'>./2-bootstrap.sh <span class="k">do</span>
</span></code></pre></td></tr></table></div></figure>


<p>The first bash script downloads the VM OS (Centos7), creates two blank VMs and sets up a local Docker registry. The second script installs all the dependencies, including Docker and Ansible.</p>

<h2>Building OpenStack docker containers with Kolla</h2>

<p>The first step in Kolla deployment workflow is deciding where to get the Docker images. Kolla maintains a <a href="https://hub.docker.com/u/kolla/">Docker Hub registry</a> with container images built for every major OpenStack release. The easiest way to get them would be to pull the images from Docker hub either directly or via a <a href="https://docs.docker.com/registry/recipes/mirror/">pull-through caching registry</a>.</p>

<p>In my case I needed to build the latest version of OpenStack packages, not just the latest major release. I also wanted to build a few additional, non-Openstack images (Opendaylight and Quagga). Because of that I had to build all Docker images locally and push them into a local docker registry. The procedure to build container images is very well documented in the official <a href="https://docs.openstack.org/kolla/latest/image-building.html">Kolla image building guide</a>. I&rsquo;ve modified it slightly to include the Quagga Dockerfile and automated it so that the whole process can be run with a single command:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>./3-build.sh <span class="k">do</span>
</span></code></pre></td></tr></table></div></figure>


<p>This step can take quite a long time (anything from 1 to 4 hours depending on the network and disk I/O speed), however, once it&rsquo;s been done these container images can be used to deploy as many OpenStack instances as necessary.</p>

<h2>Deploying OpenStack with Kolla-Ansible</h2>

<p>The next step in OpenStack deployment workflow is to deploy Docker images on target hosts. <a href="https://docs.openstack.org/kolla-ansible/latest/quickstart.html">Kolla-Ansible</a> is a highly customizable OpenStack deployment tool that is also extemely easy to use, at least for people familiar with Ansible. There are two main sources of information for Kolla-Ansible:</p>

<ul>
<li>Global configuration file (/etc/kolla/globals.yaml), which contains some of the most common customization options</li>
<li>Ansible inventory file (/usr/share/kolla-ansible/ansible/inventory/*), which maps OpenStack packages to target deployment hosts</li>
</ul>


<p>To get started with Kolla-Ansible all what it takes is a few modifications to the global configuration file to make sure that network settings match the underlying OS interface configuration and an update to the inventory file to point it to the correct deployment hosts. In my case I&rsquo;m making additional changes to enable SFC, Skydive and Tacker and adding files for Quagga container, all of which can be done with the following command:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>./4-deploy.sh <span class="k">do</span>
</span></code></pre></td></tr></table></div></figure>


<p>The best thing about this method of deployment is that it takes (in my case) under 5 minutes to get the full OpenStack cloud from scratch. That means if I break something or want to redeploy with some major changes (add/remove Opendaylight), all what I have to do is destroy the existing deployment (approx. 1 minute), modify global configuration file and re-deploy OpenStack. This makes Kolla-Ansible an ideal choice for my lab environment.</p>

<h2>Overview of containerized Openstack</h2>

<p>Once the deployment has been completed, we should be able to see a number of running Docker containers - one for each OpenStack process.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>root@compute-1# docker ps
</span><span class='line'>CONTAINER ID        IMAGE                                                                 COMMAND             CREATED             STATUS              PORTS               NAMES
</span><span class='line'>0bb8a8eeb1a9        172.26.0.1:5000/kolla/centos-source-skydive-agent:5.0.0               <span class="s2">&quot;kolla_start&quot;</span>       <span class="m">3</span> days ago          Up <span class="m">3</span> days                               skydive_agent
</span><span class='line'>63b5b643dfae        172.26.0.1:5000/kolla/centos-source-neutron-openvswitch-agent:5.0.0   <span class="s2">&quot;kolla_start&quot;</span>       <span class="m">3</span> days ago          Up <span class="m">3</span> days                               neutron_openvswitch_agent
</span><span class='line'>f6f74c5982cb        172.26.0.1:5000/kolla/centos-source-openvswitch-vswitchd:5.0.0        <span class="s2">&quot;kolla_start&quot;</span>       <span class="m">3</span> days ago          Up <span class="m">3</span> days                               openvswitch_vswitchd
</span><span class='line'>3078421a3892        172.26.0.1:5000/kolla/centos-source-openvswitch-db-server:5.0.0       <span class="s2">&quot;kolla_start&quot;</span>       <span class="m">3</span> days ago          Up <span class="m">3</span> days                               openvswitch_db
</span><span class='line'>9146c16d561b        172.26.0.1:5000/kolla/centos-source-nova-compute:5.0.0                <span class="s2">&quot;kolla_start&quot;</span>       <span class="m">3</span> days ago          Up <span class="m">3</span> days                               nova_compute
</span><span class='line'>8079f840627f        172.26.0.1:5000/kolla/centos-source-nova-libvirt:5.0.0                <span class="s2">&quot;kolla_start&quot;</span>       <span class="m">3</span> days ago          Up <span class="m">3</span> days                               nova_libvirt
</span><span class='line'>220d617d31a5        172.26.0.1:5000/kolla/centos-source-nova-ssh:5.0.0                    <span class="s2">&quot;kolla_start&quot;</span>       <span class="m">3</span> days ago          Up <span class="m">3</span> days                               nova_ssh
</span><span class='line'>743ce602d485        172.26.0.1:5000/kolla/centos-source-cron:5.0.0                        <span class="s2">&quot;kolla_start&quot;</span>       <span class="m">3</span> days ago          Up <span class="m">3</span> days                               cron
</span><span class='line'>8b71f08d2781        172.26.0.1:5000/kolla/centos-source-kolla-toolbox:5.0.0               <span class="s2">&quot;kolla_start&quot;</span>       <span class="m">3</span> days ago          Up <span class="m">3</span> days                               kolla_toolbox
</span><span class='line'>f76d0a7fcf2a        172.26.0.1:5000/kolla/centos-source-fluentd:5.0.0                     <span class="s2">&quot;kolla_start&quot;</span>       <span class="m">3</span> days ago          Up <span class="m">3</span> days                               fluentd
</span></code></pre></td></tr></table></div></figure>


<p>All the standard docker tools are available to interact with those containers. For example, this is how we can see what processes are running inside a container:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>root@compute-1# docker <span class="nb">exec </span>nova_compute ps -www aux
</span><span class='line'>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
</span><span class='line'>nova         <span class="m">1</span>  0.0  0.0    <span class="m">188</span>     <span class="m">4</span> pts/3    Ss+  Sep04   0:00 /usr/local/bin/dumb-init /bin/bash /usr/local/bin/kolla_start
</span><span class='line'>nova         <span class="m">7</span>  0.7  1.3 <span class="m">2292560</span> <span class="m">134896</span> ?      Ssl  Sep04  35:33 /var/lib/kolla/venv/bin/python /var/lib/kolla/venv/bin/nova-compute
</span><span class='line'>root        <span class="m">86</span>  0.0  0.3 <span class="m">179816</span> <span class="m">32900</span> ?        S    Sep05   0:00 /var/lib/kolla/venv/bin/python /var/lib/kolla/venv/bin/privsep-helper --config-file /etc/nova/nova.conf --privsep_context vif_plug_ovs.privsep.vif_plug --privsep_sock_path /tmp/tmpFvP0GS/privsep.sock
</span></code></pre></td></tr></table></div></figure>


<p>Some of you may have noticed that none of the containers expose any ports. So how do they communicate? The answer is very simple - all containers run in a <strong>host</strong> networking mode, effectively disabling any network isolation and giving all contaners access to TCP/IP stacks of their Docker hosts. This is a simple way to avoid having to deal with Docker networking complexities, while at the same time preserving the immutability and portability of Docker containers.</p>

<p>All containers are configured to restart in case of a failure, however there&rsquo;s no <abbr title="Container Management System">CMS</abbr> to provide full lifecycle management and advanced scheduling. If upgrade of scale-in/out is needed, Kolla-Ansible will have to be re-run with updated configuration options. There is sibling project called <a href="https://github.com/openstack/kolla-kubernetes">Kolla-Kubernetes</a> (still under developement), that&rsquo;s designed to address some of the mentioned shortcomings.</p>

<h2>Coming up</h2>

<p>Now that the lab is up we can start exploring the new OpenStack SDN features. In the next post I&rsquo;ll have a close look at Neutron&rsquo;s <abbr title=" Service Function Chainng">SFC</abbr> feature, how to configure it and how it&rsquo;s been implemented in OVS forwarding pipeline.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux SSH Session Management for Network Engineers]]></title>
    <link href="http://networkop.github.io/blog/2017/05/12/linux-ssh/"/>
    <updated>2017-05-12T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2017/05/12/linux-ssh</id>
    <content type="html"><![CDATA[<p>A short post about how I do SSH session management for network devices in Linux</p>

<!--more-->


<hr />

<p>A few weeks ago I bought myself a new Dell XPS-13 and decided for the n-th time to go all-in Linux, that is to have Linux as the main and only laptop OS. Since most of my Linux experience is with Fedora-family distros, I quickly installed Fedora-25 and embarked on a long and painful journey of getting out of my Windows comfort zone and re-establishing it in Linux. One of the most important aspects for me, as a network engineer, is to have a streamlined process of accessing network devices. In Windows I was using MTPutty and it helped define my expectations of an ideal SSH session manager:</p>

<ul>
<li>I want a multi-tab terminal with the ability to switch between tabs quickly - default (GNOME) terminal does that out-of-the box with no extra modifications</li>
<li>I want to login the device without having to enter a password - Not available by default but is possible with some dirty <code>expect</code> hacks.</li>
<li>I want my SSH sessions to be organised in a hierarchical manner with groups representing various administrative domains - customer A, local VMs, lab.</li>
</ul>


<p>Although GNOME terminal looked like a very good option, it didn&rsquo;t meet all of my requirements. I briefly looked and PAC Manager and GNOME Connection Manager but quickly dismissed them due to their ugliness and clunkiness. Ideally I wanted to keep using GNOME terminal as the main terminal emulator, without having to configure and rely on other 3rd party apps. I also didn&rsquo;t want to wrap my SSH session in <code>expect</code> as I didn&rsquo;t want my password to be pasted in my screen every time I <em>cat</em> a file containing the trigger keyword <em>Password:</em>. I&rsquo;ve finally managed to make everything work inside the native GNOME terminal and this post is a documentation of my approach.</p>

<h2>1. Install ssh-copy-net</h2>

<p>I&rsquo;ve written a little <a href="https://github.com/networkop/ssh-copy-net">tool</a> that uses <a href="https://github.com/ktbyers/netmiko">Netmiko</a> to install (and remove) public SSH keys onto network devices. Assuming <code>python-pip</code> is already installed here&rsquo;s what&rsquo;s required to download and install <code>ssh-copy-net</code>:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>pip install git+https://github.com/networkop/ssh-copy-net.git
</span></code></pre></td></tr></table></div></figure>


<p>Its functionality mimics the one of <code>ssh-copy-id</code>, so the next step is always to upload the public key to the device:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ssh-copy-net 10.6.142.1 juniper
</span><span class='line'>Username: admin
</span><span class='line'>Password:
</span><span class='line'>All Done!
</span></code></pre></td></tr></table></div></figure>


<h2>2. Define SSH config for network devices</h2>

<p>OpenSSH client <a href="https://linux.die.net/man/5/ssh_config">config file</a> provides a nice way of managing user&rsquo;s SSH sessions. Configuration file allows you to define per-host SSH settings including username, port forwarding options, key checking flags etc. In my case all what I had to do was define IP addresses of my network devices:</p>

<figure class='code'><figcaption><span>/home/null/.ssh/config</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Host srx
</span><span class='line'>  HostName 10.6.142.1
</span><span class='line'>
</span><span class='line'>Host arista
</span><span class='line'>  HostName 10.6.142.2
</span></code></pre></td></tr></table></div></figure>


<p>Now I am able to login the device by simply typing its name:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ssh arista
</span><span class='line'>Last login: Sun May  <span class="m">7</span> 10:57:30 <span class="m">2017</span> from 10.1.2.3
</span><span class='line'>arista-1&gt;
</span></code></pre></td></tr></table></div></figure>


<h2>3. Define zsh aliases</h2>

<p>The final step is session organisations. For that I&rsquo;ve decided to use zsh aliases and have device groups encoded in the alias name, separated by dashes. For example, if my SRX device was in the <strong>lab</strong> and Arista was in <strong>Site-51</strong> of <strong>Customer-A</strong> this is how I would write my aliases:</p>

<figure class='code'><figcaption><span>/home/null/.zshrc</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">alias </span>lab-srx<span class="o">=</span><span class="s1">&#39;ssh srx&#39;</span>
</span><span class='line'><span class="nb">alias </span>customer-a-site-51-arista<span class="o">=</span><span class="s1">&#39;ssh arista&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>4. Multi-pane sessions with tmux</h2>

<p>As a network engineer, I often find myself troubleshooting issues spanning multiple devices, which is why I need multiple tabs inside a single terminal window. Simply pressing Ctrl+T in GNOME terminal opens a new tab and I can switch between tabs using Alt+[1-9]. However what would be really nice is to have a couple of tabs opened side by side so that I can see the logs and compare output on a number of devices at the same time. This is where tmux comes in. It can do much more than this, but I simply use it to have multiple panes inside the same terminal tab:</p>

<p><img class="center" src="http://networkop.github.io/images/tmux.png"></p>

<p>Here&rsquo;s an example of my tmux configuration file:</p>

<figure class='code'><figcaption><span>/home/null/.tmux.conf</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Automatically set window title</span>
</span><span class='line'><span class="nb">set</span>-window-option -g automatic-rename on
</span><span class='line'><span class="nb">set</span>-option -g <span class="nb">set</span>-titles on
</span><span class='line'>
</span><span class='line'><span class="c"># Use Alt-arrow keys without prefix key to switch panes</span>
</span><span class='line'><span class="nb">bind</span> -n M-Left <span class="k">select</span>-pane -L
</span><span class='line'><span class="nb">bind</span> -n M-Right <span class="k">select</span>-pane -R
</span><span class='line'><span class="nb">bind</span> -n M-Up <span class="k">select</span>-pane -U
</span><span class='line'><span class="nb">bind</span> -n M-Down <span class="k">select</span>-pane -D
</span><span class='line'>
</span><span class='line'><span class="c"># Pane splitting keys</span>
</span><span class='line'><span class="nb">bind</span>-key v split-window -h
</span><span class='line'><span class="nb">bind</span>-key s split-window -v
</span><span class='line'>
</span><span class='line'><span class="c"># New key-binding to reset hung SSH sessions</span>
</span><span class='line'><span class="nb">bind</span>-key k respawn-pane -k
</span><span class='line'>
</span><span class='line'><span class="c"># Easy fix for arrow keys inside ssh</span>
</span><span class='line'><span class="nb">set</span> -g default-terminal <span class="s2">&quot;xterm&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Enable mouse mode (tmux 2.1 and above)</span>
</span><span class='line'><span class="nb">set</span> -g mouse on
</span><span class='line'>
</span><span class='line'><span class="c"># Reload tmux config</span>
</span><span class='line'><span class="nb">bind </span>r <span class="nb">source</span>-file ~/.tmux.conf
</span><span class='line'>
</span><span class='line'><span class="c"># No delay for escape key press</span>
</span><span class='line'><span class="nb">set</span> -sg escape-time 0
</span></code></pre></td></tr></table></div></figure>


<h2>Demo</h2>

<p>Now having all the above defined and with the help of zsh command autocompletion, I can login the device with just a few keypresses (shown in square brackets below):</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>lab  <span class="o">[</span>TAB<span class="o">]</span>
</span><span class='line'><span class="nv">$ </span>lab-  <span class="o">[</span>TAB<span class="o">]</span>
</span><span class='line'>lab-srx
</span><span class='line'><span class="nv">$ </span>lab-  <span class="o">[</span>s<span class="o">][</span>TAB<span class="o">]</span>
</span><span class='line'><span class="nv">$ </span>lab-srx  <span class="o">[</span>ENTER<span class="o">]</span>
</span><span class='line'>--- JUNOS 12.3X48-D30.7 built 2016-04-28 22:37:34 UTC
</span><span class='line'><span class="o">{</span>primary:node0<span class="o">}</span>
</span><span class='line'>null@srx&gt;
</span></code></pre></td></tr></table></div></figure>


<p>Press Ctrl+B v to split the terminal window vertically:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>customer <span class="o">[</span>TAB<span class="o">]</span>
</span><span class='line'><span class="nv">$ </span>customer- <span class="o">[</span>TAB<span class="o">]</span>
</span><span class='line'>customer-a-site-51-arista
</span><span class='line'><span class="nv">$ </span>customer- <span class="o">[</span>a<span class="o">][</span>TAB<span class="o">]</span>
</span><span class='line'><span class="nv">$ </span>customer-a-arista <span class="o">[</span>ENTER<span class="o">]</span>
</span><span class='line'>Last login: Thu May <span class="m">11</span> 15:28:03 <span class="m">2017</span> from 10.1.2.3
</span><span class='line'>arista-1&gt;
</span></code></pre></td></tr></table></div></figure>


<p>An so on and so forth&hellip;</p>

<p><img class="center" src="http://networkop.github.io/images/tmux.gif"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using YANG Models in Ansible to Configure and Verify State of IOS-XE and JUNOS Devices]]></title>
    <link href="http://networkop.github.io/blog/2017/04/04/ansible-yang/"/>
    <updated>2017-04-04T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2017/04/04/ansible-yang</id>
    <content type="html"><![CDATA[<p>In this post I will show how to use IETF, OpenConfig and vendor-specific YANG models in Ansible to configure BGP peering and verify state of physical interfaces between IOS-XE and JUNOS devices.</p>

<!--more-->


<p>The idea of using Ansible for <a href="http://networkop.co.uk/blog/2015/08/26/automating-network-build-p1/">configuration changes</a> and <a href="https://github.com/networktocode/ntc-ansible">state verification</a> is not new. However the approach I&rsquo;m going to demonstrate in this post, using YANG and NETCONF, will have a few notable differences:</p>

<ol>
<li>I will not use any templates and absolutely no XML/JSON for device config generation</li>
<li>All changes will be pushed through a single, vendor and model-independent Ansible module</li>
<li>State verification will be done with no pattern-matching or screen-scraping</li>
<li>All configuration and operational state will be based on a couple of YAML files</li>
<li>To demonstrate the model-agnostic behaviour I will use a mixture of vendor&rsquo;s native, IETF and OpenConfig YANG models</li>
</ol>


<p>I hope this promise is exciting enough so without further ado, let&rsquo;s get cracking.</p>

<h2>Environment setup</h2>

<p>The test environment will consist of a single instance of CSR1000v running IOS-XE version 16.4.1 and a single instance of vMX running JUNOS version 17.1R1.8. The VMs containing the two devices are deployed within a single hypervisor and connected with one interface to the management network and back-to-back with the second  pair of interfaces for BGP peering.</p>

<p><img class="center" src="http://networkop.github.io/images/ansible-yang.png"></p>

<p>Each device contains some basic initial configuration to allow it be reachable from the Ansible server.</p>

<figure class='code'><figcaption><span>IOS-XE initial configuration</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>interface GigabitEthernet1
</span><span class='line'>ip address 192.168.145.51 255.255.255.0
</span><span class='line'>!
</span><span class='line'>netconf-yang
</span><span class='line'>netconf-yang cisco-odm polling enable
</span><span class='line'>netconf-yang cisco-odm actions parse Interfaces
</span></code></pre></td></tr></table></div></figure>


<p>vMX configuration is quite similar. Static MAC address is <a href="http://noshut.ru/2015/09/how-to-run-juniper-vmx-in-unetlab/">required</a> in order for <code>ge</code> interfaces to work.</p>

<figure class='code'><figcaption><span>vMX initial configuration</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>set system login user admin class super password admin123
</span><span class='line'>set system services netconf
</span><span class='line'>set interface fxp0 unit 0 family inet address 192.168.145.53/24
</span><span class='line'>set interface ge-0/0/0 mac 00:0c:29:fc:1a:b7
</span></code></pre></td></tr></table></div></figure>


<h2>Ansible playbook configuration</h2>

<p>My <a href="https://github.com/networkop/yang/tree/master/ansible-101">Ansible-101</a> repository contains two plays - one for configuration and one for state verification. The local inventory file contains details about the two devices along with the login credentials. All the work will be performed by a custom Ansible module stored in the <code>./library</code> directory. This module is a wrapper for a <code>ydk_yaml</code> module described in my <a href="http://networkop.github.io/blog/2017/03/13/yaml-yang/">previous post</a>. I had to heavily modify the original <code>ydk_yaml</code> module to work around some Ansible limitations, like the lack of support for <strong>set</strong> data structures.<br/>
This custom Ansible module also relies on a number of <a href="http://networkop.github.io/blog/2017/02/22/odl-ydk/">YDK</a> Python bindings to be pre-installed. Refer to my <a href="https://github.com/networkop/yang/tree/master/yaml-101">YAML</a>, <a href="https://github.com/networkop/yang/tree/master/oper-101">Operational</a> and <a href="https://github.com/networkop/yang/tree/master/junos-101">JUNOS</a> repositories for the instructions on how to install those modules.<br/>
The desired configuration and expected operational state are documented inside a couple of device-specific host variable files. For each device there is a configuration file <code>config.yaml</code>, describing the desired configuration state. For IOS-XE there is an additional file <code>verify.yaml</code>, describing the expected operational state using the IETF interface YANG model (I couldn&rsquo;t find how to get the IETF or OpenConfig state models to work on Juniper). <br/>
All of these files follow the same structure:</p>

<ul>
<li>Root container can be either <code>config</code> or <code>verify</code> and defines how the enclosed data is supposed to be used</li>
<li>First nested container has to match the top-most container of a YANG model. For example it could be <strong>bgp-state</strong> for <a href="https://github.com/YangModels/yang/blob/master/vendor/cisco/xe/1641/cisco-bgp-state.yang">cisco-bgp-state.yang</a> or <strong>openconfig-bgp</strong> for <a href="https://github.com/openconfig/public/blob/master/release/models/bgp/openconfig-bgp.yang">openconfig-bgp.yang</a> model</li>
<li>The remaining nested data has to follow the structure of the original YANG model as described in my <a href="http://networkop.github.io/blog/2017/03/13/yaml-yang/">previous post</a>.</li>
</ul>


<p>Here&rsquo;s how IOS-XE will be configured, using IETF interfaca YANG models (to unshut the interface) and Cisco&rsquo;s native YANG model for interface IP and BGP settings:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="nn">---</span>
</span><span class='line'><span class="l-Scalar-Plain">config</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">interfaces</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">interface</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">GigabitEthernet3</span>
</span><span class='line'>        <span class="l-Scalar-Plain">enabled</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</span><span class='line'>  <span class="l-Scalar-Plain">native</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">interface</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">gigabitethernet</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="s">&#39;3&#39;</span>
</span><span class='line'>          <span class="l-Scalar-Plain">description</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">P2P link</span>
</span><span class='line'>          <span class="l-Scalar-Plain">ip</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="l-Scalar-Plain">address</span><span class="p-Indicator">:</span>
</span><span class='line'>              <span class="l-Scalar-Plain">primary</span><span class="p-Indicator">:</span>
</span><span class='line'>                <span class="l-Scalar-Plain">address</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">12.12.12.1</span>
</span><span class='line'>                <span class="l-Scalar-Plain">mask</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">255.255.255.0</span>
</span><span class='line'>      <span class="l-Scalar-Plain">loopback</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">0</span>
</span><span class='line'>          <span class="l-Scalar-Plain">description</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">ROUTER ID</span>
</span><span class='line'>          <span class="l-Scalar-Plain">ip</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="l-Scalar-Plain">address</span><span class="p-Indicator">:</span>
</span><span class='line'>              <span class="l-Scalar-Plain">primary</span><span class="p-Indicator">:</span>
</span><span class='line'>                <span class="l-Scalar-Plain">address</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">1.1.1.1</span>
</span><span class='line'>                <span class="l-Scalar-Plain">mask</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">255.255.255.255</span>
</span><span class='line'>    <span class="l-Scalar-Plain">router</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">bgp</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">id</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">65111</span>
</span><span class='line'>          <span class="l-Scalar-Plain">bgp</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="l-Scalar-Plain">router_id</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">1.1.1.1</span>
</span><span class='line'>          <span class="l-Scalar-Plain">neighbor</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">id</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">12.12.12.2</span>
</span><span class='line'>              <span class="l-Scalar-Plain">remote_as</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">65222</span>
</span><span class='line'>          <span class="l-Scalar-Plain">redistribute</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="l-Scalar-Plain">connected</span><span class="p-Indicator">:</span>
</span><span class='line'>              <span class="l-Scalar-Plain">empty</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">empty</span>
</span></code></pre></td></tr></table></div></figure>


<p>For JUNOS configuration, instead of the default humongous native model, I&rsquo;ll use a set of much more light-weight OpenConfig YANG models to configure interfaces, BGP and redistribution policies:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="nn">---</span>
</span><span class='line'><span class="l-Scalar-Plain">config</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">openconfig-interfaces</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">interface</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">ge-0/0/0</span>
</span><span class='line'>        <span class="l-Scalar-Plain">subinterfaces</span><span class="p-Indicator">:</span>
</span><span class='line'>          <span class="l-Scalar-Plain">subinterface</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">index</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">0</span>
</span><span class='line'>              <span class="l-Scalar-Plain">ipv4</span><span class="p-Indicator">:</span>
</span><span class='line'>                <span class="l-Scalar-Plain">addresses</span><span class="p-Indicator">:</span>
</span><span class='line'>                  <span class="l-Scalar-Plain">address</span><span class="p-Indicator">:</span>
</span><span class='line'>                    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">ip</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">12.12.12.2/24</span>
</span><span class='line'>                      <span class="l-Scalar-Plain">config</span><span class="p-Indicator">:</span>
</span><span class='line'>                        <span class="l-Scalar-Plain">ip</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">12.12.2.2</span>
</span><span class='line'>                        <span class="l-Scalar-Plain">prefix_length</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">24</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">lo0</span>
</span><span class='line'>        <span class="l-Scalar-Plain">subinterfaces</span><span class="p-Indicator">:</span>
</span><span class='line'>          <span class="l-Scalar-Plain">subinterface</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">index</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">0</span>
</span><span class='line'>              <span class="l-Scalar-Plain">ipv4</span><span class="p-Indicator">:</span>
</span><span class='line'>                <span class="l-Scalar-Plain">addresses</span><span class="p-Indicator">:</span>
</span><span class='line'>                  <span class="l-Scalar-Plain">address</span><span class="p-Indicator">:</span>
</span><span class='line'>                    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">ip</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">2.2.2.2/32</span>
</span><span class='line'>                      <span class="l-Scalar-Plain">config</span><span class="p-Indicator">:</span>
</span><span class='line'>                        <span class="l-Scalar-Plain">ip</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">2.2.2.2</span>
</span><span class='line'>                        <span class="l-Scalar-Plain">prefix_length</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">32</span>
</span><span class='line'>  <span class="l-Scalar-Plain">openconfig-policy</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">policy_definitions</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">policy_definition</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">CONNECTED-&gt;BGP</span>
</span><span class='line'>          <span class="l-Scalar-Plain">statements</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="l-Scalar-Plain">statement</span><span class="p-Indicator">:</span>
</span><span class='line'>              <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Loopback0</span>
</span><span class='line'>                <span class="l-Scalar-Plain">conditions</span><span class="p-Indicator">:</span>
</span><span class='line'>                  <span class="l-Scalar-Plain">match_interface</span><span class="p-Indicator">:</span>
</span><span class='line'>                    <span class="l-Scalar-Plain">config</span><span class="p-Indicator">:</span>
</span><span class='line'>                      <span class="l-Scalar-Plain">interface</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">lo0</span>
</span><span class='line'>                      <span class="l-Scalar-Plain">subinterface</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">0</span>
</span><span class='line'>                <span class="l-Scalar-Plain">actions</span><span class="p-Indicator">:</span>
</span><span class='line'>                  <span class="l-Scalar-Plain">config</span><span class="p-Indicator">:</span>
</span><span class='line'>                    <span class="l-Scalar-Plain">accept_route</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">empty</span>
</span><span class='line'>  <span class="l-Scalar-Plain">openconfig-bgp</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">global_</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">config</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="l-Scalar-Plain">as_</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">65222</span>
</span><span class='line'>    <span class="l-Scalar-Plain">neighbors</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">neighbor</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">neighbor_address</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">12.12.12.1</span>
</span><span class='line'>          <span class="l-Scalar-Plain">config</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="l-Scalar-Plain">peer_group</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">YANG</span>
</span><span class='line'>            <span class="l-Scalar-Plain">peer_as</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">65111</span>
</span><span class='line'>    <span class="l-Scalar-Plain">peer_groups</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="l-Scalar-Plain">peer_group</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">peer_group_name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">YANG</span>
</span><span class='line'>          <span class="l-Scalar-Plain">config</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="l-Scalar-Plain">peer_as</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">65111</span>
</span><span class='line'>          <span class="l-Scalar-Plain">apply_policy</span><span class="p-Indicator">:</span>
</span><span class='line'>            <span class="l-Scalar-Plain">config</span><span class="p-Indicator">:</span>
</span><span class='line'>              <span class="l-Scalar-Plain">export_policy</span><span class="p-Indicator">:</span>
</span><span class='line'>                <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">CONNECTED-&gt;BGP</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Configuration</h2>

<p>Both devices now can be configured with just a single command:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ansible-playbook config.yaml
</span></code></pre></td></tr></table></div></figure>


<p>Behind the scenes, Ansible calls my custom <code>ydk_module</code> and passes to it the full configuration state and device credentials. This module then constructs an empty YDK binding based on the name of a YANG model and <a href="http://networkop.github.io/blog/2017/03/13/yaml-yang/">populates it recursively</a> with the data from the <code>config</code> container. Finally, it pushes the data to the device with the help of YDK NETCONF service provider.</p>

<h2>Verification</h2>

<p>There&rsquo;s one side to YANG which I have carefully avoided until now and it&rsquo;s operational state models. These YANG models are built similarly to configuration models, but with a different goal - to extract the running state from a device. The reason why I&rsquo;ve avoided them is that, unlike the configuration models, the current support for state models is limited and somewhat brittle.<br/>
For example, JUNOS natively only supports state models as RPCs, where each RPC represents a certain <code>show</code> command which, I assume, when passed to the devices gets evaluated, its output parsed and result returned back to the client. With IOX-XE things are a little better with a few of the operational models available in the current 16.4 release. You can check out my <a href="https://github.com/networkop/yang/tree/master/oper-101">Github repo</a> for some examples of how to check the interface and BGP neighbor state between the two IOS-XE devices. However, most of the models are still missing (I&rsquo;m not counting the MIB-mapped YANG models) in the current release. The next few releases, though, are promised to come with an improved state model support, including some OpenConfig models, which is going to be super cool.<br/>
So in this post, since I couldn&rsquo;t get JUNOS OpenConfig models report any state and my IOS-XE BGP state model wouldn&rsquo;t return any output unless the BGP peering was with another Cisco device or in the <strong>Idle</strong> state, I&rsquo;m going to have to resort to simply checking the state of physical interfaces. This is how a sample operational state file would look like (question marks are YAML&rsquo;s special notation for sets which is how I decided to encode Enum data type):</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="nn">---</span>
</span><span class='line'><span class="l-Scalar-Plain">verify</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">interfaces-state</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="l-Scalar-Plain">interface</span><span class="p-Indicator">:</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">GigabitEthernet3</span>
</span><span class='line'>        <span class="l-Scalar-Plain">oper_status</span><span class="p-Indicator">:</span>
</span><span class='line'>          <span class="p-Indicator">?</span> <span class="l-Scalar-Plain">up</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">Loopback0</span>
</span><span class='line'>        <span class="l-Scalar-Plain">oper_status</span><span class="p-Indicator">:</span>
</span><span class='line'>          <span class="p-Indicator">?</span> <span class="l-Scalar-Plain">up</span>
</span><span class='line'>      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">name</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">GigabitEthernet2</span>
</span><span class='line'>        <span class="l-Scalar-Plain">oper_status</span><span class="p-Indicator">:</span>
</span><span class='line'>          <span class="p-Indicator">?</span> <span class="l-Scalar-Plain">down</span>
</span></code></pre></td></tr></table></div></figure>


<p>Once again, all expected state can be verified with a single command:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ansible-playbook verify.yaml
</span></code></pre></td></tr></table></div></figure>


<p>If the state defined in that YAML file matches the data returned by the IOS-XE device, the playbook completes successfully. You can check that it works by shutting down one of the <code>GigabitEthernet3</code> or <code>Loopback0</code> interfaces and observing how Ansible module returns an error.</p>

<h2>Outro</h2>

<p>Now that I&rsquo;ve come to the end of my YANG series of posts I feel like I need to provide some concise and critical summary of everything I&rsquo;ve been through. However, if there&rsquo;s one thing I&rsquo;ve learned in the last couple of months about YANG, it&rsquo;s that things are changing very rapidly. Both Cisco and Juniper are working hard introducing new models and improving support for the existing ones. So one thing to keep in mind, if you&rsquo;re reading this post a few months after it was published (April 2017), is that some or most of the above limitations may not exist and it&rsquo;s always worth checking what the latest software release has to offer.</p>

<p>Finally, I wanted to say that I&rsquo;m a strong believer that YANG models are the way forward for network device configuration and state verification, despite the timid scepticism of the networking industry. I think that there are two things that may improve the industry&rsquo;s perception of YANG and help increase its adoption:</p>

<ol>
<li><p>Support from networking vendors - we&rsquo;ve already seen Cisco changing by introducing YANG support on IOS-XE instead of producing another dubious One-PK clone. So big thanks to them and I hope that other vendors will follow suit.</p></li>
<li><p>Tools - this part, IMHO, is the most crucial. In order for people to start using YANG models we have to have the right tools that would be versatile enough to allow network engineers to be limited only by their imagination and at the same time be as robust as the CLI. So I wanted to give a big shout out to all the people contributing to open-source projects like <strong>pyang</strong>, <strong>YDK</strong> and many others that I have missed or don&rsquo;t know about. You&rsquo;re doing a great job guys, don&rsquo;s stop.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Configuring Cisco IOS XE With YANG-based YAML Files]]></title>
    <link href="http://networkop.github.io/blog/2017/03/13/yaml-yang/"/>
    <updated>2017-03-13T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2017/03/13/yaml-yang</id>
    <content type="html"><![CDATA[<p>One thing that puts a lot of network engineers off NETCONF and YANG is the complexity of the device configuration process. Even the simplest change involves multiple tools and requires some knowledge of XML. In this post I will show how to use simple, human-readable YAML configuration files to instantiate YANG models and push them down to network devices using a single command.</p>

<!--more-->


<hr />

<p>XML, just like many more structured data formats, was not designed to be human-friendly. That&rsquo;s why many network engineers lose interest in YANG as soon as the conversation gets to the XML part. JSON is a much more human-readable alternative, however very few devices support RESTCONF, and the ones that do may have <a href="https://github.com/CiscoDevNet/openconfig-getting-started/issues/4">buggy implementations</a>. At the same time, a lot of network engineers have happily embraced Ansible, which extensively uses YAML. That&rsquo;s why I&rsquo;ve decided to write a Python module that would program network devices using YANG and NETCONF according to configuration data described in a YAML format.</p>

<p>In the <a href="blog/2017/02/22/odl-ydk/">previous post</a> I have introduced a new open-source tool called YDK, designed to create API bindings for YANG models and interact with network devices using NETCONF or RESTCONF protocols. I have also mentioned that I would still prefer to use <a href="https://github.com/robshakir/pyangbind">pyangbind</a> along with other open-source tools to achieve the same functionality. Now, two weeks later, I must admin I have been converted. Initially, I was planning to write a simple REST API client to interact with RESTCONF interface of IOS XE, create an API binding with <strong>pyangbind</strong>, use it to produce the JSON output, convert it to XML and send it to the device, similar to what I&rsquo;ve described in my <a href="http://networkop.github.io/blog/2017/01/25/netconf-intro/">netconf</a> and <a href="blog/2017/02/15/restconf-yang/">restconf</a> posts. However, I&rsquo;ve realised that YDK can already do all what I need with just a few function calls. All what I&rsquo;ve got left to do is create a wrapper module to consume the YAML data and use it to automatically populate YDK bindings.</p>

<p>This post will be mostly about the internal structure of this wrapper module I call <code>ydk_yaml.py</code>, which will serve as a base library for a YANG Ansible module, which I will describe in my next post. This post will be very programming-oriented, I&rsquo;ll start with a quick overview of some of the programming concepts being used by the module and then move on to the details of module implementation. Those who are not interested in technical details can jump straight to the <strong>examples</strong> sections at the end of this post for a quick demonstration of how it works.</p>

<h2>Recursion</h2>

<p>One of the main tasks of <code>ydk_yaml.py</code> module is to be able parse a YAML data structure. This data structure, when loaded into Python, is stored as a collection of Python objects like dictionaries, lists and primitive data types like strings, integers and booleans. One key property of YAML data structures is that they can be represented as trees and parsing trees is a very well-known programming problem.</p>

<p>After having completed <a href="https://www.coursera.org/learn/programming-languages">this programming course</a> I fell in love with functional programming and recursions. Every problem I see, I try to solve with a recursive function. Recursions are very interesting in a way that they are very difficult to understand but relatively easy to write. Any recursive function will consist of a number of <code>if/then/else</code> conditional statements. The first one (or few) <code>if</code> statements are called the base of a recursion - this is where recursion stops and the value is returned to the outer function. The remaining few <code>if</code> statements will implement the recursion by calling the same function with a <strong>reduced input</strong>. You can find a much better explanation of recursive functions <a href="http://composingprograms.com/pages/17-recursive-functions.html">here</a>. For now, let&rsquo;s consider the problem of parsing the following tree-like data structure:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="p">{</span> <span class="s">&#39;parent&#39;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="s">&#39;child_1&#39;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>      <span class="s">&#39;leaf_1&#39;</span><span class="p">:</span> <span class="s">&#39;value_1&#39;</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="s">&#39;child_1&#39;</span><span class="p">:</span> <span class="s">&#39;value_2&#39;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Recursive function to parse this data structure written in a pseudo-language will look something like this:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">recursion</span><span class="p">(</span><span class="n">input_key</span><span class="p">,</span> <span class="n">input_value</span><span class="p">):</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">input_value</span> <span class="ow">is</span> <span class="n">String</span><span class="p">:</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">input_value</span><span class="p">)</span>
</span><span class='line'>  <span class="k">elif</span> <span class="n">input_value</span> <span class="ow">is</span> <span class="n">Dictonary</span><span class="p">:</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">input_value</span><span class="o">.</span><span class="n">keys_and_values</span><span class="p">():</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">recursion</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The beauty of recursive functions is that they are capable parsing data structures of arbitrary complexity. That means if we had 1000 randomly nested child elements in the parent data structure, they all could have been parsed by the same 6-line function.</p>

<h2>Introspection</h2>

<p><a href="http://zetcode.com/lang/python/introspection/">Introspection</a> refers to the ability of Python to examine objects at runtime. It can be useful when dealing with object of arbitrary structure, e.g. a YAML document. Introspection is used whenever there is a need for a function to behave differently based on the runtime data. In the above pseudo-language example, the two conditional statements are the examples of introspection. Whenever we need to determine the type of an object in Python we can either use a built-in function <code>type(obj)</code> which returns the type of an object or <code>isinstance(obj, type)</code> which checks if the <strong>object</strong> is an <em>instance</em> or a <em>descendant</em> of a particular <strong>type</strong>. This is how we can re-write the above two conditional statements using real Python:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
</span><span class='line'>  <span class="k">print</span><span class="p">(</span><span class="s">&#39;input value is a string&#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
</span><span class='line'>  <span class="k">print</span><span class="p">(</span><span class="s">&#39;intput value is a dictionary&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Metaprogramming</h2>

<p>Another programming concept used in my Python module is <a href="http://chase-seibert.github.io/blog/2013/04/12/getattr-setattr.html">metaprogramming</a>. Metaprogramming, in general, refers to an ability of programs to write themselves. This is what compilers normally do when they read the program written in a higher-level language and translate it to a lower-level language, like assembler. What I&rsquo;ve used in my module is the simplest version of metaprogramming - dynamic getting and setting of object attributes. For example, this is how we would configure BGP using YDK Python binding, as described in my <a href="blog/2017/02/22/odl-ydk/">previous post</a>:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">bgp</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">100</span>
</span><span class='line'><span class="n">n</span> <span class="o">=</span> <span class="n">bgp</span><span class="o">.</span><span class="n">Neighbor</span><span class="p">()</span>
</span><span class='line'><span class="n">n</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&#39;2.2.2.2&#39;</span>
</span><span class='line'><span class="n">n</span><span class="o">.</span><span class="n">remote_as</span> <span class="o">=</span> <span class="mi">65100</span>
</span><span class='line'><span class="n">bgp</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The same code could be re-written using the <code>getattr</code> and <code>setattr</code> method calls:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="nb">setattr</span><span class="p">(</span><span class="n">bgp</span><span class="p">,</span> <span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</span><span class='line'><span class="n">n</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">bgp</span><span class="p">,</span> <span class="s">&#39;Neighbor&#39;</span><span class="p">)()</span>
</span><span class='line'><span class="nb">setattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="s">&#39;2.2.2.2&#39;</span><span class="p">)</span>
</span><span class='line'><span class="nb">setattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;remote_as&#39;</span><span class="p">,</span> <span class="mi">65100</span><span class="p">)</span>
</span><span class='line'><span class="nb">getattr</span><span class="p">(</span><span class="n">bgp</span><span class="p">,</span> <span class="s">&#39;neighbor&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is also very useful when working with arbitrary data structures and objects. In my case the goal was to write a module that would be completely independent of the structure of a particular YANG model, which means that I can <strong>not know</strong> the structure of the Python binding generated by YDK. However, I can &ldquo;guess&rdquo; the name of the attributes if I assume that my YAML document is structured <strong>exactly</strong> like the YANG model. This simple assumption allows me to implement YAML mapping for <strong>all</strong> possible YANG models with just a single function.</p>

<h2>YANG mapping to YAML</h2>

<p>As I&rsquo;ve mentioned in my <a href="http://networkop.github.io/blog/2017/01/25/netconf-intro/">previous post</a>, YANG is simply a way to define the structure of an XML document. At the same time, it is known that YANG-based XML can be mapped to JSON as described in <a href="https://tools.ietf.org/html/draft-ietf-netmod-yang-json-10">this RFC</a>. Since YAML is a superset of JSON, it&rsquo;s easy to come up with a similar XML-to-YAML mapping convention. The following table contains the mapping between some of the most common YAML and YANG data structures and types:</p>

<table>
<thead>
<tr>
<th> YANG data </th>
<th> YAML representation</th>
</tr>
</thead>
<tbody>
<tr>
<td> container </td>
<td> dictionary </td>
</tr>
<tr>
<td> container name </td>
<td> dictionary key </td>
</tr>
<tr>
<td> leaf name </td>
<td> dictionary key </td>
</tr>
<tr>
<td> leaf </td>
<td> dictionary value </td>
</tr>
<tr>
<td> list </td>
<td> list </td>
</tr>
<tr>
<td> string, bool, integer </td>
<td> string, bool, integer </td>
</tr>
<tr>
<td> empty </td>
<td> null </td>
</tr>
</tbody>
</table>


<p>Using this table, it&rsquo;s easy to map the YANG data model to a YAML document. Let me demonstrate it on IOS XE&rsquo;s native OSPF data model. First, I&rsquo;ve generated a tree representation of an OSPF data model using <strong>pyang</strong>:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>pyang -f tree --tree-path <span class="s2">&quot;/native/router/ospf&quot;</span> ~/ydk-gen/gen-api/.cache/models/cisco_ios_xe@0.1.0/ned.yang -o ospf.tree
</span></code></pre></td></tr></table></div></figure>


<p>Next, I&rsquo;ve trimmed it down to only contain the options that I would like to set and created a YAML document based on the model&rsquo;s tree structure:</p>

<p><img class="center" src="http://networkop.github.io/images/yang-yaml.png"></p>

<p>With the right knowledge of <a href="blog/2017/02/15/restconf-yang/">YANG model&rsquo;s structure</a>, it&rsquo;s fairly easy to generate similar YAML configuration files for other configuration objects, like <a href="https://github.com/networkop/yang/blob/master/yaml-101/interface.yaml">interface</a> and <a href="https://github.com/networkop/yang/blob/master/yaml-101/bgp.yaml">BGP</a>.</p>

<h2>YANG instantiating function</h2>

<p>At the heart of the <code>ydk_yaml</code> module is a single recursive function that traverses the input YAML data structure and uses it to instantiate the YDK-generated Python binding. Here is a simple, abridged version of the function that demonstrates the main logic.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">instantiate</span><span class="p">(</span><span class="n">binding</span><span class="p">,</span> <span class="n">model_key</span><span class="p">,</span> <span class="n">model_value</span><span class="p">):</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">model_value</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
</span><span class='line'>        <span class="nb">setattr</span><span class="p">(</span><span class="n">binding</span><span class="p">,</span> <span class="n">model_key</span><span class="p">,</span> <span class="n">model_value</span><span class="p">)</span>
</span><span class='line'>    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">model_value</span><span class="p">:</span>
</span><span class='line'>            <span class="nb">getattr</span><span class="p">(</span><span class="n">binding</span><span class="p">,</span> <span class="n">model_key</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instantiate</span><span class="p">(</span><span class="n">binding</span><span class="p">,</span> <span class="n">model_key</span><span class="p">,</span> <span class="n">el</span><span class="p">))</span>
</span><span class='line'>    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
</span><span class='line'>        <span class="n">container_instance</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">binding</span><span class="p">,</span> <span class="n">model_key</span><span class="p">)()</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">model_value</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
</span><span class='line'>            <span class="n">instantiate</span><span class="p">(</span><span class="n">container_instance</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="nb">setattr</span><span class="p">(</span><span class="n">binding</span><span class="p">,</span> <span class="n">model_key</span><span class="p">,</span> <span class="n">container_instance</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Most of it should already make sense based on what I&rsquo;ve covered above. The first conditional statement is the base of the recursion and performs the action of setting the value of a YANG Leaf element. The second conditional statement takes care of a YANG List by traversing all its elements, instantiating them recursively, and appends the result to a YDK binding. The last <code>elif</code> statement creates a class instance for a YANG container, recursively populates its values and saves the final result inside a YDK binding.</p>

<p>The full version of this function covers a few extra corner cases and can be found <a href="https://github.com/networkop/yang/blob/master/yaml-101/ydk_yaml.py">here</a>.</p>

<h2>The YDK module wrapper</h2>

<p>The final step is to write a wrapper class that would consume the YDK model binding along with the YAML data, and both instantiate and push the configuration down to the network device.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">YdkModel</span><span class="p">:</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
</span><span class='line'>        <span class="kn">from</span> <span class="nn">ydk.models.cisco_ios_xe.ned</span> <span class="kn">import</span> <span class="n">Native</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">binding</span> <span class="o">=</span> <span class="n">Native</span><span class="p">()</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
</span><span class='line'>            <span class="n">instantiate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binding</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crud_action</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
</span><span class='line'>        <span class="kn">from</span> <span class="nn">ydk.services</span> <span class="kn">import</span> <span class="n">CRUDService</span>
</span><span class='line'>        <span class="kn">from</span> <span class="nn">ydk.providers</span> <span class="kn">import</span> <span class="n">NetconfServiceProvider</span>
</span><span class='line'>        <span class="n">provider</span> <span class="o">=</span> <span class="n">NetconfServiceProvider</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="n">device</span><span class="p">[</span><span class="s">&#39;hostname&#39;</span><span class="p">],</span>
</span><span class='line'>                                          <span class="n">port</span><span class="o">=</span><span class="n">device</span><span class="p">[</span><span class="s">&#39;port&#39;</span><span class="p">],</span>
</span><span class='line'>                                          <span class="n">username</span><span class="o">=</span><span class="n">device</span><span class="p">[</span><span class="s">&#39;username&#39;</span><span class="p">],</span>
</span><span class='line'>                                          <span class="n">password</span><span class="o">=</span><span class="n">device</span><span class="p">[</span><span class="s">&#39;password&#39;</span><span class="p">],</span>
</span><span class='line'>                                          <span class="n">protocol</span><span class="o">=</span><span class="s">&#39;ssh&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">crud</span> <span class="o">=</span> <span class="n">CRUDService</span><span class="p">()</span>
</span><span class='line'>        <span class="n">crud_instance</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">crud</span><span class="p">,</span> <span class="n">crud_action</span><span class="p">)</span>
</span><span class='line'>        <span class="n">crud_instance</span><span class="p">(</span><span class="n">provider</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">binding</span><span class="p">)</span>
</span><span class='line'>        <span class="n">provider</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span><span class='line'>        <span class="k">return</span>
</span></code></pre></td></tr></table></div></figure>


<p>The structure of this class is pretty simple. The constructor instantiates a YDK native data model and calls the recursive instantiation function to populate the binding. The <strong>action</strong> method implements standard CRUD actions using the YDK&rsquo;s NETCONF provider. The full version of this Python module can be found <a href="https://github.com/networkop/yang/blob/master/yaml-101/ydk_yaml.py">here</a>.</p>

<h2>Configuration examples</h2>

<p>In my <a href="https://github.com/networkop/yang/tree/master/yaml-101">Github repo</a>, I&rsquo;ve included a few examples of how to configure Interface, OSPF and BGP settings of IOS XE device. A helper Python script <code>1_send_yaml.py</code> accepts the YANG model name and the name of the YAML configuration file as the input. It then instantiates the <code>YdkModel</code> class and calls the <code>create</code> action to push the configuration to the device. Let&rsquo;s assume that we have the following YAML configuration data saved in a <code>bgp.yaml</code> file:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="nn">---</span>
</span><span class='line'><span class="l-Scalar-Plain">router</span><span class="p-Indicator">:</span>
</span><span class='line'>  <span class="l-Scalar-Plain">bgp</span><span class="p-Indicator">:</span>
</span><span class='line'>    <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">id</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">100</span>
</span><span class='line'>      <span class="l-Scalar-Plain">bgp</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="l-Scalar-Plain">router_id</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">1.1.1.1</span>
</span><span class='line'>        <span class="l-Scalar-Plain">fast_external_fallover</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">null</span>
</span><span class='line'>        <span class="l-Scalar-Plain">update_delay</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">15</span>
</span><span class='line'>      <span class="l-Scalar-Plain">neighbor</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">id</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">2.2.2.2</span>
</span><span class='line'>          <span class="l-Scalar-Plain">remote_as</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">200</span>
</span><span class='line'>        <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">id</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">3.3.3.3</span>
</span><span class='line'>          <span class="l-Scalar-Plain">remote_as</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">300</span>
</span><span class='line'>      <span class="l-Scalar-Plain">redistribute</span><span class="p-Indicator">:</span>
</span><span class='line'>        <span class="l-Scalar-Plain">connected</span><span class="p-Indicator">:</span> <span class="p-Indicator">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>To push this BGP configuration to the device all what I need to do is run the following command:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>./1_send_yaml.py bgp bgp.yaml
</span></code></pre></td></tr></table></div></figure>


<p>The resulting configuration on IOS XE device would look like this:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>router bgp 100
</span><span class='line'> bgp router-id 1.1.1.1
</span><span class='line'> bgp log-neighbor-changes
</span><span class='line'> bgp update-delay 15
</span><span class='line'> redistribute connected
</span><span class='line'> neighbor 2.2.2.2 remote-as 200
</span><span class='line'> neighbor 3.3.3.3 remote-as 300
</span></code></pre></td></tr></table></div></figure>


<p>To see more example, follow <a href="https://github.com/networkop/yang/tree/master/yaml-101">this link</a> to my Github repo.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Configuring Cisco IOS XE With YDK and OpenDaylight]]></title>
    <link href="http://networkop.github.io/blog/2017/02/22/odl-ydk/"/>
    <updated>2017-02-22T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2017/02/22/odl-ydk</id>
    <content type="html"><![CDATA[<p>Now it&rsquo;s time to turn our gaze to the godfather of YANG models and one of the most famous open-source SDN controllers, OpenDaylight. In this post I&rsquo;ll show how to connect Cisco IOS XE device to ODL and use Yang Development Kit to push a simple BGP configuration through ODL&rsquo;s RESTCONF interface.</p>

<!--more-->


<hr />

<p>In the previous posts about <a href="http://networkop.github.io/blog/2017/01/25/netconf-intro/">NETCONF</a> and <a href="http://networkop.github.io/blog/2017/02/15/restconf-yang/">RESTCONF</a> I&rsquo;ve demonstrated how to interact with Cisco IOS XE device directly from the Linux shell of my development VM. This approach works fine in some cases, e.g. whenever I setup a new DC fabric, I would make calls directly to the devices I&rsquo;m configuring. However, it becomes impractical in the Ops world where change is constant and involves a large number of devices. This is where centralised service orchestrators come to the fore. The prime examples of such platforms are Network Services Orchestrator from Tail-f/Cisco and open-source project OpenDaylight. In this post we&rsquo;ll concentrate on ODL and how to make it work with Cisco IOS XE. Additionally, I&rsquo;ll show how to use an open-source tool <a href="https://developer.cisco.com/site/ydk/">YDK</a> to generate Python bindings for native YANG models and how it compares with <strong>pyangbind</strong>.</p>

<h2>OpenDaylight primer</h2>

<p>OpenDaylight is a swiss army knife of SDN controllers. At the moment it is comprised of dozens of projects implementing all possible sorts of SDN functionality starting from Openflow controller all the way up to L3VPN orchestrator. ODL speaks most of the modern Southbound protocols like Openflow, SNMP, NETCONF and BGP. The brain of the controller is in the Service Abstraction Layer, a framework to model all network-related characteristics and properties. All logic inside SAL is modelled in YANG which is why I called it the godfather of YANG models. Towards the end users ODL exposes Java function calls for applications running on the same host and REST API for application running remotely.</p>

<p><img class="center" src="http://networkop.github.io/images/odl-sal.jpg"></p>

<p>OpenDaylight has several commercial offerings from companies involved in its development. Most notable ones are from Brocade and Cisco. Here I will allow myself a bit of a rant, feel free to skip it to go straight to the technical stuff.</p>

<p>One thing I find interesting is that Cisco are being so secretive about their Open SDN Controller, perhaps due to the earlier market pressure to come up with a single SDN story, but still have a very large number of contributors to this open-source project. It could be the case of having an egg in each basket, but the number of Cisco&rsquo;s employees involved in ODL development is substantial. I wonder if, now that the use cases for ACI and ODL have finally formed and ACI still not showing the uptake originally expected, Cisco will change their strategy and start promoting ODL more aggressively, or at least stop hiding it deep in the bowels of <a href="cisco.com">cisco.com</a>. Or, perhaps, it will always stay in the shade of Tail-f&rsquo;s NSC and Insieme&rsquo;s ACI and will be used only for customer with unique requirements, e.g. to have both OpenStack and network devices managed through the same controller.</p>

<h2>Environment setup</h2>

<p>We&rsquo;ll use the same environment we&rsquo;ve setup in the <a href="http://networkop.github.io/blog/2017/01/25/netconf-intro/">previous posts</a>, consisting of a CSR1K and a Linux VM connected to the same network inside my hypervisor. IOS XE device needs to have <code>netconf-yang</code> configured in order to enable the northbound NETCONF interface.</p>

<p>On the same Linux VM, I&rsquo;ve downloaded and launched the latest version of ODL (Boron-SR2), and enabled NETCONF and RESTCONF plugins.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>unzip distribution-karaf-0.5.2-Boron-SR2.zip
</span><span class='line'>mv distribution-karaf-0.5.2-Boron-SR2 odl-0.5.2
</span><span class='line'><span class="nb">cd </span>odl-0.5.2/
</span><span class='line'>./bin/karaf
</span><span class='line'>opendaylight-user@root&gt;feature:install odl-netconf-connector-all
</span><span class='line'>opendaylight-user@root&gt;feature:install odl-restconf-all
</span></code></pre></td></tr></table></div></figure>


<p>We&rsquo;ll use NETCONF to connect to Cisco IOS XE device and RESTCONF to interact with ODL from a Linux shell.</p>

<p><img class="center" src="http://networkop.github.io/images/odl-ydk.png"></p>

<p>It might be useful to turn on logging in karaf console to catch any errors we might encounter later:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>opendaylight-user@root&gt;log:tail
</span></code></pre></td></tr></table></div></figure>


<h2>Connecting IOS XE to ODL</h2>

<p>According to ODL <a href="http://docs.opendaylight.org/en/stable-boron/user-guide/netconf-user-guide.html">NETCONF</a> user guide, in order to connect a new device to the controller, we need to create an XML document which will include the IP, port and user credentials of the IOS XE device. Here&rsquo;s the excerpt from the <a href="https://github.com/networkop/yang/blob/master/odl-101/new_device.xml.1">full XML document</a>:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;module</span> <span class="na">xmlns=</span><span class="s">&quot;urn:opendaylight:params:xml:ns:yang:controller:config&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;type</span> <span class="na">xmlns:prefix=</span><span class="s">&quot;urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf&quot;</span><span class="nt">&gt;</span>prefix:sal-netconf-connector<span class="nt">&lt;/type&gt;</span>
</span><span class='line'>  <span class="nt">&lt;name&gt;</span>CSR1K<span class="nt">&lt;/name&gt;</span>
</span><span class='line'>  <span class="nt">&lt;address</span> <span class="na">xmlns=</span><span class="s">&quot;urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf&quot;</span><span class="nt">&gt;</span>192.168.145.51<span class="nt">&lt;/address&gt;</span>
</span><span class='line'>  <span class="nt">&lt;port</span> <span class="na">xmlns=</span><span class="s">&quot;urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf&quot;</span><span class="nt">&gt;</span>830<span class="nt">&lt;/port&gt;</span>
</span><span class='line'>  <span class="nt">&lt;username</span> <span class="na">xmlns=</span><span class="s">&quot;urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf&quot;</span><span class="nt">&gt;</span>admin<span class="nt">&lt;/username&gt;</span>
</span><span class='line'>  <span class="nt">&lt;password</span> <span class="na">xmlns=</span><span class="s">&quot;urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf&quot;</span><span class="nt">&gt;</span>admin<span class="nt">&lt;/password&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Assuming this XML is saved in a file called <a href="https://github.com/networkop/yang/blob/master/odl-101/new_device.xml.1">new_device.xml.1</a>, we can use <code>curl</code> to send it to ODL&rsquo;s netconf-connector plugin:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>curl -v -k -u admin:admin -H <span class="s2">&quot;Content-Type: application/xml&quot;</span> -X POST <span class="se">\</span>
</span><span class='line'> http://localhost:8181/restconf/config/network-topology:network-topology<span class="se">\</span>
</span><span class='line'> /topology/topology-netconf/node/controller-config/yang-ext:mount/config:modules<span class="se">\</span>
</span><span class='line'>  -d @new_device.xml.1
</span></code></pre></td></tr></table></div></figure>


<p>When the controller gets this information it will try to connect to the device via NETCONF and do the following three things:</p>

<ul>
<li>Discover device capabilities advertised in the Hello message</li>
<li>Download all YANG models advertised by the device into the <code>./cache/schema</code> directory</li>
<li>Go through all of the imports in each model and verify that they can be satisfied</li>
</ul>


<p>After ODL downloads all of the 260 available models (can take up to 20 minutes) we will see the following errors in the karaf console:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Netconf device does not provide all yang models reported in hello message capabilities
</span><span class='line'>Unable to build schema context, unsatisfied imports
</span><span class='line'>Initialization in sal failed, disconnecting from device
</span><span class='line'>No more sources <span class="k">for</span> schema context
</span></code></pre></td></tr></table></div></figure>


<p>Due to inconsistencies between the advertised and the available models, ODL fails to build the full device YANG schema context, which ultimately results in inability to connect the device to the controller. However, we won&rsquo;t need all of the 260 models advertised by the device. In fact, most of the configuration can be done through a single Cisco native YANG model, <code>ned</code>. With ODL it is possible to override the default capabilities advertised in the Hello message and &ldquo;pin&rdquo; only the ones that are going to be used. Assuming that ODL has downloaded most of the models at the previous step, we can simply tell it use the selected few with the following additions to the <a href="https://github.com/networkop/yang/blob/master/odl-101/new_device.xml.2">XML document</a>:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;yang-module-capabilities</span> <span class="na">xmlns=</span><span class="s">&quot;urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;override&gt;</span>true<span class="nt">&lt;/override&gt;</span>
</span><span class='line'>    <span class="nt">&lt;capability</span> <span class="na">xmlns=</span><span class="s">&quot;urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      urn:ietf:params:xml:ns:yang:ietf-inet-types?module=ietf-inet-types<span class="ni">&amp;amp;</span>revision=2013-07-15
</span><span class='line'>    <span class="nt">&lt;/capability&gt;</span>
</span><span class='line'>    <span class="nt">&lt;capability</span> <span class="na">xmlns=</span><span class="s">&quot;urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      http://cisco.com/ns/yang/ned/ios?module=ned<span class="ni">&amp;amp;</span>revision=2016-10-24
</span><span class='line'>    <span class="nt">&lt;/capability&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Assuming the updated XML is saved in <a href="https://github.com/networkop/yang/blob/master/odl-101/new_device.xml.2">new_device.xml.2</a> file, the following command will update the current configuration of <strong>CSR1K</strong> device:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>curl -v -k -u admin:admin -H <span class="s2">&quot;Content-Type: application/xml&quot;</span> -X PUT <span class="se">\</span>
</span><span class='line'>http://localhost:8181/restconf/config/network-topology:network-topology<span class="se">\</span>
</span><span class='line'>/topology/topology-netconf/node/controller-config<span class="se">\</span>
</span><span class='line'>/yang-ext:mount/config:modules/module<span class="se">\</span>
</span><span class='line'>/odl-sal-netconf-connector-cfg:sal-netconf-connector<span class="se">\</span>
</span><span class='line'>/CSR1K -d @new_device.xml.2
</span></code></pre></td></tr></table></div></figure>


<p>We can then verify that the device has been successfully mounted to the controller:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>curl -v -k -u admin:admin http://localhost:8181/restconf/operational<span class="se">\</span>
</span><span class='line'>/network-topology:network-topology/ <span class="p">|</span> python -m json.tool
</span></code></pre></td></tr></table></div></figure>


<p>The output should look similar to the following with the connection-status set to <code>connected</code> and no detected <code>unavailable-capabilities</code>:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="s2">&quot;netconf-node-topology:connection-status&quot;</span><span class="err">:</span> <span class="s2">&quot;connected&quot;</span><span class="err">,</span>
</span><span class='line'><span class="s2">&quot;netconf-node-topology:host&quot;</span><span class="err">:</span> <span class="s2">&quot;192.168.145.51&quot;</span><span class="err">,</span>
</span><span class='line'><span class="s2">&quot;netconf-node-topology:port&quot;</span><span class="err">:</span> <span class="mi">830</span><span class="err">,</span>
</span><span class='line'><span class="s2">&quot;netconf-node-topology:unavailable-capabilities&quot;</span><span class="err">:</span> <span class="p">{}</span><span class="err">,</span>
</span><span class='line'><span class="s2">&quot;node-id&quot;</span><span class="err">:</span> <span class="s2">&quot;CSR1K&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>At this point we should be able to interact with IOS XE&rsquo;s native YANG model through ODL&rsquo;s RESTCONF interface using the following URL</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> http://localhost:8181/restconf/config/network-topology:network-topology<span class="se">\</span>
</span><span class='line'> /topology/topology-netconf/node/CSR1K/yang-ext:mount/ned:native
</span></code></pre></td></tr></table></div></figure>


<p>The only thing that&rsquo;s missing is the actual configuration data. To generate it, I&rsquo;ll use a new open-source tool called YDK.</p>

<h2>YDK primer</h2>

<p>Yang Development Kit is a suite of tools to work with NETCONF/RESTCONF interfaces of a network device. The way I see it, YDK accomplishes two things:</p>

<ul>
<li>Generates API bindings for programming languages (Python and C++) from YANG models</li>
<li>Creates an abstraction layer to interact with southbound protocols (NETCONF or RESTCONF) in a uniform way</li>
</ul>


<p>There&rsquo;s a lot of overlap between the tools that we&rsquo;ve used <a href="http://networkop.github.io/blog/2017/02/15/restconf-yang/">before</a> and YDK. Effectively YDK combines in itself the functions of a NETCONF client, a REST client, pyangbind and pyang(the latter is used internally for model verification). Since one of the main functions of YDK is API generation I thought it&rsquo;d be interesting to know how it compares to Rob Shakir&rsquo;s <strong>pyangbind</strong> plugin. The following information is what I&rsquo;ve managed to find on the Internet and from the comment of Santiago Alvarez below:</p>

<table>
<thead>
<tr>
<th> Feature </th>
<th> Pyangbind </th>
<th> YDK </th>
</tr>
</thead>
<tbody>
<tr>
<td> PL support </td>
<td> Python </td>
<td> Python, C++ with Ruby and Go in the pipeline </td>
</tr>
<tr>
<td> Serialization </td>
<td> JSON, XML </td>
<td> only XML <a href="https://github.com/CiscoDevNet/ydk-gen/blob/master/sdk/python/core/ydk/providers/codec_provider.py#L53">at this stage</a> with JSON coming up in a few weeks </td>
</tr>
<tr>
<td> Southbound interfaces   </td>
<td> N/A </td>
<td> NETCONF, RESTCONF with ODL coming up in a few weeks </td>
</tr>
<tr>
<td> Support </td>
<td> Cisco&rsquo;s devnet team </td>
<td> Rob Shakir </td>
</tr>
</tbody>
</table>


<p>So it looks like YDK is a very promising alternative to <strong>pyangbind</strong>, however I, personally, would still prefer to use <strong>pyangbind</strong> due to familiarity, simplicity and the fact that I don&rsquo;t need the above extra features offered by YDK right now. However, given that YDK has been able to achieve so much in just under one year of its existence, I don&rsquo;t discount the possibility that I may switch to YDK as it becomes more mature and feature-rich.</p>

<h2>Python binding generation with YDK-GEN</h2>

<p>One of the first things we need to do is install YDK-GEN, the tools responsible for API bindings generation, and it&rsquo;s core Python packages on the local machine. The following few commands are my version of the official <a href="https://github.com/CiscoDevNet/ydk-gen">installation procedure</a>:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git clone https://github.com/CiscoDevNet/ydk-gen.git ~/ydk-gen
</span><span class='line'>pip install -r ~/ydk-gen/requirements.txt
</span><span class='line'><span class="nb">export </span><span class="nv">YDKGEN_HOME</span><span class="o">=</span>~/ydk-gen/
</span><span class='line'>~/ydk-gen/generate.py --python --core
</span><span class='line'>pip install ~/ydk-gen/gen-api/python/ydk/dist/ydk*.tar.gz
</span></code></pre></td></tr></table></div></figure>


<p>YDK-GEN generates Python bindings based on the so-called <strong>bundle profile</strong>. This is a simple JSON document which lists all YANG models to include in the output package. In our case we&rsquo;d need to include a <code>ned</code> model along with all its imports. The sample below shows only the model specification. Refer to my <a href="https://github.com/networkop/yang/blob/master/odl-101/cisco-ios-xe_0_1_0.json">Github repo</a> for a complete bundle profile for Cisco IOS XE native YANG model.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span><span class="nt">&quot;models&quot;</span><span class="p">:{</span><span class="nt">&quot;git&quot;</span><span class="p">:[{</span><span class="nt">&quot;url&quot;</span><span class="p">:</span><span class="s2">&quot;https://github.com/YangModels/yang.git&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nt">&quot;commits&quot;</span><span class="p">:[{</span><span class="nt">&quot;commitid&quot;</span><span class="p">:</span><span class="s2">&quot;6f4a025431103f8cbbf3405ce01bdc61d0811b1d&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="nt">&quot;file&quot;</span><span class="p">:[</span><span class="s2">&quot;vendor/cisco/xe/1641/ned.yang&quot;</span><span class="p">,</span>
</span><span class='line'>      <span class="s2">&quot;vendor/cisco/xe/1641/tailf-common.yang&quot;</span><span class="p">,</span>
</span><span class='line'>      <span class="s2">&quot;vendor/cisco/xe/1641/tailf-meta-extensions.yang&quot;</span><span class="p">,</span>
</span><span class='line'>      <span class="s2">&quot;vendor/cisco/xe/1641/tailf-cli-extensions.yang&quot;</span><span class="p">,</span>
</span><span class='line'>      <span class="s2">&quot;standard/ietf/RFC/ietf-inet-types.yang&quot;</span><span class="p">,</span>
</span><span class='line'>      <span class="s2">&quot;standard/ietf/RFC/ietf-yang-types.yang&quot;</span><span class="p">]</span>
</span><span class='line'>      <span class="p">}]}]}}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Assuming that the IOS XE bundle profile is saved in a file called <a href="https://github.com/networkop/yang/blob/master/odl-101/cisco-ios-xe_0_1_0.json">cisco-ios-xe_0_1_0.json</a>, we can use YDK to generate and install the Python binding package:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>~/ydk-gen/generate.py --python --bundle cisco-ios-xe_0_1_0.json -v
</span><span class='line'>pip install ~/ydk-gen/gen-api/python/cisco_ios_xe-bundle/dist/ydk*.tar.gz
</span></code></pre></td></tr></table></div></figure>


<h2>Configuring BGP with YDK</h2>

<p>Now we can start configuring BGP using our newly generated Python package. First, we need to create an instance of BGP configuration data:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">ydk.models.cisco_ios_xe.ned</span> <span class="kn">import</span> <span class="n">Native</span>
</span><span class='line'><span class="n">bgp</span> <span class="o">=</span> <span class="n">Native</span><span class="p">()</span><span class="o">.</span><span class="n">router</span><span class="o">.</span><span class="n">Bgp</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>The configuration will follow the pattern defined in the original model, which is why it&rsquo;s important to understand <a href="http://networkop.github.io/blog/2017/02/15/restconf-yang/">the internal structure</a> of a YANG model. YANG leafs are represented as simple instance attributes. All YANG containers need to be explicitly instantiated, just like the <code>Native</code> and <code>Bgp</code> classes in the example above. Presence containers (<code>router</code> in the above example) will be instantiated at the same time as its parent container, inside the <code>__init__</code> function of the <code>Native</code> class. Don&rsquo;t worry if this doesn&rsquo;t make sense, use <strong>iPython</strong> or any IDE with autocompletion and after a few tries, you&rsquo;ll get the hang of it.</p>

<p>Let&rsquo;s see how we can set the local BGP AS number and add a new BGP peer to the neighbor list.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">bgp</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">100</span>
</span><span class='line'><span class="n">new_neighbor</span> <span class="o">=</span> <span class="n">bgp</span><span class="o">.</span><span class="n">Neighbor</span><span class="p">()</span>
</span><span class='line'><span class="n">new_neighbor</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&#39;2.2.2.2&#39;</span>
</span><span class='line'><span class="n">new_neighbor</span><span class="o">.</span><span class="n">remote_as</span> <span class="o">=</span> <span class="mi">65100</span>
</span><span class='line'><span class="n">bgp</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_neighbor</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>At this point of time all data is stored inside the instance of a <code>Bgp</code> class. In order to get an XML representation of it, we need to use YDK&rsquo;s XML provider and encoding service:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">ydk.providers</span> <span class="kn">import</span> <span class="n">CodecServiceProvider</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">ydk.services</span> <span class="kn">import</span> <span class="n">CodecService</span>
</span><span class='line'><span class="n">provider</span> <span class="o">=</span> <span class="n">CodecServiceProvider</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&quot;xml&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">codec</span> <span class="o">=</span> <span class="n">CodecService</span><span class="p">()</span>
</span><span class='line'><span class="n">xml_string</span> <span class="o">=</span> <span class="n">codec</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">provider</span><span class="p">,</span> <span class="n">bgp</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">xml_string</span>
</span></code></pre></td></tr></table></div></figure>


<p>All what we&rsquo;ve got left now is to send the data to ODL:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">requests</span>
</span><span class='line'><span class="n">url</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;http://localhost:8181/restconf&quot;</span>
</span><span class='line'>       <span class="s">&quot;/config/network-topology:network-topology&quot;</span>
</span><span class='line'>       <span class="s">&quot;/topology/topology-netconf/node&quot;</span>
</span><span class='line'>       <span class="s">&quot;/CSR1K/yang-ext:mount/ned:native&quot;</span>
</span><span class='line'>       <span class="s">&quot;/router&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">headers</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;Content-Type&#39;</span><span class="p">:</span> <span class="s">&#39;application/xml&#39;</span><span class="p">}</span>
</span><span class='line'><span class="n">result</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">auth</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="s">&#39;admin&#39;</span><span class="p">),</span> <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">xml_string</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">result</span><span class="o">.</span><span class="n">status_code</span>
</span></code></pre></td></tr></table></div></figure>


<p>The controller should have returned the status code <code>204 No Content</code>, meaning that configuration has been changed successfully.</p>

<h2>Verification</h2>

<p>Back at the IOS XE CLI we can see the new BGP configuration that has been pushed down from the controller.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>TEST#sh run | i router
</span><span class='line'>router bgp 100
</span><span class='line'> bgp log-neighbor-changes
</span><span class='line'> neighbor 2.2.2.2 remote-as 65100
</span></code></pre></td></tr></table></div></figure>


<h2>More examples</h2>

<p>You can find a shorter version of the above procedure in my <a href="https://github.com/networkop/yang/tree/master/odl-101">ODL 101 repo</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to YANG Programming and RESTCONF on Cisco IOS XE]]></title>
    <link href="http://networkop.github.io/blog/2017/02/15/restconf-yang/"/>
    <updated>2017-02-15T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2017/02/15/restconf-yang</id>
    <content type="html"><![CDATA[<p>The sheer size of some of the YANG models can scare away even the bravest of network engineers. However, as it is with any programming language, the complexity is built out of a finite set of simple concepts. In this post we&rsquo;ll learn some of these concepts by building our own YANG model to program static IP routes on Cisco IOS XE.</p>

<!--more-->


<hr />

<p>  In the <a href="http://networkop.github.io/blog/2017/01/25/netconf-intro/">previous post</a> I have demonstrated how to make changes to interface configuration of Cisco IOS XE device using the standard <strong>IETF</strong> model. In this post I&rsquo;ll show how to use Cisco&rsquo;s <strong>native</strong> YANG model to modify static IP routes. To make things even more interesting I&rsquo;ll use RESTCONF, an HTTP-based sibling of NETCONF.</p>

<h2>RESTCONF primer</h2>

<p><a href="https://www.rfc-editor.org/rfc/rfc8040.txt">RESTCONF</a> is a very close functional equivalent of NETCONF. Instead of SSH, RESTCONF relies on HTTP to interact with configuration data and operational state of the network device and encodes all exchanged data in either XML or JSON. RESTCONF borrows the idea of Create-Read-Update-Delete operations on resources from <a href="http://networkop.github.io/blog/2016/01/01/rest-for-neteng/">REST</a> and maps them to YANG models and datastores. There is a direct relationship between NETCONF operations and RESTCONF HTTP verbs:</p>

<table>
<thead>
<tr>
<th> HTTP VERB </th>
<th> NETCONF OPERATION </th>
</tr>
</thead>
<tbody>
<tr>
<td> POST      </td>
<td> create            </td>
</tr>
<tr>
<td> PUT       </td>
<td> replace           </td>
</tr>
<tr>
<td> PATCH     </td>
<td> merge             </td>
</tr>
<tr>
<td> DELETE    </td>
<td> delete            </td>
</tr>
<tr>
<td> GET       </td>
<td> get/get-config    </td>
</tr>
</tbody>
</table>


<p>Both RESTfullness and the ability to encode data as JSON make RESTCONF a very attractive choice for application developers. In this post, for the sake of simplicity, we&rsquo;ll use Python CLI and <code>curl</code> to interact with RESTCONF API. In the upcoming posts I&rsquo;ll show how to implement the same functionality inside a simple Python library.</p>

<h2>Environment setup</h2>

<p>We&rsquo;ll pick up from where we left our environment in the <a href="http://networkop.github.io/blog/2017/01/25/netconf-intro/">previous post</a> right after we&rsquo;ve configured a network interface. The following IOS CLI command enables RESTCONF&rsquo;s root URL at <code>http://192.168.145.51/restconf/api/</code></p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>CSR1k(config)#restconf
</span></code></pre></td></tr></table></div></figure>


<p>You can start exploring the structure of RESTCONF interface starting at the root URL by specifying resource names separated by &ldquo;/&rdquo;. For example, the following command will return all configuration from Cisco&rsquo;s native datastore.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>curl -v -k admin:admin http://192.168.145.51/restconfi/api/config/native?deep
</span></code></pre></td></tr></table></div></figure>


<p>In order to get JSON instead of the default XML output the client should specify JSON media type <code>application/vnd.yang.datastore+json</code> and pass it in the <code>Accept</code> header.</p>

<h2>Writing a YANG model</h2>

<p><a href="http://networkop.github.io/blog/2017/01/25/netconf-intro/">Normally</a>, you would expect to download the YANG model from the device itself. However IOS XE&rsquo;s NETCONF and RESTCONF support is so new that not all of the models are available. Specifically, Cisco&rsquo;s native YANG model for static routing cannot be found in either <a href="https://github.com/YangModels">Yang Github Repo</a> or the device itself (via <code>get_schema</code> RPC), which makes it a very good candidate for this post.</p>

<blockquote><p><strong>Update 13-02-2017</strong>: As it turned out, the model was right under my nose the whole time. It&rsquo;s called <code>ned</code> and encapsulates the whole of Cisco&rsquo;s native datastore. So think of everything that&rsquo;s to follow as a simple learning exercise, however the point I raise in the closing paragraph still stands.</p></blockquote>

<p>The first thing we need to do is get an understanding of the structure and naming convention of the YANG model. The simplest way to do that would be to make a change on the CLI and observe the result via RESTCONF.</p>

<h3>Retrieving running configuration data</h3>

<p>Let&rsquo;s start by adding the following static route to the IOS XE device:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>ip route 2.2.2.2 255.255.255.255 GigabitEthernet2
</span></code></pre></td></tr></table></div></figure>


<p>Now we can view the configured static route via RESTCONF:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>curl -v -k -u admin:admin -H <span class="s2">&quot;Accept: application/vnd.yang.data+json&quot;</span> <span class="se">\</span>
</span><span class='line'> http://192.168.145.51/restconf/api/config/native/ip/route?deep
</span></code></pre></td></tr></table></div></figure>


<p>The returned output should look something like this:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span> <span class="nt">&quot;ned:route&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;ip-route-interface-forwarding-list&quot;</span><span class="p">:</span> <span class="p">[</span>
</span><span class='line'>      <span class="p">{</span> <span class="nt">&quot;prefix&quot;</span><span class="p">:</span> <span class="s2">&quot;2.2.2.2&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;mask&quot;</span><span class="p">:</span> <span class="s2">&quot;255.255.255.255&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;fwd-list&quot;</span><span class="p">:</span> <span class="p">[</span> <span class="p">{</span> <span class="nt">&quot;fwd&quot;</span><span class="p">:</span> <span class="s2">&quot;GigabitEthernet2&quot;</span> <span class="p">}</span> <span class="p">]</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">]</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This JSON object gives us a good understanding of how the YANG model should look like. The root element <code>route</code> contains a list of IP prefixes, called <code>ip-route-interface-forwarding-list</code>. Each element of this list contains values for IP network and mask as well as the list of next-hops called <code>fwd-list</code>. Let&rsquo;s see how we can map this to YANG model concepts.</p>

<h3>Building a simple YANG model</h3>

<p>YANG <a href="https://tools.ietf.org/html/rfc6020">RFC</a> defines a number of data structures to model an XML tree. Let&rsquo;s first concentrate on the three most fundamental data structures that constitute the biggest part of any YANG model:</p>

<ul>
<li><strong>Container</strong> is a node of a tree with a unique name which encloses a set of child elements. In JSON it is mapped to a name/object pair <code>'name': {...}</code></li>
<li><strong>Leaf</strong> is a node which contains a value and does not contain any child elements. In JSON leaf is mapped to a single key/value pair <code>'name': 'value'</code></li>
<li><strong>List</strong> can be thought of as a table that contains a set rows (list entries). Each list entry can contain Leafs, Containers and other elements and can be uniquely identified by at least one Leaf element called a <code>key</code>. In JSON lists are encoded as name/arrays pairs containing JSON objects <code>'name': [{...}, {...}]</code></li>
</ul>


<p>Now let&rsquo;s see how we can describe the received data in terms of the above data structures:</p>

<ul>
<li>The value of the topmost <code>route</code> element is a JSON object, therefore it can only be mapped to a YANG container.</li>
<li>The value of <code>ip-route-interface-forwarding-list</code> is an array of JSON objects, therefore it must be a list.</li>
<li>The only entry of this list contains <code>prefix</code> and <code>mask</code> key/value pairs. Since they don&rsquo;t contain any child elements and their values are strings they can only be mapped to YANG leafs.</li>
<li>The third element, <code>fwd-list</code>, is another YANG list and so far contains a single next-hop value inside a YANG leaf called <code>fwd</code>.</li>
<li>Finally, since <code>fwd</code> is the only leaf in the <code>fwd-list</code> list, it must be that lists' key. The <code>ip-route-interface-forwarding-list</code> list will have both <code>prefix</code> and <code>mask</code> as its key values since their combination represents a unique IP destination.</li>
</ul>


<p>With all that in mind, this is how a skeleton of our YANG model will look like:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="err">module</span> <span class="err">cisco-route-static</span> <span class="p">{</span>
</span><span class='line'>  <span class="err">namespace</span> <span class="nt">&quot;http://cisco.com/ns/yang/ned/ios&quot;</span><span class="err">;</span>
</span><span class='line'>  <span class="err">prefix</span> <span class="err">ned;</span>
</span><span class='line'>  <span class="err">container</span> <span class="err">route</span> <span class="p">{</span>
</span><span class='line'>    <span class="err">list</span> <span class="err">ip-route-interface-forwarding-list</span> <span class="err">{</span>
</span><span class='line'>      <span class="err">key</span> <span class="nt">&quot;prefix mask&quot;</span><span class="err">;</span>
</span><span class='line'>      <span class="err">leaf</span> <span class="err">prefix</span> <span class="p">{</span> <span class="err">type</span> <span class="err">string;</span> <span class="p">}</span>
</span><span class='line'>      <span class="err">leaf</span> <span class="err">mask</span> <span class="p">{</span> <span class="err">type</span> <span class="err">string;</span> <span class="p">}</span>
</span><span class='line'>      <span class="err">list</span> <span class="err">fwd-list</span> <span class="p">{</span>
</span><span class='line'>        <span class="err">key</span> <span class="nt">&quot;fwd&quot;</span><span class="err">;</span>
</span><span class='line'>        <span class="err">leaf</span> <span class="err">fwd</span> <span class="p">{</span> <span class="err">type</span> <span class="err">string;</span> <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="err">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>YANG&rsquo;s syntax is pretty light-weight and looks very similar to JSON. The topmost <code>module</code> defines the model&rsquo;s name and encloses all other elements. The first two statements are used to define XML namespace and prefix that I&rsquo;ve described in my <a href="http://networkop.github.io/blog/2017/01/25/netconf-intro/">previous post</a>.</p>

<h3>Refactoring a YANG model</h3>

<p>At this stage the model can already be instantiated by <strong>pyang</strong> and <strong>pyangbind</strong>, however there&rsquo;s a couple of very important changes and additions that I wanted to make to demonstrate some of the other features of YANG.</p>

<p>The first of them is common IETF data types. So far in our model we&rsquo;ve assumed that prefix and mask can take <strong>any</strong> value in string format. But what if we wanted to check that the values we use are, in fact, the correctly-formatted IPv4 addresses and netmasks before sending them to the device? That is where IETF common data types come to the rescue. All what we need to do is add an import statement to define which model to use and we can start referencing them in our type definitions:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="err">...</span>
</span><span class='line'><span class="err">import</span> <span class="err">ietf-yang-types</span> <span class="p">{</span> <span class="err">prefix</span> <span class="nt">&quot;yang&quot;</span><span class="err">;</span> <span class="p">}</span>
</span><span class='line'><span class="err">import</span> <span class="err">ietf-inet-types</span> <span class="p">{</span> <span class="err">prefix</span> <span class="nt">&quot;inet&quot;</span><span class="err">;</span> <span class="p">}</span>
</span><span class='line'><span class="err">...</span>
</span><span class='line'><span class="err">leaf</span> <span class="err">prefix</span> <span class="p">{</span> <span class="err">type</span> <span class="err">inet:ipv4-address;</span> <span class="p">}</span>
</span><span class='line'><span class="err">leaf</span> <span class="err">mask</span> <span class="p">{</span> <span class="err">type</span> <span class="err">yang:dotted-quad;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This solves the problem for the prefix part of a static route but how about its next-hop? Next-hops can be defined as either strings (representing an interface name) or IPv4 addresses. To make sure we can use either of these two types in the <code>fwd</code> leaf node we can define its type as a <code>union</code>. This built-in type is literally a union, a logical OR, of all its member elements. This is how we can change the <code>fwd</code> leaf definition:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="err">...</span>
</span><span class='line'><span class="err">typedef</span> <span class="err">ip-next-hop</span> <span class="p">{</span>
</span><span class='line'>  <span class="err">type</span> <span class="err">union</span> <span class="err">{</span>
</span><span class='line'>    <span class="err">type</span> <span class="err">inet:ipv4-address;</span>
</span><span class='line'>    <span class="err">type</span> <span class="err">string;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="err">}</span>
</span><span class='line'><span class="err">...</span>
</span><span class='line'><span class="err">leaf</span> <span class="err">fwd</span> <span class="p">{</span> <span class="err">type</span> <span class="err">ip-next-hop;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>So far we&rsquo;ve been concentrating on the simplest form of a static route, which doesn&rsquo;t include any of the optional arguments. Let&rsquo;s add the leaf nodes for name, AD, tag, track and permanent options of the static route:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="err">...</span>
</span><span class='line'><span class="err">leaf</span> <span class="err">metric</span> <span class="p">{</span> <span class="err">type</span> <span class="err">uint8;</span> <span class="p">}</span>
</span><span class='line'><span class="err">leaf</span> <span class="err">name</span> <span class="p">{</span> <span class="err">type</span> <span class="err">string;</span> <span class="p">}</span>
</span><span class='line'><span class="err">leaf</span> <span class="err">tag</span> <span class="p">{</span> <span class="err">type</span> <span class="err">uint8;</span> <span class="p">}</span>
</span><span class='line'><span class="err">leaf</span> <span class="err">track</span> <span class="p">{</span> <span class="err">type</span> <span class="err">uint8;</span> <span class="p">}</span>
</span><span class='line'><span class="err">leaf</span> <span class="err">permanent</span> <span class="p">{</span> <span class="err">type</span> <span class="err">empty;</span> <span class="p">}</span>
</span><span class='line'><span class="err">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Since <strong>track</strong> and <strong>permanent</strong> options are mutually exclusive they should not appear in the configuration at the same time. To model that we can use the <code>choice</code> YANG statement. Let&rsquo;s remove the <strong>track</strong> and <strong>permanent</strong> leafs from the model and replace them with this:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="err">choice</span> <span class="err">track-or-perm</span> <span class="p">{</span>
</span><span class='line'>  <span class="err">leaf</span> <span class="err">track</span> <span class="err">{</span> <span class="err">type</span> <span class="err">uint8;</span> <span class="p">}</span>
</span><span class='line'>  <span class="err">leaf</span> <span class="err">permanent</span> <span class="p">{</span> <span class="err">type</span> <span class="err">empty;</span> <span class="p">}</span>
</span><span class='line'><span class="err">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And finally, we need to add an options for VRF. When VRF is defined the whole <code>ip-route-interface-forwarding-list</code> gets encapsulated inside a list called <code>vrf</code>. This list has just one more leaf element <code>name</code> which plays the role of this lists' key. In order to model this we can use another oft-used YANG concept called <code>grouping</code>. I like to think of it as a Python function, a reusable part of code that can be referenced multiple times by its name. Here are the final changes to our model to include the VRF support:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="err">grouping</span> <span class="err">ip-route-list</span> <span class="p">{</span>
</span><span class='line'>  <span class="err">list</span> <span class="err">ip-route-interface-forwarding-list</span> <span class="err">{</span>
</span><span class='line'>      <span class="err">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="err">}</span>
</span><span class='line'><span class="err">grouping</span> <span class="err">vrf-grouping</span> <span class="p">{</span>
</span><span class='line'>  <span class="err">list</span> <span class="err">vrf</span> <span class="err">{</span>
</span><span class='line'>    <span class="err">key</span> <span class="nt">&quot;name&quot;</span><span class="err">;</span>
</span><span class='line'>    <span class="err">leaf</span> <span class="err">name</span> <span class="p">{</span> <span class="err">type</span> <span class="err">string;</span> <span class="p">}</span>
</span><span class='line'>    <span class="err">uses</span> <span class="err">ip-route-list;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="err">}</span>
</span><span class='line'><span class="err">container</span> <span class="err">route</span> <span class="p">{</span>
</span><span class='line'>  <span class="err">uses</span> <span class="err">vrf-grouping;</span>
</span><span class='line'>  <span class="err">uses</span> <span class="err">ip-route-list;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Each element in a YANG model is optional by default, which means that the <code>route</code> container can include any number of VRF and non-VRF routes. The full YANG model can be found <a href="https://github.com/networkop/yang/blob/master/yang-101/cisco-route-static.yang">here</a>.</p>

<h2>Modifying static route configuration</h2>

<p>Now let me demonstrate how to use our newly built YANG model to change the next-hop of an existing static route. Using <a href="https://github.com/mbj4668/pyang">pyang</a> we need to generate a Python module based on the YANG model.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>pyang --plugindir <span class="nv">$PYBINDPLUGIN</span> -f pybind -o binding.py cisco-route-static.yang
</span></code></pre></td></tr></table></div></figure>


<p>From a Python shell, download the current static IP route configuration:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">requests</span>
</span><span class='line'><span class="n">url</span> <span class="o">=</span> <span class="s">&quot;http://{h}:{p}/restconf/api/config/native/ip/route?deep&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h</span><span class="o">=</span><span class="s">&#39;192.168.145.51&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="s">&#39;80&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">headers</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;accept&#39;</span><span class="p">:</span> <span class="s">&#39;application/vnd.yang.data+json&#39;</span><span class="p">}</span>
</span><span class='line'><span class="n">result</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">auth</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="s">&#39;admin&#39;</span><span class="p">),</span> <span class="n">headers</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span>
</span><span class='line'><span class="n">current_json</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">text</span>
</span></code></pre></td></tr></table></div></figure>


<p>Import the downloaded JSON into a YANG model instance:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">binding</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">pyangbind.lib.pybindJSON</span> <span class="kn">as</span> <span class="nn">pybindJSON</span>
</span><span class='line'><span class="n">model</span> <span class="o">=</span> <span class="n">pybindJSON</span><span class="o">.</span><span class="n">loads_ietf</span><span class="p">(</span><span class="n">current_json</span><span class="p">,</span> <span class="n">binding</span><span class="p">,</span> <span class="s">&quot;cisco_route_static&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Delete the old next-hop and replace it with <strong>12.12.12.2</strong>:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">route</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">route</span><span class="o">.</span><span class="n">ip_route_interface_forwarding_list</span><span class="p">[</span><span class="s">&quot;2.2.2.2 255.255.255.255&quot;</span><span class="p">]</span>
</span><span class='line'><span class="n">route</span><span class="o">.</span><span class="n">fwd_list</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s">&quot;GigabitEthernet2&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">route</span><span class="o">.</span><span class="n">fwd_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;12.12.12.2&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Save the updated model in a JSON file with the help of a <a href="https://github.com/networkop/yang/blob/master/yang-101/helpers.py">write_file</a> function:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">json_data</span> <span class="o">=</span> <span class="n">pybindJSON</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;ietf&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">write_file</span><span class="p">(</span><span class="s">&#39;new_conf.json&#39;</span><span class="p">,</span> <span class="n">json_data</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Updating running configuration</h2>

<p>If we tried sending the <code>new_conf.json</code> file now, the device would have responded with an error:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>missing element: prefix in /ios:native/ios:ip/ios:route/ios:ip-route-interface-forwarding-list
</span></code></pre></td></tr></table></div></figure>


<p>In our JSON file the order of elements inside a JSON object can be different from what was defined in the YANG model. This is expected since one of the fundamental principles of JSON is that an object is an <strong>unordered</strong> collection of name/value pairs. However it looks like behind the scenes IOS XE converts JSON to XML before processing and expects all elements to come in a strict, predefined order. Fortunately, this <a href="https://github.com/CiscoDevNet/openconfig-getting-started/issues/4">bug</a> is already known and we can hope that Cisco will implement the fix for IOS XE soon. In the meantime, we&rsquo;re gonna have to resort to sending XML.</p>

<p>Following the procedure described in my <a href="http://networkop.github.io/blog/2017/01/25/netconf-intro/">previous post</a>, we can use <strong>json2xml</strong> tool to convert our instance into an XML document. Here we hit another issue. Since <strong>json2xml</strong> was designed to produce a NETCONF-compliant XML, it wraps the payload inside a <strong>data</strong> or a <strong>config</strong> element. Thankfully, <strong>json2xml</strong> is a Python script and can be easily patched to produce a RESTCONF-compliant XML. The following is a diff between the original and the patched files</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>408c409
</span><span class='line'>&lt;     if args.target not in [&quot;data&quot;, &quot;config&quot;]:
</span><span class='line'>---
</span><span class='line'>&gt;     if args.target not in [&quot;data&quot;, &quot;config&quot;, &quot;restconf&quot;]:
</span><span class='line'>437c438,442
</span><span class='line'>&lt;     ET.ElementTree(root_el).write(outfile, encoding=&quot;utf-8&quot;, xml_declaration=True)
</span><span class='line'>---
</span><span class='line'>&gt;     if args.target != &#39;restconf&#39;:
</span><span class='line'>&gt;         ET.ElementTree(root_el).write(outfile, encoding=&quot;utf-8&quot;, xml_declaration=True)
</span><span class='line'>&gt;     else:
</span><span class='line'>&gt;         ET.ElementTree(list(root_el)[0]).write(outfile, encoding=&quot;utf-8&quot;, xml_declaration=True)
</span></code></pre></td></tr></table></div></figure>


<p>Instead of patching the original file, I&rsquo;ve applied the above changes to a local copy of the file. Once patched, the following commands should produce the needed XML.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>pyang -f jtox -o static-route.jtox cisco-route-static.yang
</span><span class='line'>./json2xml -t restconf -o new_conf.xml static-route.jtox new_conf.json
</span></code></pre></td></tr></table></div></figure>


<p>The final step would be to send the generated XML to the IOS XE device. Since we are replacing the old static IP route configuration we&rsquo;re gonna have to use HTTP PUT to overwrite the old data.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>curl -v -k -u admin:admin -H <span class="s2">&quot;Content-Type: application/vnd.yang.data+xml&quot;</span> <span class="se">\</span>
</span><span class='line'> -X PUT http://192.168.145.51/restconf/api/config/native/ip/route/ -d @new_conf.xml
</span></code></pre></td></tr></table></div></figure>


<h2>Verification</h2>

<p>Back at the IOS XE CLI we can see the new static IP route installed.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>TEST#sh run | i ip route
</span><span class='line'>ip route 2.2.2.2 255.255.255.255 12.12.12.2
</span></code></pre></td></tr></table></div></figure>


<h2>More examples</h2>

<p>As always there are more examples available in my <a href="https://github.com/networkop/yang/tree/master/yang-101">YANG 101 repo</a></p>

<hr />

<p>The exercise we&rsquo;ve done in this post, though useful from a learning perspective, can come in very handy when dealing with vendors who forget or simply don&rsquo;t want to share their YANG models with their customers (I know of at least one vendor that would only publish tree representations of their YANG models). In the upcoming posts I&rsquo;ll show how to create a simple Python library to program static routes via RESTCONF and finally how to build an Ansible module to do that.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started With NETCONF and YANG on Cisco IOS XE]]></title>
    <link href="http://networkop.github.io/blog/2017/01/25/netconf-intro/"/>
    <updated>2017-01-25T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2017/01/25/netconf-intro</id>
    <content type="html"><![CDATA[<p>Everyone who has any interest in network automation inevitably comes across NETCONF and YANG. These technologies have mostly been implemented for and adopted by big telcos and service providers, while support in the enterprise/DC gear has been virtually non-existent. Things are starting to change now as NETCONF/YANG support has been introduced in the latest IOS XE software train. That&rsquo;s why I think it&rsquo;s high time I started another series of posts dedicated to YANG, NETCONF, RESTCONF and various open-source tools to interact with those interfaces.</p>

<!--more-->


<hr />

<p>To kick things off I will show how to use <a href="http://ncclient.readthedocs.io/en/latest/">ncclient</a> and <a href="https://github.com/mbj4668/pyang">pyang</a> to configure interfaces on Cisco IOS XE device. In order to make sure everyone is on the same page and to provide some reference points for the remaining parts of the post, I would first need to cover some basic theory about NETCONF, XML and YANG.</p>

<h2>NETCONF primer</h2>

<p>NETCONF is a network management protocol that runs over a secure transport (SSH, TLS etc.). It defines a set of commands (<abbr title="Remote Procedure Call">RPCs</abbr>) to change the state of a network device, however it does not define the structure of the exchanged information. The only requirement is for the payload to be a well-formed XML document. Effectively NETCONF provides a way for a network device to expose its API and in that sense it is very similar to <a href="http://networkop.github.io/blog/2016/01/01/rest-for-neteng/">REST</a>. Here are some basic NETCONF operations that will be used later in this post:</p>

<ul>
<li><strong>hello</strong> - messages exchanged when the NETCONF session is being established, used to advertise the list of supported capabilities.</li>
<li><strong>get-config</strong> - used by clients to retrieve the configuration from a network device.</li>
<li><strong>edit-config</strong> - used by clients to edit the configuration of a network device.</li>
<li><strong>close-session</strong> - used by clients to gracefully close the NETCONF session.</li>
</ul>


<p>All of these standard NETCONF operations are implemented in <a href="http://ncclient.readthedocs.io/en/latest/">ncclient</a> Python library which is what we&rsquo;re going to use to talk to CSR1k.</p>

<h2>XML primer</h2>

<p>There are several ways to exchange structured data over the network. HTML, YAML, JSON and XML are all examples of structured data formats. XML encodes data elements in tags and nests them inside one another to create complex tree-like data structures. Thankfully we are not going to spend much time dealing with XML in this post, however there are a few basic concepts that might be useful for the overall understanding:</p>

<ul>
<li><strong>Root</strong> - Every XML document has one root element containing one or more child elements.</li>
<li><strong>Path</strong> - is a way of addressing a particular element inside a tree.</li>
<li><strong>Namespaces</strong> - provide name isolation for potentially duplicate elements. As we&rsquo;ll see later, the resulting XML document may be built from several YANG models and namespaces are required to make sure there are no naming conflicts between elements.</li>
</ul>


<p>The first two concepts are similar to paths in a Linux filesystem where all of the files are laid out in a tree-like structure with root partition at its top. Namespace is somewhat similar to a unique URL identifying a particular server on the network. Using namespaces you can address multiple unique <code>/etc/hosts</code> files by prepending the host address to the path.</p>

<p>As with other structured data formats, XML by itself does not define the structure of the document. We still need something to organise a set of XML tags, specify what is mandatory and what is optional and what are the value constraints for the elements. This is exactly what YANG is used for.</p>

<h2>YANG primer</h2>

<p>YANG was conceived as a human-readable way to model the structure of an XML document. Similar to a programming language it has some primitive data types (integers, boolean, strings), several basic data structures (containers, lists, leafs) and allows users to define their own data types. The goal is to be able to formally model any network device configuration.</p>

<p>Anyone who has ever used Ansible to <a href="http://networkop.co.uk/blog/2015/08/26/automating-network-build-p1/">generate text network configuration files</a> is familiar with network modelling. Coming up with a naming conventions for variables, deciding how to split them into different files, creating data structures for variables representing different parts of configuration are all a part of network modelling. YANG is similar to that kind of modelling, only this time the models are already created for you. There are three main sources of YANG models today:</p>

<ol>
<li><strong>Equipment Vendors</strong> create their own &ldquo;native&rdquo; models to interact with their devices.</li>
<li><strong>Standards bodies</strong> (e.g. IETF and IEEE) were supposed to be the driving force of model creation. However in reality they have managed to produce only a few models that cover basic functionality like interface configuration and routing. Half of these models are still in the &ldquo;DRAFT&rdquo; stage.</li>
<li><strong>OpenConfig</strong> working group was formed by major telcos and SPs to fill the gap left by IETF. OpenConfig has produced the most number of models so far ranging from LLDP and VLAN to segment routing and BGP configurations. Unfortunately these models are only supported by high-end SP gear and we can only hope that they will find their way into the lower-end part of the market.</li>
</ol>


<p>Be sure to check of these and many other YANG models on <a href="https://github.com/YangModels/yang">YangModels</a> Github repo.</p>

<h2>Environment setup</h2>

<p>My test environment consists of a single instance of Cisco CSR1k running IOS XE 16.04.01. For the sake of simplicity I&rsquo;m not using any network emulator and simply run it as a stand-alone VM inside VMWare Workstation. CSR1k has the following configuration applied:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>username admin privilege 15 secret admin
</span><span class='line'>!
</span><span class='line'>interface GigabitEthernet1
</span><span class='line'>  ip address 192.168.145.51 255.255.255.0
</span><span class='line'>  no shutdown
</span><span class='line'>!
</span><span class='line'>netconf-yang
</span></code></pre></td></tr></table></div></figure>


<p>The last command is all what&rsquo;s required to enable NETCONF/YANG support.</p>

<p>On the same hypervisor I have my development CentOS7 VM, which is connected to the same network as the first interface of CSR1k. My VM is able to ping and ssh into the CSR1k. We will need the following additional packages installed:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum install openssl-devel python-devel python-pip gcc
</span><span class='line'>pip install ncclient pyang pyangbind ipython
</span></code></pre></td></tr></table></div></figure>


<h2>Device configuration workflow</h2>

<p>The following workflow will be performed in both interactive Python shell (e.g. iPython) and Linux bash shell. The best way to follow along is to have two sessions opened, one with each of the shells. This will save you from having to rerun import statements every time you re-open a python shell.</p>

<h3>1. Discovering device capabilities</h3>

<p>The first thing you have to do with any NETCONF-capable device is discover its capabilities. We&rsquo;ll use ncclient&rsquo;s <a href="http://ncclient.readthedocs.io/en/latest/manager.html">manager</a> module to establish a session to CSR1k. Method <code>.connect()</code> of the manager object takes device IP, port and login credentials as input and returns a reference to a NETCONF session established with the device.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">ncclient</span> <span class="kn">import</span> <span class="n">manager</span>
</span><span class='line'>
</span><span class='line'><span class="n">m</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">&#39;192.168.145.51&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">830</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s">&#39;admin&#39;</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">password</span><span class="o">=</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="n">device_params</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;csr&#39;</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="n">m</span><span class="o">.</span><span class="n">server_capabilities</span>
</span></code></pre></td></tr></table></div></figure>


<p>When the session is established, server capabilities advertised in the <strong>hello</strong> message get saved in the <code>server_capabilities</code> variable. Last command should print a long list of all capabilities and supported YANG models.</p>

<h3>2. Obtaining YANG models</h3>

<p>The task we have set for ourselves is to configure an interface. CSR1k supports both native (Cisco-specific) and IETF-standard ways of doing it. In this post I&rsquo;ll show how to use the IETF models to do that. First we need to identify which model to use. Based on the discovered capabilities we can guess that <strong>ietf-ip</strong> could be used to configure IP addresses, so let&rsquo;s get this model first. One way to get a YANG model is to search for it on the Internet, and since its an IETF model, it most likely can be found in of the <a href="https://tools.ietf.org/html/rfc7277">RFCs</a>.
Another way to get it is to download it from the device itself. All devices supporting <a href="https://tools.ietf.org/html/rfc6022">RFC6022</a> must be able to send the requested model in response to the <code>get_schema</code> call. Let&rsquo;s see how we can download the <strong>ietf-ip</strong> YANG model:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">schema</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_schema</span><span class="p">(</span><span class="s">&#39;ietf-ip&#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">schema</span>
</span></code></pre></td></tr></table></div></figure>


<p>At this stage the model is embedded in the XML response and we still need to extract it and save it in a file. To do that we&rsquo;ll use python <code>lxml</code> library to parse the received XML document, pick the first child from the root of the tree (<strong>data</strong> element) and save it into a variable. A helper function <a href="https://github.com/networkop/yang/blob/master/helpers.py">write_file</a> simply saves the Python string contained in the <code>yang_text</code> variable in a file.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">as</span> <span class="nn">ET</span>
</span><span class='line'><span class="n">root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">schema</span><span class="o">.</span><span class="n">xml</span><span class="p">)</span>
</span><span class='line'><span class="n">yang_text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">root</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span>
</span><span class='line'><span class="n">write_file</span><span class="p">(</span><span class="s">&#39;ietf-ip.yang&#39;</span><span class="p">,</span> <span class="n">yang_text</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Back at the Linux shell we can now start using pyang. The most basic function of pyang is to convert the YANG model into one of the <a href="https://github.com/mbj4668/pyang#features">many supported formats</a>. For example, tree format can be very helpful for high-level understanding of the structure of a YANG model. It produces a tree-like representation of a YANG model and annotates element types and constraints using syntax described in <a href="https://tools.ietf.org/html/rfc7277#section-1.2">this RFC</a>.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>pyang -f tree ietf-ip.yang <span class="p">|</span> head -
</span><span class='line'>module: ietf-ip
</span><span class='line'>  augment /if:interfaces/if:interface:
</span><span class='line'>    +--rw ipv4!
</span><span class='line'>    <span class="p">|</span>  +--rw enabled?      boolean
</span><span class='line'>    <span class="p">|</span>  +--rw forwarding?   boolean
</span><span class='line'>    <span class="p">|</span>  +--rw mtu?          uint16
</span><span class='line'>    <span class="p">|</span>  +--rw address* <span class="o">[</span>ip<span class="o">]</span>
</span><span class='line'>    <span class="p">|</span>  <span class="p">|</span>  +--rw ip               inet:ipv4-address-no-zone
</span><span class='line'>    <span class="p">|</span>  <span class="p">|</span>  +--rw <span class="o">(</span>subnet<span class="o">)</span>
</span><span class='line'>    <span class="p">|</span>  <span class="p">|</span>     +--:<span class="o">(</span>prefix-length<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>From the output above we can see the <strong>ietf-ip</strong> augments or extends the <strong>interface</strong> model. It adds new configurable (rw) containers with a list of IP prefixes to be assigned to an interface. Another thing we can see is that this model cannot be used on its own, since it doesn&rsquo;t specify the name of the interface it augments. This model can only be used together with <code>ietf-interfaces</code> YANG model which models the basic interface properties like MTU, state and description. In fact <code>ietf-ip</code> relies on a number of YANG models which are specified as imports at the beginning of the model definition.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>module ietf-ip {
</span><span class='line'> namespace &quot;urn:ietf:params:xml:ns:yang:ietf-ip&quot;;
</span><span class='line'> prefix ip;
</span><span class='line'> import ietf-interfaces {
</span><span class='line'>   prefix if;
</span><span class='line'> }
</span><span class='line'> import ietf-inet-types {
</span><span class='line'>   prefix inet;
</span><span class='line'> }
</span><span class='line'> import ietf-yang-types {
</span><span class='line'>   prefix yang;
</span><span class='line'> }
</span></code></pre></td></tr></table></div></figure>


<p>Each import statement specifies the model and the prefix by which it will be referred later in the document. These prefixes create a clear separation between namespaces of different models.</p>

<p>We would need to download all of these models and use them together with the <strong>ietf-ip</strong> throughout the rest of this post. Use the procedure described above to download the <strong>ietf-interfaces</strong>, <strong>ietf-inet-types</strong> and <strong>ietf-yang-types</strong> models.</p>

<h3>3. Instantiating YANG models</h3>

<p>Now we can use <a href="https://github.com/robshakir/pyangbind">pyangbind</a>, an extension to pyang, to build a Python module based on the downloaded YANG models and start building interface configuration. Make sure your <code>$PYBINDPLUGIN</code> variable is set like its described <a href="https://github.com/robshakir/pyangbind">here</a>.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>pyang --plugindir <span class="nv">$PYBINDPLUGIN</span> -f pybind -o ietf_ip_binding.py ietf-ip.yang ietf-interfaces.yang ietf-inet-types.yang ietf-inet-types.yang
</span></code></pre></td></tr></table></div></figure>


<p>The resulting <code>ietf_ip_binding.py</code> is now ready for use inside the Python shell. Note that we import <code>ietf_interfaces</code> as this is the parent object for <code>ietf_ip</code>. The details about how to work with generated Python binding can be found on pyangbind&rsquo;s <a href="https://github.com/robshakir/pyangbind">Github page</a>.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">ietf_ip_binding</span> <span class="kn">import</span> <span class="n">ietf_interfaces</span>
</span><span class='line'><span class="n">model</span> <span class="o">=</span> <span class="n">ietf_interfaces</span><span class="p">()</span>
</span><span class='line'><span class="n">model</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span><span class="s">&#39;interfaces&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;interface&#39;</span><span class="p">:</span> <span class="p">{}},</span> <span class="s">&#39;interfaces-state&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;interface&#39;</span><span class="p">:</span> <span class="p">{}}}</span>
</span></code></pre></td></tr></table></div></figure>


<p>To setup an IP address, we first need to create a model of an interface we&rsquo;re planning to manipulate. We can then use <code>.get()</code> on the model&rsquo;s instance to see the list of all configurable parameters and their defaults.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">new_interface</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;GigabitEthernet2&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">new_interface</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span><span class="s">&#39;description&#39;</span><span class="p">:</span> <span class="s">u&#39;&#39;</span><span class="p">,</span>
</span><span class='line'> <span class="s">&#39;enabled&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
</span><span class='line'> <span class="s">&#39;ipv4&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;address&#39;</span><span class="p">:</span> <span class="p">{},</span>
</span><span class='line'>  <span class="s">&#39;enabled&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
</span><span class='line'>  <span class="s">&#39;forwarding&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
</span><span class='line'>  <span class="s">&#39;mtu&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>  <span class="s">&#39;neighbor&#39;</span><span class="p">:</span> <span class="p">{}},</span>
</span><span class='line'> <span class="s">&#39;ipv6&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;address&#39;</span><span class="p">:</span> <span class="p">{},</span>
</span><span class='line'>  <span class="s">&#39;autoconf&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;create-global-addresses&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
</span><span class='line'>   <span class="s">&#39;create-temporary-addresses&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
</span><span class='line'>   <span class="s">&#39;temporary-preferred-lifetime&#39;</span><span class="p">:</span> <span class="il">86400L</span><span class="p">,</span>
</span><span class='line'>   <span class="s">&#39;temporary-valid-lifetime&#39;</span><span class="p">:</span> <span class="il">604800L</span><span class="p">},</span>
</span><span class='line'>  <span class="s">&#39;dup-addr-detect-transmits&#39;</span><span class="p">:</span> <span class="il">1L</span><span class="p">,</span>
</span><span class='line'>  <span class="s">&#39;enabled&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
</span><span class='line'>  <span class="s">&#39;forwarding&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
</span><span class='line'>  <span class="s">&#39;mtu&#39;</span><span class="p">:</span> <span class="il">0L</span><span class="p">,</span>
</span><span class='line'>  <span class="s">&#39;neighbor&#39;</span><span class="p">:</span> <span class="p">{}},</span>
</span><span class='line'> <span class="s">&#39;link-up-down-trap-enable&#39;</span><span class="p">:</span> <span class="s">u&#39;&#39;</span><span class="p">,</span>
</span><span class='line'> <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">u&#39;GigabitEthernet2&#39;</span><span class="p">,</span>
</span><span class='line'> <span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="s">u&#39;&#39;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The simples thing we can do is modify the interface description.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">new_interface</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="s">&#39;NETCONF-CONFIGURED PORT&#39;</span>
</span><span class='line'><span class="n">new_interface</span><span class="o">.</span><span class="n">get</span><span class="p">()[</span><span class="s">&#39;description&#39;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>New objects are added by calling <code>.add()</code> on the parent object and passing unique key as an argument.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">ipv4_addr</span> <span class="o">=</span> <span class="n">new_interface</span><span class="o">.</span><span class="n">ipv4</span><span class="o">.</span><span class="n">address</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;12.12.12.2&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">ipv4_addr</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span><span class="s">&#39;ip&#39;</span><span class="p">:</span> <span class="s">u&#39;12.12.12.2&#39;</span><span class="p">,</span> <span class="s">&#39;netmask&#39;</span><span class="p">:</span> <span class="s">u&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;prefix-length&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
</span><span class='line'><span class="n">ipv4_addr</span><span class="o">.</span><span class="n">netmask</span> <span class="o">=</span> <span class="s">&#39;255.255.255.0&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>At the time of writing pyangbind only supported serialisation into JSON format which means we have to do a couple of extra steps to get the required XML. For now let&rsquo;s dump the contents of our interface model instance into a file.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">pyangbind.lib.pybindJSON</span> <span class="kn">as</span> <span class="nn">pybindJSON</span>
</span><span class='line'><span class="n">json_data</span> <span class="o">=</span> <span class="n">pybindJSON</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;ietf&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">write_file</span><span class="p">(</span><span class="s">&#39;new_interface.json&#39;</span><span class="p">,</span><span class="n">json_data</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">json_data</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4. Applying configuration changes</h3>

<p>Even though pyanbind does not support XML, it is possible to use <a href="https://github.com/mbj4668/pyang/wiki/XmlJson">other pyang plugins</a> to generate XML from JSON.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>pyang -f jtox -o interface.jtox ietf-ip.yang ietf-interfaces.yang ietf-inet-types.yang ietf-yang-types.yang
</span><span class='line'>json2xml -t config -o interface.xml interface.jtox interface.json
</span></code></pre></td></tr></table></div></figure>


<p>The resulting <code>interface.xml</code> file contains the XML document ready to be sent to the device. I&rsquo;ll use <a href="https://github.com/networkop/yang/blob/master/helpers.py">read_file</a> helper function to read its contents and save it into a variable. We should still have a NETCONF session opened from one of the previous steps and we&rsquo;ll use the <a href="https://tools.ietf.org/html/rfc6241#section-7.2">edit-config</a> RPC call to apply our changes to the running configuration of CSR1k.</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">xml</span> <span class="o">=</span> read_file<span class="o">(</span><span class="s1">&#39;interface.xml&#39;</span><span class="o">)</span>
</span><span class='line'><span class="nv">reply</span> <span class="o">=</span> m.edit_config<span class="o">(</span><span class="nv">target</span><span class="o">=</span><span class="s1">&#39;running&#39;</span>, <span class="nv">config</span><span class="o">=</span>xml<span class="o">)</span>
</span><span class='line'>print<span class="o">(</span><span class="s2">&quot;Success? {}&quot;</span>.format<span class="o">(</span>reply.ok<span class="o">))</span>
</span><span class='line'>m.close_session<span class="o">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>If the change was applied successfully <code>reply.ok</code> should return <code>True</code> and we can close the session to the device.</p>

<h3>Verifying changes</h3>

<p>Going back to the CSR1k&rsquo;s CLI we should see our changes reflected in the running configuration:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>Router#sh run int gi 2
</span><span class='line'>Building configuration...
</span><span class='line'>
</span><span class='line'>Current configuration : 126 bytes
</span><span class='line'>!
</span><span class='line'>interface GigabitEthernet2
</span><span class='line'> description NETCONF-CONFIGURED PORT
</span><span class='line'> ip address 12.12.12.2 255.255.255.0
</span><span class='line'> negotiation auto
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<h3>All-in-one scripts</h3>

<p>Checkout <a href="https://github.com/networkop/yang">this</a> Github page for Python scripts that implement the above workflow in a more organised way.</p>

<hr />

<p>In this post I have merely scratched the surface of YANG modelling and network device programming. In the following posts I am planning to take a closer look at the RESTCONF interface, internal structure of a YANG model, Ansible integration and other YANG-related topics until I run out of interest. So until that happens&hellip; stay tuned.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStack SDN With OVN (Part 2) - Network Engineering Analysis]]></title>
    <link href="http://networkop.github.io/blog/2016/12/10/ovn-part2/"/>
    <updated>2016-12-10T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2016/12/10/ovn-part2</id>
    <content type="html"><![CDATA[<p>In this post we will see how OVN implements virtual networks for OpenStack. The structure of this post is such that starting from the highest level of networking abstraction we will delve deeper into implementation details with each subsequent section. The biggest emphasis will be on how networking data model gets transformed into a set of logical flows, which eventually become OpenFlow flows. The final section will introduce a new overlay protocol GENEVE and explain why VXLAN no longer satisfies the needs of an overlay protocol.</p>

<!--more-->


<h2>OpenStack - virtual network topology</h2>

<p>In the <a href="http://networkop.github.io/blog/2016/11/27/ovn-part1/">previous post</a> we have installed OpenStack and created a simple virtual topology as shown below. In OpenStack&rsquo;s data model this topology consists of the following elements:</p>

<ul>
<li><strong>Network</strong> defines a virtual L2 broadcast domain</li>
<li><strong>Subnet</strong> attached to the network, defines an IP subnet within the network</li>
<li><strong>Router</strong> provides connectivity between all directly connected subnets</li>
<li><strong>Port</strong> VM&rsquo;s point of attachment to the subnet</li>
</ul>


<p><img class="center" src="http://networkop.github.io/images/ovn-zoom1.png"></p>

<p>So far nothing unusual, this is a simple Neutron data model, all that information is stored in Neutron&rsquo;s database and can be queried with <code>neutron</code> CLI commands.</p>

<h2>OVN Northbound DB - logical network topology</h2>

<p>Every call to implement an element for the above data model is forwarded to OVN ML2 driver as defined by the <code>mechanism driver</code> setting of the ML2 plugin. This driver is responsible for the creation of an appropriate data model inside the OVN Northbound DB. The main elements of this data model are:</p>

<ul>
<li><strong>Switch</strong> equivalent of a Neutron&rsquo;s Subnet, enables L2 forwarding for all attached ports</li>
<li><strong>Distributed Router</strong> provides distributed routing between directly connected subnets</li>
<li><strong>Gateway Router</strong> provides connectivity between external networks and distributed routers, implements NAT and Load Balancing</li>
<li><strong>Port</strong> of a logical switch, attaches VM to the switch</li>
</ul>


<p>This is a visual representation of our network topology inside OVN&rsquo;s Northbound DB, built based on the output of <code>ovn-nbctl show</code> command:</p>

<p><img class="center" src="http://networkop.github.io/images/ovn-zoom2.png"></p>

<p>This topology is pretty similar to Neutron&rsquo;s native data model with the exception of a gateway router. In OVN, a gateway router is a special non-distributed router which performs functions that are very hard or impossible to distribute amongst all nodes, like NAT and Load Balancing. This router only exists on a single compute node which is selected by the scheduler based on the <code>ovn_l3_scheduler</code> setting of the ML2 plugin. It is attached to a distributed router via a point-to-point /30 subnet defined in the <code>ovn_l3_admin_net_cidr</code> setting of the ML2 plugin.</p>

<p>Apart from the logical network topology, Northbound database keeps track of all QoS, NAT and ACL settings and their parent objects. The detailed description of all tables and properties of this database can be found in the official <a href="http://openvswitch.org/support/dist-docs/ovn-nb.5.html">Northbound DB documentation</a>.</p>

<h2>OVN Southbound DB - logical flows</h2>

<p>OVN <a href="http://openvswitch.org/support/dist-docs/ovn-northd.8.html">northd</a> process running on the controller node translates the above logical topology into a set of tables stored in Southbound DB. Each row in those tables is a logical flow and together they form a <strong>forwarding pipeline</strong> by stringing together multiple actions to be performed on a packet. These actions range from packet drop through packet header modification to packet output. The stringing is implemented with a special <code>next</code> action which moves the packet one step down the pipeline starting from table 0. Let&rsquo;s have a look at the <strong>simplified</strong> versions of L2 and L3 forwarding pipelines using examples from our virtual topology.</p>

<h3>L2 datapath</h3>

<p>In the first example we&rsquo;ll explore the L2 datapath between VM1 and VM3. Both VMs are attached to the ports of the same logical switch. The full datapath of a logical switch consists of two parts - ingress and egress datapath (the direction is from the perspective of a logical switch). The ultimate goal of an ingress datapath is to determine the output port or ports (in case of multicast) and pass the packet to the egress datapath. The egress datapath does a few security checks before sending the packet out to its destination. Two things are worth noting at this stage:</p>

<ol>
<li>The two datapaths can be located either on the same or on two different hypervisor nodes. In the latter case, the packet is passed between the two nodes in an overlay tunnel.</li>
<li>The egress datapath does not have a destination lookup step which means that all information about the output port MUST be supplied by the ingress datapath. This means that destination lookup does not have to be done twice and it also has some interesting implications on the choice of encapsulation protocol as we&rsquo;ll see in the next section.</li>
</ol>


<p><img class="center" src="http://networkop.github.io/images/ovn-zoom3-l2.png"></p>

<p>Let&rsquo;s have a closer look at each of the stages of the forwarding pipeline. I&rsquo;ll include snippets of logical flows demonstrating the most interesting behaviour at each stage. Full logical datapath is quite long and can be viewed with <code>ovn-sbctl lflow-list [DATAPATH]</code> command. Here is some useful information, collected from the Northbound database, that will be used in the examples below:</p>

<hr />

<table>
<thead>
<tr>
<th> VM# </th>
<th> IP </th>
<th> MAC </th>
<th> Port UUID </th>
</tr>
</thead>
<tbody>
<tr>
<td> VM1 </td>
<td> 10.0.0.2 </td>
<td> fa:16:3e:4f:2f:b8 </td>
<td> 26c23a54-6a91-48fd-a019-3bd8a7e118de </td>
</tr>
<tr>
<td> VM3 </td>
<td> 10.0.0.5 </td>
<td> fa:16:3e:2a:60:32 </td>
<td> 5c62cfbe-0b2f-4c2a-98c3-7ee76c9d2879 </td>
</tr>
</tbody>
</table>


<hr />

<ul>
<li><strong>Port security</strong> - makes sure that incoming packet has the correct source MAC and IP addresses.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0 (ls_in_port_sec_l2), priority=50, match=(inport == "26c23a54-6a91-48fd-a019-3bd8a7e118de"
</span><span class='line'>  && eth.src == {fa:16:3e:4f:2f:b8}), action=(next;)
</span><span class='line'>table=1 (ls_in_port_sec_ip), priority=90, match=(inport == "26c23a54-6a91-48fd-a019-3bd8a7e118de"
</span><span class='line'>  && eth.src == fa:16:3e:4f:2f:b8 && ip4.src == {10.0.0.2}), action=(next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Egress ACL</strong> - set of tables that implement Neutron&rsquo;s Egress Port Security functionality. Default rules allow all egress traffic from a VM. The first flow below matches all new connections coming from VM1 and marks them for connection tracking with <code>reg0[1] = 1</code>. The next table catches these marked packets and commits them to the connection tracker. Special <code>ct_label=0/1</code> action ensures return traffic is allowed which is a standard behaviour of all stateful firewalls.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=6 (ls_in_acl), priority=2002 , match=(((ct.new && !ct.est) ||
</span><span class='line'>  (!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1)) &&
</span><span class='line'>  (inport == "26c23a54-6a91-48fd-a019-3bd8a7e118de" && ip4)),
</span><span class='line'>  action=(reg0[1] = 1; next;)
</span><span class='line'>table=9 (ls_in_stateful), priority=100  , match=(reg0[1] == 1),
</span><span class='line'>  action=(ct_commit(ct_label=0/1); next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>ARP Responder</strong> - matches an incoming ARP/ND request and generates an appropriate ARP/ND response. The way it is accomplished is similar to Neutron&rsquo;s native <a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">ARP responder</a> feature. Effectively an ARP request gets transformed into an ARP response by swapping source and destination fields.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=10(ls_in_arp_rsp), priority=50, match=(arp.tpa == 10.0.0.5 && arp.op == 1),
</span><span class='line'>  action=(eth.dst = eth.src; eth.src = fa:16:3e:2a:60:32; arp.op = 2; /* ARP reply */
</span><span class='line'>  arp.tha = arp.sha; arp.sha = fa:16:3e:2a:60:32; arp.tpa = arp.spa; arp.spa = 10.0.0.5;
</span><span class='line'>  outport = inport; flags.loopback = 1; output;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>DHCP Processing</strong> - set of tables that implement the DHCP server functionality using the approach similar to the ARP responder described above.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=12(ls_in_dhcp_response), priority=100, match=(inport == "26c23a54-6a91-48fd-a019-3bd8a7e118de"
</span><span class='line'>  && eth.src == fa:16:3e:4f:2f:b8 && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255
</span><span class='line'>  && udp.src == 68 && udp.dst == 67 && reg0[3]),
</span><span class='line'>  action=(eth.dst = eth.src; eth.src = fa:16:3e:94:b6:bc; ip4.dst = 10.0.0.2;
</span><span class='line'>  ip4.src = 10.0.0.1; udp.src = 67; udp.dst = 68; outport = inport; flags.loopback = 1; output;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Destination Lookup</strong> - implements L2 forwarding based on the destination MAC address of a frame. At this stage the <strong>outport</strong> variable is set to the VM3&rsquo;s port UUID.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=13(ls_in_l2_lkup), priority=50, match=(eth.dst == fa:16:3e:2a:60:32),
</span><span class='line'>  action=(outport = "5c62cfbe-0b2f-4c2a-98c3-7ee76c9d2879"; output;)
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Ingress ACL</strong> - set of tables that implement Neutron&rsquo;s Ingress Port security. For the sake of argument let&rsquo;s assume that we have enabled inbound SSH connections. The principle is same as before - the packet gets matched in one table and submitted to connection tracking in another table.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=4 (ls_out_acl), priority=2002 , match=(((ct.new && !ct.est)
</span><span class='line'>  || (!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1))
</span><span class='line'>  && (outport == "26c23a54-6a91-48fd-a019-3bd8a7e118de" && ip4
</span><span class='line'>  && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 22)),
</span><span class='line'>  action=(reg0[1] = 1; next;
</span><span class='line'>table=6 (ls_out_stateful), priority=100  , match=(reg0[1] == 1),
</span><span class='line'>  action=(ct_commit(ct_label=0/1); next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Port Security</strong> - implements inbound port security for destination VM by checking the sanity of destination MAC and IP addresses.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=7 (ls_out_port_sec_ip), priority=90, match=(outport == "5c62cfbe-0b2f-4c2a-98c3-7ee76c9d2879"
</span><span class='line'>  && eth.dst == fa:16:3e:2a:60:32 && ip4.dst == {255.255.255.255, 224.0.0.0/4, 10.0.0.5}),
</span><span class='line'>  action=(next;)
</span><span class='line'>table=8 (ls_out_port_sec_l2), priority=50, match=(outport == "5c62cfbe-0b2f-4c2a-98c3-7ee76c9d2879"
</span><span class='line'>  && eth.dst == {fa:16:3e:2a:60:32}),
</span><span class='line'>  action=(output;)</span></code></pre></td></tr></table></div></figure>


<h3>L3 datapath</h3>

<p>Similar to a logical switch pipeline, L3 datapath is split into ingress and egress parts. In this example we&rsquo;ll concentrate on  the Gateway router datapath. This router is connected to a distributed logical router via a transit subnet (SWtr) and to an external network via an external bridge (SWex) and performs NAT translation for all VM traffic.</p>

<p><img class="center" src="http://networkop.github.io/images/ovn-zoom3-l3.png"></p>

<p>Here is some useful information about router interfaces and ports that will be used in the examples below.</p>

<hr />

<table>
<thead>
<tr>
<th> SW function </th>
<th> IP </th>
<th> MAC </th>
<th> Port UUID </th>
</tr>
</thead>
<tbody>
<tr>
<td> External </td>
<td> 169.254.0.54/24 </td>
<td> fa:16:3e:39:c8:d8 </td>
<td> lrp-dc1ae9e3-d8fd-4451-aed8-3d6ddc5d095b </td>
</tr>
<tr>
<td> DVR-GW transit </td>
<td> 169.254.128.2/30 </td>
<td> fa:16:3e:7e:96:e7 </td>
<td> lrp-gtsp-186d8754-cc4b-40fd-9e5d-b0d26fc063bd </td>
</tr>
</tbody>
</table>


<hr />

<ul>
<li><strong>Port security</strong> - implements sanity check for all incoming packets.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0 (lr_in_admission), priority=50, match=((eth.mcast || eth.dst == fa:16:3e:7e:96:e7)
</span><span class='line'> && inport == "lrp-gtsp-186d8754-cc4b-40fd-9e5d-b0d26fc063bd"), action=(next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>IP Input</strong> - performs additional L3 sanity checks and implements typical IP services of a router (e.g. ICMP/ARP reply)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=1 (lr_in_ip_input), priority=100, match=(ip4.src == {169.254.128.2, 169.254.128.3}),
</span><span class='line'>  action=(drop;)
</span><span class='line'>table=1 (lr_in_ip_input), priority=90, match=(inport == "lrp-gtsp-186d8754-cc4b-40fd-9e5d-b0d26fc063bd"
</span><span class='line'>  && arp.tpa == 169.254.128.2 && arp.op == 1),
</span><span class='line'>  action=(eth.dst = eth.src; eth.src = fa:16:3e:7e:96:e7; arp.op = 2;
</span><span class='line'>  /* ARP reply */ arp.tha = arp.sha; arp.sha = fa:16:3e:7e:96:e7;
</span><span class='line'>  arp.tpa = arp.spa; arp.spa = 169.254.128.2;
</span><span class='line'>  outport = "lrp-gtsp-186d8754-cc4b-40fd-9e5d-b0d26fc063bd"; flags.loopback = 1; output;)
</span><span class='line'>table=1 (lr_in_ip_input), priority=90, match=(ip4.dst == 169.254.128.2
</span><span class='line'>  && icmp4.type == 8 && icmp4.code == 0),
</span><span class='line'>  action=(ip4.dst &lt;-&gt; ip4.src; ip.ttl = 255; icmp4.type = 0; flags.loopback = 1; next; )</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>UNSNAT</strong> - translates the destination IP to the real address for packets coming from <strong>external</strong> networks</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=3 (lr_in_unsnat), priority=100, match=(ip && ip4.dst == 169.254.0.54),
</span><span class='line'>  action=(ct_snat; next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>DNAT</strong> - implements what is commonly known as static NAT, i.e. performs one-to-one destination IP translation for every configured floating IP.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=4 (lr_in_dnat), priority=100, match=(ip && ip4.dst == 169.254.0.52),
</span><span class='line'>  action=(flags.loopback = 1; ct_dnat(10.0.0.5);)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>IP routing</strong> - implements L3 forwarding based on the destination IP address. At this stage the <code>outport</code> is decided, IP TTL is decremented and the new next-hop IP is set in register0.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=5 (lr_in_ip_routing), priority=1, match=(ip4.dst == 0.0.0.0/0),
</span><span class='line'>  action=(ip.ttl--; reg0 = 169.254.0.1; reg1 = 169.254.0.54; eth.src = fa:16:3e:39:c8:d8;
</span><span class='line'>  outport = "lrp-dc1ae9e3-d8fd-4451-aed8-3d6ddc5d095b"; flags.loopback = 1; next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Next Hop Resolver</strong> - discovers the next-hop MAC address for a packet. This could either be a statically configured value when the next-hop is an OVN-managed router or a dynamic binding learned through ARP and stored in a special <code>MAC_Binding</code> table of Southbound DB.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=6 (lr_in_arp_resolve), priority=100, match=(outport == "lrp-gtsp-186d8754-cc4b-40fd-9e5d-b0d26fc063bd"
</span><span class='line'>  && reg0 == 169.254.128.1), action=(eth.dst = fa:16:3e:2a:7f:25; next;)
</span><span class='line'>table=6 (lr_in_arp_resolve), priority=0, match=(ip4),
</span><span class='line'>  action=(get_arp(outport, reg0); next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>SNAT</strong> - implements what is commonly known as overload NAT. Translates source IP, source UDP/TCP port number and ICMP Query ID to hide them behind a single IP address</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0 (lr_out_snat), priority=25, match=(ip && ip4.src == 10.0.0.0/24),
</span><span class='line'>  action=(ct_snat(169.254.0.54);)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Output</strong> - send the packet out the port determined during the IP routing stage.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=1 (lr_out_delivery), priority=100, match=(outport == "lrp-gtsp-186d8754-cc4b-40fd-9e5d-b0d26fc063bd"),
</span><span class='line'>  action=(output;)</span></code></pre></td></tr></table></div></figure>


<p>This was a very high-level, abridged and simplified version of how logical datapaths are built in OVN. Hopefully this lays enough groundwork to move on to the official <a href="http://openvswitch.org/support/dist-docs/ovn-northd.8.html">northd documentation</a> which describes both L2 and L3 datapaths in much greater detail.</p>

<p>Apart from the logical flows, Southbound DB also contains a number of tables that establish the logical-to-physical bindings. For example, the <code>Port_Binding</code> table establishes binding between logical switch, logical port, logical port overlay ID (a.k.a. tunnel key) and the unique hypervisor ID. In the next section we&rsquo;ll see how this information is used to translate logical flows into OpenFlow flows at each compute node. For full description of Southbound DB, its tables and their properties refer to the official SB <a href="http://openvswitch.org/support/dist-docs/ovn-sb.5.html">schema documentation</a>.</p>

<h2>OVN Controller - OpenFlow flows</h2>

<p><a href="http://openvswitch.org/support/dist-docs/ovn-controller.8.html">OVN Controller</a> process is the distributed part of OVN SDN controller. This process, running on each compute node, connects to Southbound DB via OVSDB and configures local OVS according to information received from it. It also uses Southbound DB to exchange the physical location information with other hypervisors. The two most important bits of information that OVN controller contributes to Southbound DB are physical location of logical ports and overlay tunnel IP address. These are the last two missing pieces to map logical flows to physical nodes and networks.</p>

<p>The whole flat space of OpenFlow tables is split into multiple areas. Tables 16 to 47 implement an ingress logical pipeline and tables 48 to 63 implement an egress logical pipeline. These tables have no notion of physical ports and are functionally equivalent to logical flows in Southbound DB. Tables 0 and 65 are responsible for mapping between the physical and logical realms. In table 0 packets are matched on the physical incoming port and assigned to a correct logical datapath as was defined by the <code>Port_Binding</code> table. In table 65 the information about the outport, that was determined during the ingress pipeline processing, is mapped to a local physical interface and the packet is sent out.</p>

<p>To demonstrate the details of OpenFlow implementation, I&rsquo;ll use the traffic flow between VM1 and external destination (8.8.8.8). For the sake of brevity I will only cover the major steps of packet processing inside OVS, omitting security checks and ARP/DHCP processing.</p>

<p><img class="center" src="http://networkop.github.io/images/ovn-zoom4-openflow.png"></p>

<p>When packets traverse OpenFlow tables they get labelled or annotated with special values to simplify matching in subsequent tables. For example, when table 0 matches the incoming port, it annotates the packet with the datapath ID. Since it would have been impractical to label packets with globally unique UUIDs from Soutbound DB, these UUIDs get mapped to smaller values called <strong>tunnel keys</strong>. To make things even more confusing, each port will have a local kernel ID, unique within each hypervisor. We&rsquo;ll need both tunnel keys and local port IDs to be able to track the packets inside the OVS. The figure below depicts all port and datapath IDs that have been collected from the Soutbound DB and local OVSDB on each hypervisor. Local port numbers are attached with a dotted line to their respective tunnel keys.</p>

<p><img class="center" src="http://networkop.github.io/images/ovn-zoom4-tunnelkey.png"></p>

<p>When VM1 sends the first packet to 8.8.8.8, it reaches OVS on local port 13. OVN Controller knows that this port belongs to VM1 and installs an OpenFlow rule to match all packets from this port and annotate them with datapath ID (OXM_OF_METADATA), incoming port ID (NXM_NX_REG14), conntrack zone (NXM_NX_REG13). It then moves these annotated packets to the first table of the ingress pipeline.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0, priority=100,in_port=13 actions=load:0x2-&gt;NXM_NX_REG13[],
</span><span class='line'>  load:0x2-&gt;OXM_OF_METADATA[],load:0x2-&gt;NXM_NX_REG14[],
</span><span class='line'>  resubmit(,16)</span></code></pre></td></tr></table></div></figure>


<p>Skipping to the L2 MAC address lookup stage, the output port (0x1) is decided based on the destination MAC address and saved in register 15.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=29, priority=50,metadata=0x2,dl_dst=fa:16:3e:0d:df:ea
</span><span class='line'>  actions=load:0x1-&gt;NXM_NX_REG15[],resubmit(,32)</span></code></pre></td></tr></table></div></figure>


<p>Finally, the packet reaches the last table where it is sent out the physical patch port interface towards R1.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=65, priority=100,reg15=0x1,metadata=0x2 actions=output:1</span></code></pre></td></tr></table></div></figure>


<p>The other end of this patch port is connected to a local instance of distributed router R1. That means our packet, unmodified, re-enters OpenFlow table 0, only this time on a different port. Local port 2 is associated with a logical pipeline of a router, hence <code>metadata</code> for this packet is set to 4.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0, priority=100,in_port=2 actions=load:0x4-&gt;OXM_OF_METADATA[],
</span><span class='line'>  load:0x1-&gt;NXM_NX_REG14[],resubmit(,16)</span></code></pre></td></tr></table></div></figure>


<p>The packet progresses through logical router datapath and finally gets to table 21 where destination IP lookup take place. It matches the catch-all <strong>default route</strong> rule and the values for its next-hop IP (0xa9fe8002), MAC address (fa:16:3e:2a:7f:25) and logical output port (0x03) are set.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=21, priority=1,ip,metadata=0x4 actions=dec_ttl(),load:0xa9fe8002-&gt;NXM_NX_XXREG0[96..127],
</span><span class='line'>  load:0xa9fe8001-&gt;NXM_NX_XXREG0[64..95],mod_dl_src:fa:16:3e:2a:7f:25,
</span><span class='line'>  load:0x3-&gt;NXM_NX_REG15[],load:0x1-&gt;NXM_NX_REG10[0],resubmit(,22)</span></code></pre></td></tr></table></div></figure>


<p>Table 65 converts the logical output port 3 to physical port 6, which is yet another patch port connected to a transit switch.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=65, priority=100,reg15=0x3,metadata=0x4 actions=output:6</span></code></pre></td></tr></table></div></figure>


<p>The packet once again re-enters OpenFlow pipeline from table 0, this time from port 5. Table 0 maps incoming port 5 to the logical datapath of a transit switch with Tunnel key 7.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0, priority=100,in_port=5 actions=load:0x7-&gt;OXM_OF_METADATA[],
</span><span class='line'>  load:0x1-&gt;NXM_NX_REG14[],resubmit(,16)</span></code></pre></td></tr></table></div></figure>


<p>Destination lookup determines the output port (2) but this time, instead of entering the egress pipeline locally, the packet gets sent out the physical tunnel port (7) which points to the IP address of a compute node hosting the GW router. The headers of an overlay packet are populated with logical datapath ID (0x7), logical input port (copied from register 14) and logical output port (0x2).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=29, priority=50,metadata=0x7,dl_dst=fa:16:3e:7e:96:e7
</span><span class='line'>  actions=load:0x2-&gt;NXM_NX_REG15[],resubmit(,32)
</span><span class='line'>table=32, priority=100,reg15=0x2,metadata=0x7 actions=load:0x7-&gt;NXM_NX_TUN_ID[0..23],
</span><span class='line'>  set_field:0x2/0xffffffff-&gt;tun_metadata0,move:NXM_NX_REG14[0..14]-&gt;NXM_NX_TUN_METADATA0[16..30],
</span><span class='line'>  output:7</span></code></pre></td></tr></table></div></figure>


<p>When packet reaches the destination node, it once again enters the OpenFlow table 0, but this time all information is extracted from the tunnel keys.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0, priority=100,in_port=17 actions=move:NXM_NX_TUN_ID[0..23]-&gt;OXM_OF_METADATA[0..23],
</span><span class='line'>  move:NXM_NX_TUN_METADATA0[16..30]-&gt;NXM_NX_REG14[0..14],
</span><span class='line'>  move:NXM_NX_TUN_METADATA0[0..15]-&gt;NXM_NX_REG15[0..15],
</span><span class='line'>  resubmit(,33)</span></code></pre></td></tr></table></div></figure>


<p>At the end of the transit switch datapath the packet gets sent out port 12, whose peer is patch port 16.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=65, priority=100,reg15=0x2,metadata=0x7 actions=output:12</span></code></pre></td></tr></table></div></figure>


<p>The packet re-enters OpenFlow table 0 from port 16, where it gets mapped to the logical datapath of a gateway router.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0, priority=100,in_port=16 actions=load:0x2-&gt;NXM_NX_REG11[],
</span><span class='line'>  load:0x6-&gt;NXM_NX_REG12[],load:0x6-&gt;OXM_OF_METADATA[],
</span><span class='line'>  load:0x2-&gt;NXM_NX_REG14[],resubmit(,16)</span></code></pre></td></tr></table></div></figure>


<p>Similar to a distributed router R1, table 21 determines the next-hop MAC address for a packet and saves the output port in register 15.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=21, priority=1,ip,metadata=0x6 actions=dec_ttl(),load:0xa9fe0001-&gt;NXM_NX_XXREG0[96..127],
</span><span class='line'>  load:0xa9fe0036-&gt;NXM_NX_XXREG0[64..95],mod_dl_src:fa:16:3e:39:c8:d8,
</span><span class='line'>  load:0x1-&gt;NXM_NX_REG15[],load:0x1-&gt;NXM_NX_REG10[0],resubmit(,22)</span></code></pre></td></tr></table></div></figure>


<p>The first table of an egress pipeline source-NATs packets to external IP address of the GW router.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=48, priority=33,ip,metadata=0x6,nw_src=10.0.0.2
</span><span class='line'>  actions=ct(commit,table=49,zone=NXM_NX_REG12[0..15],nat(src=169.254.0.56))</span></code></pre></td></tr></table></div></figure>


<p>The modified packet is sent out the physical port 14 towards the external switch.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=65, priority=100,reg15=0x1,metadata=0x6 actions=output:14</span></code></pre></td></tr></table></div></figure>


<p>External switch determines the output port connected to the <code>br-ex</code> on a local hypervisor and send the packet out.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0, priority=100,in_port=13 actions=load:0x5-&gt;NXM_NX_REG11[],
</span><span class='line'>  load:0x3-&gt;NXM_NX_REG12[],load:0x3-&gt;OXM_OF_METADATA[],
</span><span class='line'>  load:0x2-&gt;NXM_NX_REG14[],resubmit(,16)
</span><span class='line'>table=29, priority=0,metadata=0x3 actions=load:0xfffe-&gt;NXM_NX_REG15[],resubmit(,32)
</span><span class='line'>table=33, priority=100,reg15=0xfffe,metadata=0x3
</span><span class='line'>  actions=load:0x1-&gt;NXM_NX_REG13[],load:0x1-&gt;NXM_NX_REG15[],
</span><span class='line'>  resubmit(,34),load:0xfffe-&gt;NXM_NX_REG15[]
</span><span class='line'>table=65, priority=100,reg15=0x1,metadata=0x3 actions=output:15</span></code></pre></td></tr></table></div></figure>


<p>As we&rsquo;ve just seen, OpenFlow repeats the logical topology by interconnecting logical datapaths of switches and routers with virtual point-to-point patch cables. This may seem like an unnecessary modelling element with a potential for a performance impact. However, when flows get installed in kernel datapath, these patch ports <a href="http://galsagie.github.io/2015/11/23/ovn-l3-deepdive">do not exist</a>, which means that there isn&rsquo;t any performance impact on packets in fastpath.</p>

<h2>Physical network - GENEVE overlay</h2>

<p>Before we wrap up, let us have a quick look at the new overlay protocol GENEVE. The goal of any overlay protocol is to transport all the necessary tunnel keys. With VXLAN the only tunnel key that could be transported is the Virtual Network Identifier (VNI). In OVN&rsquo;s case these tunnel keys include not only the logical datapath ID (commonly known as VNI) but also both input and output port IDs. You could have carved up the 24 bits of VXLAN tunnel ID to encode all this information but this would only have given you 256 unique values per key. Some other overlay protocols, like STT have even bigger tunnel ID header size but they, too, have a strict upper limit.</p>

<p>GENEVE was designed to have a variable-length header. The first few bytes are well-defined fixed size fields followed by variable-length Options. This kind of structure allows software developers to innovate at their own pace while still getting the benefits of hardware offload for the fixed-size portion of the header. OVN developers <a href="http://openvswitch.org/support/dist-docs/ovn-architecture.7.html">decided</a> to use Options header type 0x80 to store the 15-bit logical ingress port ID and a 16-bit egress port ID (an extra bit is for logical multicast groups).</p>

<p><img class="center" src="http://networkop.github.io/images/ovn-zoom5-geneve.png"></p>

<p>The figure above shows the ICMP ping coming from VM1(10.0.0.2) to Google&rsquo;s DNS. As I&rsquo;ve showed in the previous section, GENEVE is used between the ingress and egress pipelines of a transit switch (SWtr), whose datapath ID is encoded in the VNI field (0x7). Packets enter the transit switch on port 1 and leave it on port 2. These two values are encoded in the <code>00010002</code> value of the <code>Options Data</code> field.</p>

<p>So now that GENEVE has taken over as the inter-hypervisor overlay protocol, does that mean that VXLAN is dead? OVN still supports VXLAN but only for interconnects with 3rd party devices like VXLAN-VLAN gateways or VXLAN TOR switches. Rephrasing the official OVN <a href="http://openvswitch.org/support/dist-docs/ovn-architecture.7.html">documentation</a>, VXLAN gateways will continue to be supported but they will have a reduced feature set due to lack of extensibility.</p>

<h2>Conclusion</h2>

<p>OpenStack networking has always been one of the first use cases of any new SDN controller. All the major SDN platforms like ACI, NSX, Contrail, VSP or ODL have some form of OpenStack integration. And it made sense, since native Neutron networking has always been one of the biggest pain points in OpenStack deployments. As I&rsquo;ve just demonstrated, OVN can now do all of the common networking functionality natively, without having to rely on 3rd party agents. In addition to that it has a fantastic <a href="http://openvswitch.org/support/dist-docs/">documentation</a>, implements all forwarding inside a single OVS bridge and it is an open-source project. As an OpenStack networking solution it is still, perhaps, a few months away from being production ready - active/active HA is not supported with OVSDB, GW router scheduling options are limited, lack of native support for DNS and Metadata proxy. However I anticipate that starting from the next OpenStack release (Ocata, Feb 2017) OVN will be ready for mass deployment even by companies without an army of OVS/OpenStack developers. And when that happens there will even less need for proprietary OpenStack SDN platforms.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStack SDN With OVN (Part 1) - Build and Install]]></title>
    <link href="http://networkop.github.io/blog/2016/11/27/ovn-part1/"/>
    <updated>2016-11-27T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2016/11/27/ovn-part1</id>
    <content type="html"><![CDATA[<p>This is a first of a two-post series dedicated to project OVN. In this post I&rsquo;ll show how to build, install and configure OVN to work with a 3-node RDO OpenStack lab.</p>

<!--more-->


<p>Vanilla OpenStack networking has many functional, performance and scaling limitations. Projects like <a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">L2 population</a>, <a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">local ARP responder</a>, <a href="http://networkop.github.io/blog/2016/05/21/neutron-l2gw/">L2 Gateway</a> and <a href="http://networkop.github.io/blog/2016/10/13/os-dvr/">DVR</a> were conceived to address those issues. However good a job these projects do, they still remain a collection of separate projects, each with its own limitations, configuration options and sets of dependencies. That led to an effort outside of OpenStack to develop a special-purpose OVS-only SDN controller that would address those issues in a centralised and consistent manner. This post will be about one such SDN controller, coming directly from the people responsible for OpenvSwitch, Open Virtual Network (OVN).</p>

<h2>OVN quick introduction</h2>

<p>OVN is a distributed SDN controller implementing virtual networks with the help OVS. Even though it is positioned as a <abbr title="Cloud Management System">CMS</abbr>-independent controller, the main use case is still OpenStack. OVN was designed to address the following limitations of vanilla OpenStack networking:</p>

<ul>
<li>Security groups could not be implemented directly on OVS ports and, therefore, required a dedicated Linux bridge between the VM and the OVS integration bridge.</li>
<li>Routing and DHCP agents required dedicated network namespaces.</li>
<li>NAT was implemented using a combination of network namespaces, iptables and proxy-ARP.</li>
</ul>


<p>OVN implements security groups, distributed virtual routing, NAT and distributed DHCP server all inside a single OVS bridge. This dramatically improves performance by reducing the number of inter-process packet handling and ensures that all flows can benefit from kernel fast-path switching.</p>

<p>At a high level, OVN consists of 3 main components:</p>

<ol>
<li>OVN ML2 Plugin - performs translation between Neutron data model and OVN logical data model stored in Northbound DB.</li>
<li>OVN northd - the brains of OVN, translates the high level networking abstractions (logical switches, routers and ports) into logical flows. These <a href="https://blog.russellbryant.net/2016/11/11/ovn-logical-flows-and-ovn-trace/">logical flows</a> are not yet OpenFlow flows but similar in concept and a very powerful abstraction. All translated information is stored in Southbound DB.</li>
<li>OVN controllers - located on each compute node, receive identical copies of logical flows (centralised network view) and exchange logical port to overlay IP binding information via the central Southbound DB. This information is used to perform logical flow translation into OpenFlow which are then programmed into the local OVS instance.</li>
</ol>


<p><img class="center" src="http://networkop.github.io/images/ovn-arch.png"></p>

<p>If you want to learn more about OVN architecture and use cases, <a href="http://docs.openstack.org/developer/networking-ovn/readme.html">OpenStack OVN page</a> has an excellent collection of resources for further reading.</p>

<h2>OpenStack installation</h2>

<p>I&rsquo;ll use RDO packstack to help me build a 1 controller and 2 compute nodes OpenStack lab on CentOS7. I&rsquo;ll use the master trunk to deploy the latest OpenStack Ocata packages. This is required since at the time of writing (Nov 2016) some of the OVN features were not available in OpenStack Newton.</p>

<figure class='code'><figcaption><span>Install latest RDO repositories on all 3 nodes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> /etc/yum.repos.d/
</span><span class='line'>wget http://trunk.rdoproject.org/centos7/delorean-deps.repo
</span><span class='line'>wget https://trunk.rdoproject.org/centos7-master/current/delorean.repo
</span></code></pre></td></tr></table></div></figure>


<p>On the controller node, generate a sample answer file and modify settings to match the IPs of individual nodes. Optionally, you can disable some of the unused components like Nagios and Ceilometer similar to how I did it in my <a href="http://networkop.co.uk/blog/2016/04/18/os-unl-lab/">earlier post</a>.</p>

<figure class='code'><figcaption><span>Modify answer file and deploy OpenStack</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum install -y openstack-packstack crudini
</span><span class='line'>packstack --gen-answer-file<span class="o">=</span>/root/packstack.answer
</span><span class='line'>crudini --set --existing defautl CONFIG_COMPUTE_HOSTS 169.254.0.12,169.254.0.13
</span><span class='line'>crudini --set --existing defautl CONFIG_CONTROLLER_HOST 169.254.0.11
</span><span class='line'>crudini --set --existing defautl CONFIG_NETWORK_HOSTS 169.254.0.11
</span><span class='line'>packstack --answer-file<span class="o">=</span>/root/packstack.answer
</span></code></pre></td></tr></table></div></figure>


<p>After the last step we should have a working 3-node OpenStack lab, similar to the one depicted below. If you want to learn about how to automate this process, refer to my older posts about <a href="http://networkop.github.io/blog/2016/08/26/os-lab-p1/">OpenStack</a> and <a href="http://networkop.github.io/blog/2016/09/09/os-lab-p2/">underlay Leaf-Spine fabric</a> build using Chef.</p>

<p><img class="center" src="http://networkop.github.io/images/ovn-openstack.png"></p>

<h2>OVN Build</h2>

<p>OVN can be built directly from OVS source code. Instead of building and installing OVS on each of the OpenStack nodes individually, I&rsquo;ll build a set of RPM&rsquo;s on the Controller and will use them to install and upgrade OVS/OVN components on the remaining nodes.</p>

<p>Part of OVN build process includes building an OVS kernel module. In order to be able to use kmod RPM on all nodes we need to make sure all nodes use the same version of Linux kernel. The easiest way would be to fetch the latest updates from CentOS repos and reboot the nodes. This step should result in same kernel version on all nodes, which can be checked with <code>uname -r</code> command.</p>

<figure class='code'><figcaption><span>Upgrade kernel on all nodes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum -y update kernel
</span><span class='line'>reboot
</span></code></pre></td></tr></table></div></figure>


<p>The official <a href="https://github.com/openvswitch/ovs/blob/master/INSTALL.Fedora.rst">OVS installation procedure for CentOS7</a> is pretty accurate and requires only a few modifications to account for the packages missing in the minimal CentOS image I&rsquo;ve used as a base OS.</p>

<figure class='code'><figcaption><span>OVS build procedure</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum install rpm-build autoconf automake libtool systemd-units openssl openssl-devel python python-twisted-core python-zope-interface python-six desktop-file-utils groff graphviz procps-ng libcap-ng libcap-ng-devel
</span><span class='line'>yum install selinux-policy-devel kernel-devel-<span class="sb">`</span>uname -r<span class="sb">`</span> git
</span><span class='line'>git clone https://github.com/openvswitch/ovs.git
</span><span class='line'><span class="nb">cd </span>ovs
</span><span class='line'>./boot.sh
</span><span class='line'>./configure
</span><span class='line'>make rpm-fedora <span class="nv">RPMBUILD_OPT</span><span class="o">=</span><span class="s2">&quot;--without check&quot;</span>
</span><span class='line'>make rpm-fedora-kmod
</span></code></pre></td></tr></table></div></figure>


<p>At the end of the process we should have a set of rpms inside the <code>ovs/rpm/rpmbuild/RPMS/</code> directory.</p>

<h2>OVN Install</h2>

<p>Before we can begin installing OVN, we need to prepare the existing OpenStack environment by disabling and removing legacy Neutron OpenvSwitch agents. Since OVN natively implements L2 and L3 forwarding, DHCP and NAT, we won&rsquo;t need L3 and DHCP agents on any of the Compute nodes. Network node that used to provide North-South connectivity will no longer be needed.</p>

<h3>OpenStack preparation</h3>

<p>First, we need to make sure all Compute nodes have a bridge that would provide access to external provider networks. In my case, I&rsquo;ll move the <code>eth1</code> interface under the OVS <code>br-ex</code> on all Compute nodes.</p>

<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-eth1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">DEVICE</span><span class="o">=</span>eth1
</span><span class='line'><span class="nv">NAME</span><span class="o">=</span>eth1
</span><span class='line'><span class="nv">DEVICETYPE</span><span class="o">=</span>ovs
</span><span class='line'><span class="nv">TYPE</span><span class="o">=</span>OVSPort
</span><span class='line'><span class="nv">OVS_BRIDGE</span><span class="o">=</span>br-ex
</span><span class='line'><span class="nv">ONBOOT</span><span class="o">=</span>yes
</span><span class='line'><span class="nv">BOOTPROTO</span><span class="o">=</span>none
</span></code></pre></td></tr></table></div></figure>


<p>IP address needs to be moved to <code>br-ex</code> interface. Below example is for Compute node #2:</p>

<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-br-ex</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">ONBOOT</span><span class="o">=</span>yes
</span><span class='line'><span class="nv">DEFROUTE</span><span class="o">=</span>yes
</span><span class='line'><span class="nv">IPADDR</span><span class="o">=</span>169.254.0.12
</span><span class='line'><span class="nv">PREFIX</span><span class="o">=</span>24
</span><span class='line'><span class="nv">GATEWAY</span><span class="o">=</span>169.254.0.1
</span><span class='line'><span class="nv">DNS1</span><span class="o">=</span>8.8.8.8
</span><span class='line'><span class="nv">DEVICE</span><span class="o">=</span>br-ex
</span><span class='line'><span class="nv">NAME</span><span class="o">=</span>br-ex
</span><span class='line'><span class="nv">DEVICETYPE</span><span class="o">=</span>ovs
</span><span class='line'><span class="nv">OVSBOOTPROTO</span><span class="o">=</span>none
</span><span class='line'><span class="nv">TYPE</span><span class="o">=</span>OVSBridge
</span></code></pre></td></tr></table></div></figure>


<p>At the same time OVS configuration on Network/Controller node will need to be completely wiped out. Once that&rsquo;s done, we can remove the Neutron OVS package from all nodes.</p>

<figure class='code'><figcaption><span>Remove legacy Neutron OVS agents</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum remove openstack-neutron-openvswitch
</span></code></pre></td></tr></table></div></figure>


<h3>OVS packages installation</h3>

<p>Now everything is ready for OVN installation. First step is to install the kernel module and upgrade the existing OVS package. Reboot may be needed in order for the correct kernel module to be loaded.</p>

<figure class='code'><figcaption><span>Upgrade OVS on all nodes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>rpm -i openvswitch-kmod-2.6.90-1.el7.centos.x86_64.rpm
</span><span class='line'>rpm -U openvswitch-2.6.90-1.el7.centos.x86_64.rpm
</span><span class='line'>reboot
</span></code></pre></td></tr></table></div></figure>


<p>Now we can install OVN. Controllers will be running the <code>ovn-northd</code> process which can be installed as follows:</p>

<figure class='code'><figcaption><span>Install OVN on the Controller</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>rpm -i openvswitch-ovn-common-*.x86_64.rpm
</span><span class='line'>rpm -i openvswitch-ovn-central-*.x86_64.rpm
</span><span class='line'>systemctl start ovn-northd
</span></code></pre></td></tr></table></div></figure>


<p>The following packages install the <code>ovn-controller</code> on all Compute nodes:</p>

<figure class='code'><figcaption><span>Install OVN on Compute nodes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>rpm -i openvswitch-ovn-common-*.x86_64.rpm
</span><span class='line'>rpm -i openvswitch-ovn-host-*.x86_64.rpm
</span><span class='line'>systemctl start ovn-controller
</span></code></pre></td></tr></table></div></figure>


<p>The last thing is to install the OVN ML2 plugin, a python library that allows Neutron to talk to OVN Northbound database.</p>

<figure class='code'><figcaption><span>Install OVN ML2 plugin on the Controller</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum install python-networking-ovn
</span></code></pre></td></tr></table></div></figure>


<h2>OVN Configuration</h2>

<p>Now that we have all the required packages in place, it&rsquo;s time to reconfigure Neutron to start using OVN instead of a default openvswitch plugin. The installation procedure is described in the official <a href="http://docs.openstack.org/developer/networking-ovn/index.html">Neutron integration guide</a>. At the end, once we&rsquo;ve restarted <code>ovn-northd</code> on the controller and <code>ovn-controller</code> on the compute nodes, we should see the following output on the controller node:</p>

<figure class='code'><figcaption><span>ovs-sbctl show</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Chassis <span class="s2">&quot;d03bdd51-e687-4078-aa54-0ff8007db0b5&quot;</span>
</span><span class='line'>    hostname: <span class="s2">&quot;compute-3&quot;</span>
</span><span class='line'>    Encap geneve
</span><span class='line'>        ip: <span class="s2">&quot;10.0.0.4&quot;</span>
</span><span class='line'>        options: <span class="o">{</span><span class="nv">csum</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="o">}</span>
</span><span class='line'>    Encap vxlan
</span><span class='line'>        ip: <span class="s2">&quot;10.0.0.4&quot;</span>
</span><span class='line'>        options: <span class="o">{</span><span class="nv">csum</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="o">}</span>
</span><span class='line'>Chassis <span class="s2">&quot;b89b8683-7c74-43df-8ac6-1d57ddefec77&quot;</span>
</span><span class='line'>    hostname: <span class="s2">&quot;compute-2&quot;</span>
</span><span class='line'>    Encap vxlan
</span><span class='line'>        ip: <span class="s2">&quot;10.0.0.2&quot;</span>
</span><span class='line'>        options: <span class="o">{</span><span class="nv">csum</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="o">}</span>
</span><span class='line'>    Encap geneve
</span><span class='line'>        ip: <span class="s2">&quot;10.0.0.2&quot;</span>
</span><span class='line'>        options: <span class="o">{</span><span class="nv">csum</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This means that all instances of a distributed OVN controller located on each compute node have successfully registered with Southbound OVSDB and provided information about their physical overlay addresses and supported encapsulation types.</p>

<h2>(Optional) Automating everything with Chef</h2>

<p>At this point of time there&rsquo;s no way to automate OVN deployment with Packstack (TripleO already has OVN integration templates). For those who want to bypass the manual build process I have created a new Chef cookbook, automating all steps described above. This Chef playbook assumes that OpenStack environment has been built as described in my <a href="http://networkop.github.io/blog/2016/08/26/os-lab-p1/">earlier post</a>. Optionally, you can automate the build of underlay network as well by following my <a href="http://networkop.github.io/blog/2016/09/09/os-lab-p2/">other post</a>. Once you&rsquo;ve got both OpenStack and underlay built, you can use the following scripts to build, install and configure OVN:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git clone https://github.com/networkop/chef-unl-os.git
</span><span class='line'><span class="nb">cd </span>chef-unl-os
</span><span class='line'>chef-client -z -E lab ovn.rb
</span></code></pre></td></tr></table></div></figure>


<h2>Test topology setup</h2>

<p>Now we should be able to create a test topology with two tenant subnets and an external network interconnected by a virtual router.</p>

<figure class='code'><figcaption><span>Creating a test topology</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>neutron net-create NET-RED
</span><span class='line'>neutron net-create NET-BLUE
</span><span class='line'>neutron subnet-create --name SUB-BLUE NET-BLUE 10.0.0.0/24
</span><span class='line'>neutron subnet-create --name SUB-RED NET-RED 20.0.0.0/24
</span><span class='line'>neutron net-create NET-EXT --provider:network_type flat <span class="se">\</span>
</span><span class='line'>                           --provider:physical_network extnet <span class="se">\</span>
</span><span class='line'>                           --router:external --shared
</span><span class='line'>neutron subnet-create --name SUB-EXT --enable_dhcp<span class="o">=</span>False <span class="se">\</span>
</span><span class='line'>                      --allocation-pool<span class="o">=</span><span class="nv">start</span><span class="o">=</span>169.254.0.50,end<span class="o">=</span>169.254.0.99 <span class="se">\</span>
</span><span class='line'>                      --gateway<span class="o">=</span>169.254.0.1 NET-EXT 169.254.0.0/24
</span><span class='line'>neutron router-create R1
</span><span class='line'>neutron router-interface-add R1 SUB-BLUE
</span><span class='line'>neutron router-interface-add R1 SUB-RED
</span><span class='line'>neutron router-gateway-set R1 NET-EXT
</span></code></pre></td></tr></table></div></figure>


<p>When we attach a few test VMs to each subnet we should be able to successfully ping between the VMs, assuming the security groups are setup to allow ICMP/ND.</p>

<figure class='code'><figcaption><span>Create VMs</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>curl http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img <span class="p">|</span> glance <span class="se">\</span>
</span><span class='line'>image-create --name<span class="o">=</span><span class="s1">&#39;IMG-CIRROS&#39;</span> <span class="se">\</span>
</span><span class='line'>  --visibility<span class="o">=</span>public <span class="se">\</span>
</span><span class='line'>  --container-format<span class="o">=</span>bare <span class="se">\</span>
</span><span class='line'>  --disk-format<span class="o">=</span>qcow2
</span><span class='line'>nova aggregate-create AGG-RED AZ-RED
</span><span class='line'>nova aggregate-create AGG-BLUE AZ-BLUE
</span><span class='line'>nova aggregate-add-host AGG-BLUE compute-2
</span><span class='line'>nova aggregate-add-host AGG-RED compute-3
</span><span class='line'>nova boot --flavor m1.tiny --image <span class="s1">&#39;IMG-CIRROS&#39;</span> <span class="se">\</span>
</span><span class='line'>  --nic net-name<span class="o">=</span>NET-BLUE <span class="se">\</span>
</span><span class='line'>  --availability-zone AZ-BLUE <span class="se">\</span>
</span><span class='line'>  VM1
</span><span class='line'>
</span><span class='line'>nova boot --flavor m1.tiny --image <span class="s1">&#39;IMG-CIRROS&#39;</span> <span class="se">\</span>
</span><span class='line'>  --nic net-name<span class="o">=</span>NET-RED <span class="se">\</span>
</span><span class='line'>  --availability-zone AZ-RED <span class="se">\</span>
</span><span class='line'>  VM2
</span><span class='line'>nova boot --flavor m1.tiny --image <span class="s1">&#39;IMG-CIRROS&#39;</span> <span class="se">\</span>
</span><span class='line'>  --nic net-name<span class="o">=</span>NET-BLUE <span class="se">\</span>
</span><span class='line'>  --availability-zone AZ-RED <span class="se">\</span>
</span><span class='line'>  VM3
</span><span class='line'>openstack floating ip create NET-EXT
</span><span class='line'>openstack server add floating ip VM3 169.254.0.53
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://networkop.github.io/images/ovn-topo.png"></p>

<p>In the next post we will use the above virtual topology to explore the dataplane packet flow inside an OVN-managed OpenvSwitch and how it uses the new encapsulation protocol GENEVE to optimise egress forwarding lookups on remote compute nodes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type-2 and Type-5 EPVN on vQFX 10k in UnetLab]]></title>
    <link href="http://networkop.github.io/blog/2016/10/26/qfx-unl/"/>
    <updated>2016-10-26T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/10/26/qfx-unl</id>
    <content type="html"><![CDATA[<p>I was fortunate enough to be given a chance to test the new virtual QFX 10k image from Juniper. In this post I will show how to import this image into UnetLab and demonstrate the basic L2 and L3 EVPN services.</p>

<!--more-->


<h2>News about UnetLab</h2>

<p>Those who read my blog regularly know that I&rsquo;m a big fan of a network simulator called UnetLab. For the last two years I&rsquo;ve done all my labbing in UNL and was constantly surprised by how extensible and stable it has been. I believe that projects like this are very important to our networking community because they help train the new generation of network engineers and enable them to expand their horizons. Recently UnetLab team has decided take the next step and create a new version of UNL. This new project, called <a href="https://www.indiegogo.com/projects/eve-ng-emulated-virtual-environment-next-gen#/">EVE-NG</a>, will help users build labs of any size and run full replicas of their production networks, which is ideal for <a href="http://networkop.github.io/blog/2016/02/19/network-ci-intro/">pre-deployment testing</a> of network changes. If you want to learn more, check out the <a href="https://www.indiegogo.com/projects/eve-ng-emulated-virtual-environment-next-gen#/">EVE-NG</a> page on indiegogo.</p>

<h2>Creating vQFX nodes in UnetLab</h2>

<p>Back to the business at hand, vQFX is not publically available yet but is expected to pop up at <a href="http://www.juniper.net/">Juniper.net</a> some time in the future. Similar to a recently released vMX, vQFX will consist of two virtual machines - one running the routing engine (RE) and second simulating the ASIC forwarding piplines (PFE). You can find more information about these images on Juniper&rsquo;s <a href="https://github.com/Juniper/vqfx10k-vagrant">Github page</a>. Images get distributed in multiple formats but in the context of this post we&rsquo;ll only deal with two VMDK files:</p>

<figure class='code'><figcaption><span>vQFX images</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>vqfx10k-re-15.1X53-D60.vmdk
</span><span class='line'>vqfx10k-pfe-20160609-2.vmdk
</span></code></pre></td></tr></table></div></figure>


<p>To be able to use these images in UnetLab, we first need to convert them to <strong>qcow2</strong> format and copy them to the directory where UNL stores all its qemu images:</p>

<figure class='code'><figcaption><span>Importing VMDK images</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> mkdir /opt/unetlab/addons/qemu/qfx_re-15d1X53
</span><span class='line'> mkdir /opt/unetlab/addons/qemu/qfx_pfe-20160609
</span><span class='line'>
</span><span class='line'>/opt/qemu/bin/qemu-img convert -f vmdk -O qcow2 vqfx10k-pfe-20160609-2.vmdk /opt/unetlab/addons/qemu/qfx_pfe-20160609/hda.qcow2
</span><span class='line'>
</span><span class='line'>/opt/qemu/bin/qemu-img convert -f vmdk -O qcow2 vqfx10k-re-15.1X53-D60.vmdk /opt/unetlab/addons/qemu/qfx_re-15d1X53/hda.qcow2
</span></code></pre></td></tr></table></div></figure>


<p>Next, we need to create new node definitions for RE and PFE VMs. The easiest way would be to clone the linux node type:</p>

<figure class='code'><figcaption><span>Creating vQFX node definitions</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> /opt/unetlab/html/templates
</span><span class='line'>cp linux.php qfx_pfe.php
</span><span class='line'>cp linux.php qfx_re.php
</span><span class='line'>
</span><span class='line'>sed -i <span class="s1">&#39;s/2048/1024/; s/virtio-net-pci/e1000/; s/Server/Switch/&#39;</span> qfx_re.php
</span><span class='line'>sed -i <span class="s1">&#39;s/2048/1536/; s/virtio-net-pci/e1000/; s/Server/Switch/&#39;</span> qfx_pfe.php
</span><span class='line'>
</span><span class='line'>sed -i <span class="s1">&#39;s/Linux/QFX_RE/g; s/linux/qfx_re/g&#39;</span> qfx_re.php
</span><span class='line'>sed -i <span class="s1">&#39;s/Linux/QFX_PFE/g; s/linux/qfx_pfe/g&#39;</span> qfx_pfe.php
</span><span class='line'>
</span><span class='line'>sed -ri <span class="s1">&#39;s/(.*ethernet.*) = 1/\1 = 2/&#39;</span> qfx_pfe.php
</span><span class='line'>sed -ri <span class="s1">&#39;s/(.*ethernet.*) = 1/\1 = 8/&#39;</span> qfx_re.php
</span></code></pre></td></tr></table></div></figure>


<p>Now let&rsquo;s add the QFX to the list of nodes by modifying the following file:</p>

<figure class='code'><figcaption><span>/opt/unetlab/html/includes/init.php</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="s1">&#39;openstack&#39;</span>             <span class="o">=</span>&gt;      <span class="s1">&#39;Openstack&#39;</span>,
</span><span class='line'><span class="s1">&#39;qfx_re&#39;</span>                <span class="o">=</span>&gt;      <span class="s1">&#39;QFX10k-RE&#39;</span>,
</span><span class='line'><span class="s1">&#39;qfx_pfe&#39;</span>               <span class="o">=</span>&gt;      <span class="s1">&#39;QFX10k-PFE&#39;</span>,
</span><span class='line'><span class="s1">&#39;mikrotik&#39;</span>              <span class="o">=</span>&gt;      <span class="s1">&#39;MikroTik RouterOS&#39;</span>,
</span></code></pre></td></tr></table></div></figure>


<p>Optionally, <code>/opt/unetlab/html/includes/__node.php</code> can be modified to change the default naming convention similar to the <code>vmx</code> node.</p>

<p>Once you&rsquo;ve done all the above changes, you should have a working vQFX 10k node available in UNL GUI. For the purpose of demonstration of EVPN features I&rsquo;ve created the following topology:</p>

<p><img class="center" src="http://networkop.github.io/images/qfx-unl.png"></p>

<h2>EVPN L2 and L3 services</h2>

<p>EVPN standards define multiple routes types to distribute NLRI information across the network. The two most &ldquo;significant&rdquo; route types are 2 and 5. Type-2 NLRI was designed to carry the MAC (and optionally IP) address to VTEP IP binding information which is used to populate the dynamic MAC address table. This function, that was previously accomplished by a central SDN controller, is now performed in a scalable, standard-based, controller-independent fashion. <a href="http://www.juniper.net/documentation/en_US/junos16.1/topics/concept/evpn-route-type5-understanding.html">Type-5 NLRI</a> contains IP Prefix to VTEP IP mapping and is similar to the function of traditional L3 VPNs. In order to explore the capabilities of EVPN implementation on vQFX I&rsquo;ve created and artificial scenario with 3 virtual switches, 3 VLANs and 4 hosts.</p>

<p><img class="center" src="http://networkop.github.io/images/qfx-lab.png"></p>

<p>VLAN10 (green) is present on all 3 switches, VLAN20 (purple) is only configured on switches 1 and 2 and VLAN88 (red) only exists on SW3. I&rsquo;ve provided configuration snippets below for reference purposes only and only for SW1. Remaining switches are configured similarly.</p>

<h3>Configuring Basic IP and BGP setup</h3>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">set </span>interfaces xe-0/0/0 unit <span class="m">0</span> family inet address 12.12.12.1/24
</span><span class='line'><span class="nb">set </span>interfaces xe-0/0/2 unit <span class="m">0</span> family inet address 13.13.13.1/24
</span><span class='line'><span class="nb">set </span>interfaces lo0 unit <span class="m">0</span> family inet address 99.99.99.1/32
</span><span class='line'><span class="nb">set </span>routing-options static route 99.99.99.2/32 next-hop 12.12.12.2
</span><span class='line'><span class="nb">set </span>routing-options static route 99.99.99.3/32 next-hop 13.13.13.3
</span><span class='line'>
</span><span class='line'><span class="nb">set </span>routing-options router-id 99.99.99.1
</span><span class='line'><span class="nb">set </span>routing-options autonomous-system 555
</span><span class='line'>
</span><span class='line'><span class="nb">set </span>routing-options autonomous-system 555
</span><span class='line'><span class="nb">set </span>protocols bgp group EVPN <span class="nb">type </span>internal
</span><span class='line'><span class="nb">set </span>protocols bgp group EVPN <span class="nb">local</span>-address 99.99.99.1
</span><span class='line'><span class="nb">set </span>protocols bgp group EVPN family evpn signaling
</span><span class='line'><span class="nb">set </span>protocols bgp group EVPN neighbor 99.99.99.2
</span><span class='line'><span class="nb">set </span>protocols bgp group EVPN neighbor 99.99.99.3
</span></code></pre></td></tr></table></div></figure>


<h3>Configuring End-host connectivity and IRB</h3>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">set </span>vlans BD5010 vlan-id 10
</span><span class='line'><span class="nb">set </span>vlans BD5010 l3-interface irb.10
</span><span class='line'><span class="nb">set </span>vlans BD5020 vlan-id 20
</span><span class='line'><span class="nb">set </span>vlans BD5020 l3-interface irb.20
</span><span class='line'><span class="nb">set </span>interfaces xe-0/0/1 unit <span class="m">0</span> family ethernet-switching vlan members 10
</span><span class='line'><span class="nb">set </span>interfaces xe-0/0/3 unit <span class="m">0</span> family ethernet-switching vlan members 20
</span><span class='line'><span class="nb">set </span>interfaces irb unit <span class="m">10</span> family inet address 10.0.0.254/24
</span><span class='line'><span class="nb">set </span>interfaces irb unit <span class="m">20</span> family inet address 20.0.0.254/24
</span></code></pre></td></tr></table></div></figure>


<h3>Configuring L2 EVPN services</h3>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">set </span>protocols evpn encapsulation vxlan
</span><span class='line'><span class="nb">set </span>protocols evpn extended-vni-list all
</span><span class='line'><span class="nb">set </span>protocols evpn multicast-mode ingress-replication
</span><span class='line'>
</span><span class='line'><span class="nb">set </span>switch-options vtep-source-interface lo0.0
</span><span class='line'><span class="nb">set </span>switch-options route-distinguisher 555:0
</span><span class='line'><span class="nb">set </span>switch-options vrf-target target:555:123
</span><span class='line'>
</span><span class='line'><span class="nb">set </span>vlans BD5010 vxlan vni 5010
</span><span class='line'><span class="nb">set </span>vlans BD5010 vxlan ingress-node-replication
</span><span class='line'><span class="nb">set </span>vlans BD5020 vxlan vni 5020
</span><span class='line'><span class="nb">set </span>vlans BD5020 vxlan ingress-node-replication
</span></code></pre></td></tr></table></div></figure>


<h3>Configuring L3 EVPN service</h3>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF instance-type vrf
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF interface irb.10
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF interface irb.20
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF interface lo0.10
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF route-distinguisher 555:1
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF vrf-target target:123:5055
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF protocols evpn ip-prefix-routes advertise direct-nexthop
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF protocols evpn ip-prefix-routes encapsulation vxlan
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF protocols evpn ip-prefix-routes vni 5555
</span></code></pre></td></tr></table></div></figure>


<h2>Traffic flow overview</h2>

<p>Once all the nodes have been configured, we can have a closer look at the traffic flows, specifically at how packets are being forwarded and where the L2 and L3 lookups take place.</p>

<h3>L2 forwarding - H1 to H2 (00:50:79:66:68:06)</h3>

<p>Traffic from H1 to H2 will never leave its own broadcast domain. As soon as the packet hits the incoming interface of SW1, MAC address lookup occurs pointing to the remote VTEP interface of SW2.</p>

<figure class='code'><figcaption><span>SW1> show ethernet-switching table | match 00:50:79:66:68:06</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   BD5010              00:50:79:66:68:06   D        vtep.32769             99.99.99.2
</span></code></pre></td></tr></table></div></figure>


<p>Once SW2 decapsulates the packet, the lookup in the MAC address table returns the locally connected interface, where it gets forwarded next.</p>

<figure class='code'><figcaption><span>SW2> show ethernet-switching table | match 00:50:79:66:68:06</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   BD5010              00:50:79:66:68:06   D        xe-0/0/1.0
</span></code></pre></td></tr></table></div></figure>


<h3>L3 forwarding (symmetric) - H3 to H4</h3>

<p>The route to 8.8.8.0/24 is advertised by SW3 in type-5 NLRI</p>

<figure class='code'><figcaption><span>SW1> show route receive-protocol bgp 99.99.99.3 extensive</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>* 5:555:1::0::8.8.8.0::24/304 <span class="o">(</span><span class="m">1</span> entry, <span class="m">1</span> announced<span class="o">)</span>
</span><span class='line'>     Import Accepted
</span><span class='line'>     Route Distinguisher: 555:1
</span><span class='line'>     Route Label: 5555
</span><span class='line'>     Overlay gateway address: 0.0.0.0
</span><span class='line'>     Nexthop: 99.99.99.3
</span><span class='line'>     Localpref: 100
</span><span class='line'>     AS path: I
</span><span class='line'>     Communities: target:123:5055 encapsulation0:0:0:0:vxlan router-mac:02:05:86:71:72:00
</span></code></pre></td></tr></table></div></figure>


<p>This NLRI doesn&rsquo;t contain any overlay gateway address, however it does have a special &ldquo;router-mac&rdquo; community with a globally unique SW3&rsquo;s chassis MAC. This MAC is advertised as normal type-2 MAC address and points to the remote VTEP interface of SW3:</p>

<figure class='code'><figcaption><span>SW1> show ethernet-switching table | match 02:05:86:71:72:00</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   BD5010              02:05:86:71:72:00   D        vtep.32770             99.99.99.3
</span></code></pre></td></tr></table></div></figure>


<p>The above two pieces of information are fed into our EVPN-VRF routing table to produce the entry with the following parameters:</p>

<figure class='code'><figcaption><span>SW1> show route table EVPN-VRF.inet.0 detail 8.8.8.8 | match "VTEP|VNI|MAC"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Encap VNI: 5555, Decap VNI: 5555
</span><span class='line'>Source VTEP: 99.99.99.1, Destination VTEP: 99.99.99.3
</span><span class='line'>SMAC: 02:05:86:71:3b:00, DMAC: 02:05:86:71:72:00
</span></code></pre></td></tr></table></div></figure>


<p>This is the example of how &ldquo;symmetric&rdquo; IRB routing is performed. Instead of routing the packet at the ingress and switching at the egress node, how it was done in the case of Neutron&rsquo;s <a href="http://networkop.github.io/blog/2016/10/13/os-dvr/">DVR</a>, the routing is performed twice. First the packet is routed into a &ldquo;transit&rdquo; VNI 5555, which glues all the switches in the same EVI together from the L3 perspective. Once the packet reaches the destination node, it gets routed into the intended VNI (5088 in our case) and forwarded out the local interface. This way switches may have different sets of VLANs and IRBs and still be able route packets between VXLANs.</p>

<h3>L3 forwarding (asymmetric) - H1 to H4</h3>

<p>As you may have noticed, the green broadcast domain extends to all three switches, even though hosts are only attached to the first two. Let&rsquo;s see how it will affect the packet flows.
The flow from H1 to H4 will be similar to the one from H3 to H4 described above. However return packets will get routed on SW3 directly into VXLAN5010, since that switch has an IRB.10 interface and then switched all the way to H1.</p>

<figure class='code'><figcaption><span>SW3> show route forwarding-table destination 10.0.0.1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Routing table: EVPN-VRF.inet
</span><span class='line'>Internet:
</span><span class='line'>Destination        Type RtRef Next hop           Type Index    NhRef Netif
</span><span class='line'>10.0.0.1/32        dest     <span class="m">0</span> 0:50:79:66:68:5    ucst     <span class="m">1772</span>     <span class="m">1</span> vtep.32770
</span></code></pre></td></tr></table></div></figure>


<p>This is the example of &ldquo;asymmetric&rdquo; routing, similar to the one exhibited by Neutron <a href="http://networkop.github.io/blog/2016/10/13/os-dvr/">DVR</a>. You would see similar behaviour if you examined the flow between H3 and H2.</p>

<h2>Conclusion</h2>

<p>So why all the hassle configuring EPVN on data centre switches? For one, you can <a href="http://forums.juniper.net/t5/Data-Center-Technologists/MC-LAG-is-dead-Long-live-EVPN-Multi-homing/ba-p/298924">get rid</a> of MLAG in TOR switches and replace it with EVPN multihoming. However, the main benefit is that you can stretch L2 broadcast domains across your whole data centre without the need for an SDN controller. So, for example, we can now easily satisfy the requirement of having external floating IP network on all compute nodes introduced by <a href="http://networkop.github.io/blog/2016/10/13/os-dvr/">Neutron DVR</a>. EVPN-enabled switches can also now perform functions similar to DC gateway routers (the likes of ASR, MX or SR) while giving you the benefits of horizontal scaling of Leaf/Spine networks. As <a href="https://docs.cumulusnetworks.com/display/DOCS/Ethernet+Virtual+Private+Network+-+EVPN">more</a> and <a href="https://eos.arista.com/forum/evpn-control-plane-support-for-vxlan/">more</a> vendors introduce EVPN support, it is poised to become the ultimate DC routing protocol, complementing the functions already performed by the host-based virtual switches, and with all the DC switches <a href="http://networkop.github.io/blog/2016/09/09/os-lab-p2/">running BGP</a> already, introducing EVPN may be as easy as enabling a new address family.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStack SDN - Distributed Virtual Routing]]></title>
    <link href="http://networkop.github.io/blog/2016/10/13/os-dvr/"/>
    <updated>2016-10-13T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/10/13/os-dvr</id>
    <content type="html"><![CDATA[<p>In this post we&rsquo;ll explore how DVR is implemented in OpenStack Neutron and what are some of its benefits and shortcomings.</p>

<!--more-->


<p>To be honest I was a little hesitant to write this post because the topic of Neutron&rsquo;s DVR has already been <abbr title="beaten to death">exhaustively covered</abbr> by many, including <a href="https://assafmuller.com/category/dvr/">Assaf Muller</a>, <a href="http://blog.gampel.net/2014/12/openstack-neutron-distributed-virtual.html">Eran Gampel</a> and in the official OpenStack <a href="http://docs.openstack.org/mitaka/networking-guide/scenario-dvr-ovs.html">networking guide</a>. The coverage of the topic was so thorough that I barely had anything to add. However I still decided to write a DVR post of my own for the following two reasons:</p>

<ol>
<li>I often use my own posts as references and it&rsquo;s always easier for me to find information in my own writings.</li>
<li>I wanted to use this post as a reference platform for subsequent posts about dynamic routing and OVN project.</li>
</ol>


<p>The topic of Neutron&rsquo;s DVR is quite vast so I had to compromise between the length of this post and the level of details. In the end, I edited out most of the repeated content and replaced it with references to my older posts. I think I left everything that should be needed to follow along the narrative so hopefully it won&rsquo;t seem too patchy.</p>

<h2>Virtual topology overview</h2>

<p>Let&rsquo;s see what we&rsquo;re going to be dealing with in this post. This is a simple virtual topology with two VMs sitting in two different subnets. VM1 has a floating IP assigned that is used for external access.</p>

<p><img class="center" src="http://networkop.github.io/images/dvr-topo.png"></p>

<p>Before we get to the packet walk details, let me briefly describe how to build the above topology using Neutron CLI. I&rsquo;ll assume that OpenStack has just been installed and nothing has been configured yet, effectively we&rsquo;ll pick up from where we left our lab in the <a href="http://networkop.github.io/blog/2016/09/09/os-lab-p2/">previous post</a>.</p>

<h2>Virtual topology setup</h2>

<ol>
<li>Upload Cirros Linux image to OpenStack's image repository

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img | glance \
</span><span class='line'>     image-create --name='IMG-CIRROS' \
</span><span class='line'>     --visibility=public \
</span><span class='line'>     --container-format=bare \
</span><span class='line'>     --disk-format=qcow2</span></code></pre></td></tr></table></div></figure>
</li>
<li>Create 2 virtual subnets - RED and BLUE

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>neutron net-create NET-BLUE
</span><span class='line'>neutron subnet-create --name SUB-BLUE NET-BLUE 10.0.0.0/24 \
</span><span class='line'>  --dns-nameserver 8.8.8.8
</span><span class='line'>
</span><span class='line'>neutron net-create NET-RED
</span><span class='line'>neutron subnet-create --name SUB-RED NET-RED 10.0.1.0/24 \
</span><span class='line'>  --dns-nameserver 8.8.8.8</span></code></pre></td></tr></table></div></figure>
</li>
<li>Create external network

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>neutron net-create EXT-NET --provider:network_type flat \
</span><span class='line'>  --provider:physical_network extnet  \
</span><span class='line'>  --router:external \
</span><span class='line'>  --shared
</span><span class='line'>
</span><span class='line'>neutron subnet-create --name EXT-SUB \
</span><span class='line'> --enable_dhcp=False \
</span><span class='line'> --allocation-pool=start=169.254.0.50,end=169.254.0.99 \
</span><span class='line'> --gateway=169.254.0.1 EXT-NET 169.254.0.0/24</span></code></pre></td></tr></table></div></figure>
</li>

<li>Create a router and attach it to all three networks created above

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>neutron router-create R1
</span><span class='line'>neutron router-interface-add R1 SUB-RED
</span><span class='line'>neutron router-interface-add R1 SUB-BLUE
</span><span class='line'>neutron router-gateway-set R1 EXT-NET</span></code></pre></td></tr></table></div></figure>
</li>

<li>Create two host aggregates to spread the VMs across two different hosts

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nova aggregate-create AGG-RED AZ-RED
</span><span class='line'>nova aggregate-create AGG-BLUE AZ-BLUE
</span><span class='line'>nova aggregate-add-host AGG-BLUE compute-2
</span><span class='line'>nova aggregate-add-host AGG-RED compute-3</span></code></pre></td></tr></table></div></figure>
</li>

<li>Boot VMs on two different hypervisors

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nova boot --flavor m1.tiny --image 'IMG-CIRROS' \
</span><span class='line'>     --nic net-name=NET-BLUE \
</span><span class='line'>    --availability-zone AZ-BLUE \
</span><span class='line'>     VM1
</span><span class='line'>
</span><span class='line'>nova boot --flavor m1.tiny --image 'IMG-CIRROS' \
</span><span class='line'>    --nic net-name=NET-RED \
</span><span class='line'>    --availability-zone AZ-RED \
</span><span class='line'>    VM2</span></code></pre></td></tr></table></div></figure>
</li>

<li>Assign a floating IP (Static NAT) to VM1

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nova floating-ip-create EXT-NET
</span><span class='line'>nova floating-ip-associate VM1 169.254.0.55</span></code></pre></td></tr></table></div></figure>
</li>

<li>Enable ingress ICMP and SSH access

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nova secgroup-add-rule default tcp 22 22 0.0.0.0/0
</span><span class='line'>nova secgroup-add-rule default icmp -1 -1 0.0.0.0/0</span></code></pre></td></tr></table></div></figure>
</li>

<li>Make sure that both VMs are up and running.

<figure class='code'><figcaption><span>nova list</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>+--------------------------------------+------+--------+------------+-------------+----------------------------------+
</span><span class='line'><span class="p">|</span> ID                                   <span class="p">|</span> Name <span class="p">|</span> Status <span class="p">|</span> Task State <span class="p">|</span> Power State <span class="p">|</span> Networks                         <span class="p">|</span>
</span><span class='line'>+--------------------------------------+------+--------+------------+-------------+----------------------------------+
</span><span class='line'><span class="p">|</span> 92263ae8-43d1-4cd0-b271-2b11f0efbe7f <span class="p">|</span> VM1  <span class="p">|</span> ACTIVE <span class="p">|</span> -          <span class="p">|</span> Running     <span class="p">|</span> NET-BLUE<span class="o">=</span>10.0.0.12, 169.254.0.55 <span class="p">|</span>
</span><span class='line'><span class="p">|</span> b4562f24-2461-49fb-875b-fa1bf869dc4a <span class="p">|</span> VM2  <span class="p">|</span> ACTIVE <span class="p">|</span> -          <span class="p">|</span> Running     <span class="p">|</span> NET-RED<span class="o">=</span>10.0.1.4                 <span class="p">|</span>
</span><span class='line'>+--------------------------------------+------+--------+------------+-------------+----------------------------------+
</span></code></pre></td></tr></table></div></figure>
</li>
</ol>


<h2>non-DVR traffic flow</h2>

<p>Using the technique described in my <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">earlier post</a> I&rsquo;ve collected the dynamically allocated port numbers and created a physical representation of our virtual network.</p>

<p><img class="center" src="http://networkop.github.io/images/dvr-before.png"></p>

<p>For the sake of brevity I will omit the verification commands. The traffic flow between VM1 and VM2 will follow the standard path that I&rsquo;ve explored in my <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">native Neutron SDN post</a>.<br/>
It is obvious that in this case traffic flows are suboptimal. Instead of going directly between the peer compute nodes, the packet has to hairpin through a Neutron router. This adds to the end-to-end latency and creates unnecessary load on the Network node. These are one of the main reasons why Distributed Virtual Routing was introduced in OpenStack Juno.</p>

<h2>Enabling DVR</h2>

<p>Enabling DVR requires configuration changes of multiple files on all OpenStack nodes. At a high level, all compute nodes will now run Neutron&rsquo;s L3-agent service which will be responsible for provisioning of DVR and other auxiliary namespaces. The details of specific configuration options that need to be enabled can be found in the official OpenStack <a href="http://docs.openstack.org/mitaka/networking-guide/scenario-dvr-ovs.html">Networking guide</a>. As usual, I&rsquo;ve incorporated all the necessary changes into a single Chef <a href="https://github.com/networkop/chef-unl-os/tree/master/cookbooks/neutron">cookbook</a>, so in order to enable DVR in our lab all what you need to do is run the following commands from the UNetLab VM:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git pull origin master
</span><span class='line'>chef-client -z -E lab neutron.rb
</span></code></pre></td></tr></table></div></figure>


<p>Once all changes has been made, we need to either create a new router or update the existing one to enable the DVR functionality:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>neutron router-update --admin-state-up False --distributed True R1
</span><span class='line'>neutron router-update --admin-state-up True R1
</span></code></pre></td></tr></table></div></figure>


<h2>DVR East-West traffic flow</h2>

<p>Now let&rsquo;s see how the traffic flows have changed with the introduction of DVR.</p>

<p><img class="center" src="http://networkop.github.io/images/dvr-ew.png"></p>

<p>We&rsquo;re going to be examining the following traffic flow:</p>

<ul>
<li>From VM1 (10.0.0.12/fa:16:3e:83:92:96)</li>
<li>Via router R1 (10.0.0.1/fa:16:3e:72:7a:50; 10.0.1.1/fa:16:3e:6a:2c:8b)</li>
<li>To VM2 (10.0.1.4/fa:16:3e:76:31:68)</li>
</ul>


<p>R1 now has an instance on all compute nodes that have VMs in the BLUE or RED networks. That means that VM1 will send a packet directly to the R1&rsquo;s BLUE interface via the integration bridge.</p>

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">2</span>     <span class="m">1</span>  fa:16:3e:83:92:96    1
</span><span class='line'>    <span class="m">4</span>     <span class="m">1</span>  fa:16:3e:72:7a:50    1
</span><span class='line'>    <span class="m">5</span>     <span class="m">2</span>  fa:16:3e:6a:2c:8b    1
</span></code></pre></td></tr></table></div></figure>


<p>This is dynamically populated MAC address table of the integration bridge. You can see that the MAC address of VM1 and both interfaces of R1 have been learned. That means that when VM1 sends a packet to its default gateway&rsquo;s MAC address, it will go directly to R1&rsquo;s BLUE interface on port 4.</p>

<p>In this post I will omit the details of ARP resolution process which remains the same as <a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">before</a>, however there&rsquo;s one interesting detail that is worth mentioning before we move on. During the initial flood-and-learn phase on the <strong>br-int</strong>, the ARP request will get flooded down to the tunnel bridge. As per the standard behaviour, the packet should get replicated to all nodes. However, in this case we don&rsquo;t want to hear responses from other nodes, since the router is hosted locally. In order to help that, tunnel bridges explicitly drop all packets coming from integration bridges and destined for MAC addresses of locally hosted routers:</p>

<figure class='code'><figcaption><span>ovs-appctl ofproto/trace br-tun in_port=1,dl_vlan=1,dl_dst=fa:16:3e:72:7a:50 | grep -E "Rule|action"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xa3536ac94478bd1d <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>1
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>goto_table:1
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">1</span> <span class="nv">cookie</span><span class="o">=</span>0xa3536ac94478bd1d <span class="nv">priority</span><span class="o">=</span>2,dl_vlan<span class="o">=</span>1,dl_dst<span class="o">=</span>fa:16:3e:72:7a:50
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>drop
</span></code></pre></td></tr></table></div></figure>


<p>Getting back to our traffic flow, once the IP packet has reached the DVR instance of R1 on compute node #2, the routing lookup occurs and the packet is sent back to the integration bridge with a new source MAC of R1&rsquo;s RED interface.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip route</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>10.0.0.0/24 dev qr-102c4426-86  proto kernel  scope link  src 10.0.0.1
</span><span class='line'>10.0.1.0/24 dev qr-3779302e-62  proto kernel  scope link  src 10.0.1.1
</span></code></pre></td></tr></table></div></figure>


<p>Tunnel bridge will do its usual work by locating the target compute node based on the destination MAC address of VM2 (DVR requires <a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">L2 population</a> to be enabled) and will send the packet directly to the compute node #3.</p>

<figure class='code'><figcaption><span>ovs-appctl ofproto/trace br-tun in_port=1,dl_vlan=2,dl_src=fa:16:3e:6a:2c:8b,dl_dst=fa:16:3e:76:31:68 | grep -E "Rule|action"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xa3536ac94478bd1d <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>1
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>goto_table:1
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">1</span> <span class="nv">cookie</span><span class="o">=</span>0xa3536ac94478bd1d <span class="nv">priority</span><span class="o">=</span>1,dl_vlan<span class="o">=</span>2,dl_src<span class="o">=</span>fa:16:3e:6a:2c:8b
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>set_field:fa:16:3f:d3:10:60-&gt;eth_src,goto_table:2
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">2</span> <span class="nv">cookie</span><span class="o">=</span>0xa3536ac94478bd1d <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>goto_table:20
</span><span class='line'>                        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">20</span> <span class="nv">cookie</span><span class="o">=</span>0xa3536ac94478bd1d <span class="nv">priority</span><span class="o">=</span>2,dl_vlan<span class="o">=</span>2,dl_dst<span class="o">=</span>fa:16:3e:76:31:68
</span><span class='line'>                        OpenFlow <span class="nv">actions</span><span class="o">=</span>pop_vlan,set_field:0x4d-&gt;tun_id,output:3
</span></code></pre></td></tr></table></div></figure>


<p>Since all instances of R1 have the same set of IP/MAC addresses, the MAC address of a local router can be learned by the remote integration bridge hosting the same instance of DVR. In order to prevent that from happening, the sending <strong>br-tun</strong> replaces the source MAC address of the frame with the <code>set_field:fa:16:3f:d3:10:60-&gt;eth_src</code> action. This way the real R1&rsquo;s MAC address gets masked as the frame leaves the node. These &ldquo;mask&rdquo; MACs are generated by and learned from the Neutron server, which ensures that each node gets a unique address.</p>

<p>The receiving node&rsquo;s <strong>br-tun</strong> will swap the VXLAN header with a VLAN ID and forward the frame up to the integration bridge.</p>

<figure class='code'><figcaption><span>ovs-appctl ofproto/trace br-tun in_port=3,tun_id=0x4d,dl_dst=fa:16:3e:76:31:68 | grep -E "Rule|action"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0x8a7dedf35101427f <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>3
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>goto_table:4
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">4</span> <span class="nv">cookie</span><span class="o">=</span>0x8a7dedf35101427f <span class="nv">priority</span><span class="o">=</span>1,tun_id<span class="o">=</span>0x4d
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>push_vlan:0x8100,set_field:4097-&gt;vlan_vid,goto_table:9
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">9</span> <span class="nv">cookie</span><span class="o">=</span>0x8a7dedf35101427f <span class="nv">priority</span><span class="o">=</span>0
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>goto_table:10
</span><span class='line'>                        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">10</span> <span class="nv">cookie</span><span class="o">=</span>0x8a7dedf35101427f <span class="nv">priority</span><span class="o">=</span>1
</span><span class='line'>                        OpenFlow <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,cookie<span class="o">=</span>0x8a7dedf35101427f,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:OXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span><span class='line'>                                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0x9a1e0026794eadc5 <span class="nv">priority</span><span class="o">=</span>1
</span><span class='line'>                                OpenFlow <span class="nv">actions</span><span class="o">=</span>NORMAL
</span></code></pre></td></tr></table></div></figure>


<p>Integration bridge of compute node #3 will lookup the destination MAC address and send the packet out port 2.</p>

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">2</span>     <span class="m">1</span>  fa:16:3e:76:31:68    0
</span><span class='line'>    <span class="m">4</span>     <span class="m">2</span>  fa:16:3e:72:7a:50    0
</span><span class='line'>    <span class="m">5</span>     <span class="m">1</span>  fa:16:3e:6a:2c:8b    0
</span><span class='line'>    <span class="m">1</span>     <span class="m">1</span>  fa:16:3e:29:de:20    0
</span></code></pre></td></tr></table></div></figure>


<p>The reverse packet flow is similar - the packet will get routed on the compute node #3 and sent in a BLUE network to the compute node #2.</p>

<h2>External connectivity</h2>

<p>External connectivity will be very different for VMs with and without a floating IP. We will examine each case individually.</p>

<h3>Case 1 - Overload NAT (VM2 with no FIP)</h3>

<p><img class="center" src="http://networkop.github.io/images/dvr-snat.png"></p>

<p>External connectivity for VMs with no floating IP is still performed by the Network node. This time however, NATing is performed by a new element - SNAT namespace. As per the normal behaviour, VM2 will send a packet to its default gateway first. Let&rsquo;s have a closer look at the routing table of the DVR:</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip route</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>10.0.0.0/24 dev qr-102c4426-86  proto kernel  scope link  src 10.0.0.1
</span><span class='line'>10.0.1.0/24 dev qr-3779302e-62  proto kernel  scope link  src 10.0.1.1
</span></code></pre></td></tr></table></div></figure>


<p>There&rsquo;s no default route in the main routing table, so how would it get routed out? DVRs extensively use <a href="http://linux-ip.net/html/tools-ip-rule.html">Linux routing policy database</a> (RPDB), a feature that has a lot in common with OpenFlow tables. The principle of RPDB is that every packet gets matched against a set of routing tables until there&rsquo;s a hit. The tables are checked in the order of their priority (lowest to highest). One of the main features of RPDB is the ability to perform matches based on something other than the destination IP address, which is why it&rsquo;s often referred to as policy-based routing. To view the contents of RPDB use the <code>ip rule</code> command under the DVR namespace:</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip rule</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>0:      from all lookup <span class="nb">local</span>
</span><span class='line'>32766:  from all lookup main
</span><span class='line'>32767:  from all lookup default
</span><span class='line'>167772161:      from 10.0.0.1/24 lookup 167772161
</span><span class='line'>167772417:      from 10.0.1.1/24 lookup 167772417
</span></code></pre></td></tr></table></div></figure>


<p>In our case table 167772161 matches all packets sourced from the BLUE subnet and if we examine the corresponding routing table we&rsquo;ll find the missing default route there.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip route list table 167772417</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>default via 10.0.1.12 dev qr-3779302e-62
</span></code></pre></td></tr></table></div></figure>


<p>The next hop of this default route points to the SNAT&rsquo;s interface in the BLUE network. MAC address is statically programmed by the local L3-agent.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip neigh | grep 10.0.1.12</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>10.0.1.12 dev qr-3779302e-62 lladdr fa:16:3e:29:de:20 PERMANENT
</span></code></pre></td></tr></table></div></figure>


<p>Integration bridge sends the packet out port 1 to the tunnel bridge.</p>

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int | grep fa:16:3e:29:de:20</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="m">1</span>     <span class="m">1</span>  fa:16:3e:29:de:20    1
</span></code></pre></td></tr></table></div></figure>


<p>Tunnel bridge finds the corresponding match and sends the VXLAN-encapsulated packet to the Network node.</p>

<figure class='code'><figcaption><span>ovs-appctl ofproto/trace br-tun in_port=1,dl_vlan=1,dl_dst=fa:16:3e:29:de:20 | tail -n 1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Datapath actions: <span class="nb">set</span><span class="o">(</span>tunnel<span class="o">(</span><span class="nv">tun_id</span><span class="o">=</span>0x4d,src<span class="o">=</span>10.0.0.4,dst<span class="o">=</span>10.0.0.0,ttl<span class="o">=</span>64,flags<span class="o">(</span>df<span class="p">|</span>key<span class="o">)))</span>,pop_vlan,3
</span></code></pre></td></tr></table></div></figure>


<p>Tunnel bridge of the Network node forwards the frame up to the integration bridge.</p>

<figure class='code'><figcaption><span>ovs-appctl ofproto/trace br-tun in_port=3,tun_id=0x4d,dl_dst=fa:16:3e:29:de:20 | grep output</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,cookie<span class="o">=</span>0xb9be3fe62922c800,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:OXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span></code></pre></td></tr></table></div></figure>


<p>Integration bridge sends the frame to port 10, which is where SNAT namespace is attached</p>

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int | grep fa:16:3e:29:de:20</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="m">10</span>     <span class="m">1</span>  fa:16:3e:29:de:20    0
</span></code></pre></td></tr></table></div></figure>


<p>SNAT is a namespace with an interface in each of the subnets - BLUE, RED and External subnet</p>

<figure class='code'><figcaption><span>ip netns exec snat-uuid ip a | grep -E "UP|inet"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>16: sg-fefd493b-a5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1450</span> qdisc noqueue state UNKNOWN
</span><span class='line'>    link/ether fa:16:3e:99:5c:3a brd ff:ff:ff:ff:ff:ff
</span><span class='line'>    inet 10.0.0.6/24 brd 10.0.0.255 scope global sg-fefd493b-a5
</span><span class='line'>18: sg-b3d58360-b4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1450</span> qdisc noqueue state UNKNOWN
</span><span class='line'>    link/ether fa:16:3e:29:de:20 brd ff:ff:ff:ff:ff:ff
</span><span class='line'>    inet 10.0.1.12/24 brd 10.0.1.255 scope global sg-b3d58360-b4
</span><span class='line'>19: qg-765b5aca-ce: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UNKNOWN
</span><span class='line'>    link/ether fa:16:3e:d5:75:0e brd ff:ff:ff:ff:ff:ff
</span><span class='line'>    inet 169.254.0.57/24 brd 169.254.0.255 scope global qg-765b5aca-ce
</span></code></pre></td></tr></table></div></figure>


<p>SNAT has a single default route pointing to the External network&rsquo;s gateway.</p>

<figure class='code'><figcaption><span>ip netns exec snat-uuid ip route | grep default</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>default via 169.254.0.1 dev qg-765b5aca-ce
</span></code></pre></td></tr></table></div></figure>


<p>Before sending the packet out, iptables will NAT the packet to hide it behind SNAT&rsquo;s <strong>qg</strong> external interface IP.</p>

<figure class='code'><figcaption><span>ip netns exec snat-uuid iptables -t nat -L | grep SNAT</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>SNAT       all  --  anywhere             anywhere             to:169.254.0.57
</span></code></pre></td></tr></table></div></figure>


<h3>Case 2 - Static NAT (VM1 with FIP)</h3>

<p><img class="center" src="http://networkop.github.io/images/dvr-dnat.png"></p>

<p>The first step in this scenario is the same - VM1 sends a packet to the MAC address of its default gateway. As before, the default route is missing in the main routing table.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip route list table main</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>10.0.0.0/24 dev qr-102c4426-86  proto kernel  scope link  src 10.0.0.1
</span><span class='line'>10.0.1.0/24 dev qr-3779302e-62  proto kernel  scope link  src 10.0.1.1
</span><span class='line'>169.254.106.114/31 dev rfp-e4d4897e-7  proto kernel  scope link  src 169.254.106.114
</span></code></pre></td></tr></table></div></figure>


<p>Looking at the <strong>ip rule</strong> configuration we can find that table 16 matches all packets from that particular VM (10.0.0.12).</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip rule</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>0:      from all lookup <span class="nb">local</span>
</span><span class='line'>32766:  from all lookup main
</span><span class='line'>32767:  from all lookup default
</span><span class='line'>57481:  from 10.0.0.12 lookup 16
</span><span class='line'>167772161:      from 10.0.0.1/24 lookup 167772161
</span><span class='line'>167772417:      from 10.0.1.1/24 lookup 167772417
</span></code></pre></td></tr></table></div></figure>


<p>Routing table 16 sends the packet via a point-to-point veth pair link to the FIP namespace.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip route list table 16</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>default via 169.254.106.115 dev rfp-e4d4897e-7
</span></code></pre></td></tr></table></div></figure>


<p>Before sending the packet out, DVR translates the source IP of the packet to the FIP assigned to that VM.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid iptables -t nat -L | grep NAT</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>SNAT       all  --  10.0.0.12            anywhere             to:169.254.0.55
</span></code></pre></td></tr></table></div></figure>


<p>A FIP namespace is a simple router designed to connect multiple DVRs to external network. This way all routers can share the same &ldquo;uplink&rdquo; namespace and don&rsquo;t have to consume valuable addresses from external subnet.</p>

<figure class='code'><figcaption><span>ip netns exec fip-uuid ip a | grep -E "UP|inet"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>2: fpr-e4d4897e-7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP qlen 1000
</span><span class='line'>    inet 169.254.106.115/31 scope global fpr-e4d4897e-7
</span><span class='line'>15: <span class="nb">fg</span>-d3bb699d-af: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UNKNOWN
</span><span class='line'>    inet 169.254.0.58/24 brd 169.254.0.255 scope global <span class="nb">fg</span>-d3bb699d-af
</span></code></pre></td></tr></table></div></figure>


<p>Default route inside the FIP namespace points to the External subnet&rsquo;s gateway IP.</p>

<figure class='code'><figcaption><span>ip netns exec fip-uuid ip route | grep default</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>default via 169.254.0.1 dev <span class="nb">fg</span>-d3bb699d-af
</span></code></pre></td></tr></table></div></figure>


<p>The MAC address of the gateway is statically configured by the L3 agent.</p>

<figure class='code'><figcaption><span>ip netns exec fip-uuid ip neigh | grep 169.254.0.1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>169.254.0.1 dev <span class="nb">fg</span>-d3bb699d-af lladdr 32:3e:7d:13:ca:78 DELAY
</span></code></pre></td></tr></table></div></figure>


<p>The packet is sent to the <strong>br-int</strong> with the destination MAC address of the default gateway, which is learned on port 3.</p>

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int | grep 32:3e:7d:13:ca:78</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>  <span class="m">3</span>     <span class="m">3</span>  32:3e:7d:13:ca:78    1
</span></code></pre></td></tr></table></div></figure>


<p>External bridge strips the VLAN ID of the packet coming from the <strong>br-int</strong> and does the lookup in the dynamic MAC address table.</p>

<figure class='code'><figcaption><span>ovs-appctl ofproto/trace br-ex in_port=2,dl_vlan=3 | grep actions=</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>pop_vlan,NORMAL
</span></code></pre></td></tr></table></div></figure>


<p>The frame is forwarded out the physical interface.</p>

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-ex | grep 32:3e:7d:13:ca:78</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="m">1</span>     <span class="m">0</span>  32:3e:7d:13:ca:78    1
</span></code></pre></td></tr></table></div></figure>


<p>Reverse packet flow will be quite similar, however in this case FIP namespace must be able to respond to ARP requests for the IPs that only exist on DVRs. In order to do that, it uses a proxy-ARP feature. First, L3 agent installs a static route for the FIP pointing back to the correct DVR over the veth pair interface:</p>

<figure class='code'><figcaption><span>ip netns exec fip-uuid ip route get 169.254.0.55</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>169.254.0.55 via 169.254.106.114 dev fpr-e4d4897e-7  src 169.254.106.115
</span></code></pre></td></tr></table></div></figure>


<p>Now that the FIP namespace knows the route to the floating IP, it can respond to ARPs on behalf of DVR as long as proxy-ARP is enabled on the external <strong>fg</strong> interface:</p>

<figure class='code'><figcaption><span>ip netns exec fip-uuid</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat /proc/sys/net/ipv4/conf/fg-d3bb699d-af/proxy_arp
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure>


<p>Finally, the DVR NATs the packet back to its internal IP in the BLUE subnet and forwards it straight to VM1.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid iptables -t nat -L | grep DNAT</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>DNAT       all  --  anywhere             169.254.0.55         to:10.0.0.12
</span></code></pre></td></tr></table></div></figure>


<h2>DVR Pros and Cons</h2>

<p>Without a doubt DVR has introduced a number of much needed <strong>improvements</strong> to OpenStack networking:</p>

<ul>
<li>East-West traffic now follows the most optimal path thereby reducing the load on the Network node.</li>
<li>External connectivity to floating IPs now also follows the most optimal path directly to the compute node hosting the VM.</li>
</ul>


<p>However, there&rsquo;s a number of <strong>issues</strong> that either remain unaddressed or result directly from the current DVR architecture:</p>

<ul>
<li>DHCP and SNAT are still hosted on the Network node.</li>
<li>Asymmetric routing means that every DVR needs to have an interface in every configured subnet, even when there are no VMs that belong to those subnets on the current compute node.</li>
<li>Direct connectivity to FIP means that all compute nodes now need to have direct L2 adjacency to external subnets.</li>
<li>FIP namespace on compute nodes consumes IP addresses from external subnets which can be a problem if external subnet is in a public IPv4 address range.</li>
<li>DVR implementation as a network namespace creates additional overhead in packet processing.</li>
</ul>


<p>Some of the above issues are not critical and can be fixed with a little effort:</p>

<ul>
<li>In order to reduce the scope of a External network VLAN span inside the DC, dedicate a subset of hosts that will have a direct L2 adjacency to external networks and only deploy external-facing VMs on those hosts.</li>
<li>Since FIP namespace only requires an external IP address for <a href="http://lists.openstack.org/pipermail/openstack-dev/2016-June/096386.html">debugging purposes</a>, we can create an additional, secondary, subnet in RFC1918 space for FIP connectivity. This is enabled by a feature called subnet <a href="https://specs.openstack.org/openstack/neutron-specs/specs/newton/subnet-service-types.html">&ldquo;Service types&rdquo;</a> and is <a href="https://github.com/openstack/neutron-specs/blob/master/specs/newton/subnet-service-types.rst">available</a> in the latest Newton release.</li>
</ul>


<p>However the main issue still remains unresolved. Every North-South packet has to hop several times between the global and DVR/FIP/NAT namespaces. These kind of operations are very expensive in terms of consumed CPU and memory resources and can be very detrimental to network performance. Using namespaces may be the most straight-forward and non-disruptive way of implementing DVR, however it&rsquo;s definitely not the most optimal. Ideally we&rsquo;d like to see both L2 and L3 pipelines implemented in OpenvSwitch tables. This way all packets can benefit from OVS <a href="https://networkheresy.com/2014/11/13/accelerating-open-vswitch-to-ludicrous-speed/">fast-path flow caching</a>. But fear not, the solution to this already exists in a shape of <a href="https://www.openstack.org/summit/vancouver-2015/summit-videos/presentation/ovn-native-virtual-networking-for-open-vswitch">Open Virtual Network</a>. OVN is a project spawned from the OVS and aims to <a href="https://blog.russellbryant.net/2016/09/29/ovs-2-6-and-the-first-release-of-ovn/">address</a> a number of shortcomings existing in current implementations of virtual networks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automating the Build of OpenStack Lab (Part 2)]]></title>
    <link href="http://networkop.github.io/blog/2016/09/09/os-lab-p2/"/>
    <updated>2016-09-09T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/09/09/os-lab-p2</id>
    <content type="html"><![CDATA[<p>In this post we&rsquo;ll use Chef, unnumbered BGP and Cumulus VX to build a massively scalable &ldquo;Lapukhov&rdquo; Leaf-Spine data centre.</p>

<!--more-->


<hr />

<p>In the <a href="http://networkop.github.io/blog/2016/08/26/os-lab-p1/">last post</a> we&rsquo;ve seen how to use Chef to automate the build of a 3-node OpenStack cloud. The only thing remaining is to build an underlay network supporting communication between the nodes, which is what we&rsquo;re going to do next. The build process will, again, be relatively simple and will include only a few manual steps, but before we get there let me go over some of the decisions and assumptions I&rsquo;ve made in my network design.</p>

<h2>High-level design</h2>

<p>The need to provide more bandwidth for East-West traffic has made the Clos Leaf-Spine architecture a de facto standard in any data centre network design. The use of virtual overlay networks has obviated the requirement to have a strict VLAN and IP numbering schemes in the underlay. The only requirement for the compute nodes now is to have any-to-any layer 3 connectivity. This is how the underlay network design has converged to a Layer 3 Leaf-Spine architecture.<br/>
The choice of a routing protocol is not so straight-forward. My fellow countryman Petr Lapukhov and co-authors of <a href="https://tools.ietf.org/html/draft-ietf-rtgwg-bgp-routi3ng-large-dc-11">RFC draft</a> claim that having a single routing protocol in your WAN and DC reduces complexity and makes interoperability and operations a lot easier. This draft presents some of the design principles that can be used to build a L3 data centre with BGP as the only routing protocol. In our lab we&rsquo;re going to implement a single &ldquo;cluster&rdquo; of the multi-tier topology proposed in that RFC.</p>

<p><img class="center" src="http://networkop.github.io/images/os-lab-chef-full.png"></p>

<p>In order to help us build this in an automated and scalable way, we&rsquo;re going to use a relatively new feature called <strong>unnumbered BGP</strong>.</p>

<h2>Unnumbered BGP as a replacement for IGP</h2>

<p>As we all know, one of the main advantages of interior gateway protocols is the automatic discovery of adjacent routers which is accomplished with the help of link-local multicasts. On the other hand, BGP traditionally required you to explicitly define neighbor&rsquo;s IP address in order to establish a peering relationship with it. This is where IPv6 comes to the rescue. With the help of neighbor discovery protocol and router advertisement messages, it becomes possible to accurately determine the address of the peer BGP router on an intra-fabric link. The only question is how we would exchange IPv4 information over and IPv6-only BGP network.<br/>
<a href="https://tools.ietf.org/html/rfc5549">RFC 5549</a>, described an &ldquo;extended nexthop encoding capability&rdquo; which allows BGP to exchange routing updates with nexthops that don&rsquo;t belong to the address family of the advertised prefix. In plain English it means that BGP is now capable of advertising an IPV4 prefix with an IPv6 nexthop. This makes it possible to configure all transit links inside the Clos fabric with IPv6 link-local addresses and still maintain reachability between the edge IPv4 host networks. Since nexthop IPs will get updated at every hop, there is no need for an underlying IGP to distribute them between all BGP routers. What we see is, effectively, BGP <strong>absorbing</strong> the functions of an IGP protocol inside the data centre.</p>

<h2>Configuration example on Cumulus VX</h2>

<p>In order to implement BGP unnumbered on Cumulus Linux all you need to is:</p>

<ol>
<li>Enable IPv6 router advertisements on all transit links</li>
<li>Enable BGP on the same interfaces</li>
</ol>


<p>Example Quagga configuration snippet will look like this:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>interface swp1
</span><span class='line'>  ipv6 nd ra-interval 5
</span><span class='line'>  no ipv6 nd suppress-ra
</span><span class='line'>
</span><span class='line'>rouer bgp &lt;ASN&gt;
</span><span class='line'>  neighbor swp1 interface
</span><span class='line'>  neighbor swp1 external
</span></code></pre></td></tr></table></div></figure>


<p>As you can see, Cumulus simplifies it even more by allowing you to only specify the BGP peering type (external/internal) and learning the value of peer BGP AS dynamically from a neighbor.</p>

<h2>Design assumptions and caveats</h2>

<p>With all the above in mind, this is the list of decisions I&rsquo;ve made while building the fabric configuration:</p>

<ul>
<li>All switches inside the fabric will be running BGP peerings using <strong>IPv6 link-local</strong> addresses</li>
<li><strong>eBGP</strong> will be used throughout to simplify configuration automation (all peers will be external)</li>
<li>Each Leaf/Spine switch will have a <strong>unique IPv4 loopback</strong> address assigned for management purposes (ICMP, SSH)</li>
<li>On each Leaf switch <strong>all directly connected IPv4</strong> prefixes will get redistributed into BGP</li>
<li>BGP multipath rule will be &ldquo;relaxed&rdquo; to allow for different AS-PATHs. This is not used in our current topology but is required in an HA Leaf switch design (same IPv4 prefix will be advertised from two Leaf switches with different ASN)</li>
<li>Loop prevention on Leaf switches will also be &ldquo;relaxed&rdquo;. This, again, is not used in our single &ldquo;cluster&rdquo; topology, however it will allow same Leaf ASNs to be reused in a different cluster.</li>
</ul>


<h2>Implementation steps</h2>

<p>Picking up where we left off after the OpenStack node provisioning described in the <a href="http://networkop.github.io/blog/2016/08/26/os-lab-p1/">previous post</a></p>

<ol>
<li><p>Get the latest <a href="https://github.com/networkop/chef-unl-os">OpenStack lab cookbooks</a></p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    git clone <a href="https://github.com/networkop/chef-unl-os.git">https://github.com/networkop/chef-unl-os.git</a>
</span><span class='line'>    <span class="nb">cd </span>chef-unl-os
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p><a href="https://cumulusnetworks.com/cumulus-vx/">Download</a> and import Cumulus VX image similar to how it&rsquo;s described <a href="http://www.unetlab.com/2015/06/adding-cisco-asav-images/">here</a>.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    /opt/unetlab/addons/qemu/cumulus-vx/hda.qcow2
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Build the topology inside UNL. Make sure that Node IDs inside UNL match the ones in <strong>chef-unl-os/environment/lab.rb</strong> file and that interfaces are connected as shown in the diagram below</p>

<p> <img class="center" src="http://networkop.github.io/images/os-lab-unl.png"></p></li>
<li><p>Re-run UNL self-provisioning cookbook to create a <a href="https://github.com/networkop/chef-unl-os/blob/master/cookbooks/pxe/templates/ztp.erb">zero touch provisioning</a> file and update DHCP server configuration with static entries for the switches.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    chef-client -z -E lab -o pxe
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  Cumulus <a href="https://docs.cumulusnetworks.com/display/DOCS/Zero+Touch+Provisioning+-+ZTP">ZTP</a> allows you to run a predefined script on the first boot of the operating system. In our case we inject a UNL VM&rsquo;s public key and enable passwordless <strong>sudo</strong> for cumulus user.</p></li>
<li><p>Kickoff Chef provisioning to bootstrap and configure the DC fabric.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    chef-client -z -E lab fabric.rb
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  This command instructs Chef provisioning to connect to each switch, download and install the Chef client and run a simple recipe to create quagga configuration file from a template.</p></li>
</ol>


<p>At the end of step 5 we should have a fully functional BGP-only fabric and all 3 compute nodes should be able to reach each other in at most 4 hops.</p>

<figure class='code'><figcaption><span>[root@controller-1 ~]# traceroute 10.0.0.4</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>traceroute to 10.0.0.4 <span class="o">(</span>10.0.0.4<span class="o">)</span>, <span class="m">30</span> hops max, <span class="m">60</span> byte packets
</span><span class='line'> <span class="m">1</span>  10.0.0.1 <span class="o">(</span>10.0.0.1<span class="o">)</span>  0.609 ms  0.589 ms  0.836 ms
</span><span class='line'> <span class="m">2</span>  10.255.255.7 <span class="o">(</span>10.255.255.7<span class="o">)</span>  0.875 ms  2.957 ms  3.083 ms
</span><span class='line'> <span class="m">3</span>  10.255.255.6 <span class="o">(</span>10.255.255.6<span class="o">)</span>  3.473 ms  5.486 ms  3.147 ms
</span><span class='line'> <span class="m">4</span>  10.0.0.4 <span class="o">(</span>10.0.0.4<span class="o">)</span>  4.231 ms  4.159 ms  4.115 ms
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automating the Build of OpenStack Lab (Part 1)]]></title>
    <link href="http://networkop.github.io/blog/2016/08/26/os-lab-p1/"/>
    <updated>2016-08-26T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/08/26/os-lab-p1</id>
    <content type="html"><![CDATA[<p>In this post we will explore what&rsquo;s required to perform a zero-touch deployment of an OpenStack cloud. We&rsquo;ll get a 3-node lab up and running inside UNetLab with just a few commands.</p>

<!--more-->


<hr />

<p>Now that I&rsquo;m finally beginning to settle down at my new place of residence I can start spending more time on research and blogging. I have left off right before I was about to start exploring the native OpenStack distributed virtual routing function. However as I&rsquo;d started rebuilding my OpenStack lab from scratch I realised that I was doing a lot of repetitive tasks which can be easily automated. Couple that with the fact that I needed to learn Chef for my new work and you&rsquo;ve got this blogpost describing a few Chef <a href="https://github.com/networkop/chef-unl-os.git">cookbooks</a> (similar to Ansible&rsquo;s playbook) automating all those manual steps described in my earlier blogposts <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">1</a> and <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">2</a>.<br/>
In addition to that in this post I&rsquo;ll show how to build a very simple OpenStack baremetal provisioner and installer. Some examples of production-grade baremetal provisioners are <a href="https://wiki.openstack.org/wiki/Ironic">Ironic</a>, <a href="http://crowbar.github.io/">Crowbar</a> and <a href="http://maas.io/">MAAS</a>. In our case we&rsquo;ll turn UNetLab VM into an <strong>undercloud</strong>, a server used to provision and deploy our OpenStack lab, an <strong>overcloud</strong>. To do that we&rsquo;ll first install and configure DHCP, TFTP and Apache servers to PXE-boot our UNL OpenStack nodes. Once all the nodes are bootstrapped, we&rsquo;ll use Chef to configure the server networking and kickoff the packstack OpenStack installer.</p>

<p><img class="center" src="http://networkop.github.io/images/os-lab-chef.png"></p>

<p>In this post I&rsquo;ll try to use Chef recipes that I&rsquo;ve written as much as possible, therefore you won&rsquo;t see the actual configuration commands, e.g. how to configure Apache or DHCP servers. However I will try to describe everything that happens at each step and hopefully that will provide enough incentive for the curious to look into the Chef code and see how it&rsquo;s done. To help with the Chef code understanding let me start with a brief overview of what to look for in a cookbook.</p>

<h2>How to read a Chef cookbook (Optional)</h2>

<p>A cookbook directory (<strong>/cookbooks/[cookbook_name]</strong>) contains all its configuration scripts in <strong>/recipes</strong>. Each file inside a recipe contains a list of steps to be performed on a server. Each step is an operation (add/delete/update) on a <strong>resource</strong>. Here are some of the common Chef resources:</p>

<ul>
<li>Package - allows you to add, remove or update a package</li>
<li>Template - creates a file from an <strong>erb</strong>-formatted template</li>
<li>Execute - runs an ad-hoc CLI command</li>
</ul>


<p>Just these three basic resources allow you to do 95% of administrative tasks on any server. Most importantly they do it in platform-independent (any flavour of Linux) and idempotent (only make changes if current state is different from a desired state) way. Other directories you might want to explore are:</p>

<ul>
<li>/templates - contains all the <strong>erb</strong>-formatted templates</li>
<li>/attributes - contains recipe variables (file paths, urls etc.)</li>
<li>/files - contains the non-template files, i.e. files with static content</li>
</ul>


<h2>Bootstrapping the OpenStack nodes</h2>

<ol>
<li><p>If you haven&rsquo;t done it yet, download a copy of the <strong>UNetLab VM</strong> from the <a href="http://www.unetlab.com/">official website</a>. Set it up inside your hypervisor so that you can access Internet through the first interface <strong>pnet0</strong> (i.e. connect the first NIC of the VM to hypervisor&rsquo;s NAT interface). Make sure the VM has got at least 6GB of RAM and VT-x support enabled for nested virtualization.</p></li>
<li><p>Follow the official <a href="https://downloads.chef.io/chef-dk/">installation instructions</a> to <strong>install Chef Development Kit</strong> inside UNetLab VM.</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   wget <a href="https://packages.chef.io/stable/ubuntu/12.04/chefdk_0.16.28-1_amd64.deb">https://packages.chef.io/stable/ubuntu/12.04/chefdk_0.16.28-1_amd64.deb</a>
</span><span class='line'>   dpkg -i chefdk_0.16.28-1_amd64.deb
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p><strong>Install git</strong> and clone <a href="https://github.com/networkop/chef-unl-os.git">chef cookbooks</a>.</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   apt-get -y update
</span><span class='line'>   apt-get -y install git
</span><span class='line'>   git clone <a href="https://github.com/networkop/chef-unl-os.git">https://github.com/networkop/chef-unl-os.git</a>
</span><span class='line'>   <span class="nb">cd </span>chef-unl-os
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Examine the lab <strong>environment settings</strong> to see what values are going to be used. You can modify that file to your liking.</p>

<blockquote><p>Note that the OpenStack node IDs (keys of <em>os_lab</em> hash) MUST have one to one correspondence with the UNL node IDs which will be created at step 5</p></blockquote>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   cat environment/lab.rb
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Run Chef against a local server to setup the <strong>baremetal provisioner</strong>. This step installs and configures DHCP, TFTP and Apache servers. It also creates all the necessary PXE-boot and kickstart files based on our environment settings. Note that a part of the process is the download of a 700MB CentOS image so it might take a while to complete.</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   chef-client -z -E lab -o pxe
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p> At the start of the PXE-boot process, DCHP server sends an OFFER which, along with the standard IP information, includes the name of the PXE boot image and the IP address of TFTP server where to get it from. A server loads this image and then searches the TFTP server for the boot configuration file which tells it what kernel to load and where to get a kickstart file. Both kickstart and the actual installation files are accessed via HTTP and served by the same Apache server that runs UNL GUI.</p></li>
<li><p>From <strong>UNL GUI</strong> create a new lab, add 3 OpenStack nodes and connect them all to <strong>pnet10</strong> interface as described in <a href="http://www.unetlab.com/2014/11/using-cloud-devices/">this guide</a>. Note that the <strong>pnet10</strong> interface has already been created by Chef so you don&rsquo;t have to re-create it again.</p>

<blockquote><p>Make sure that the UNL node IDs match the ones defined in the environment setting file</p></blockquote></li>
<li><p>Fire-up the nodes and watch them being bootstrapped by our UNL VM.</p></li>
</ol>


<h2>Server provisioning</h2>

<p>Next step is to configure the server networking and kickoff the OpenStack installer. These steps will also be done with a single command:</p>

<p>   <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   chef-client -z -E lab lab.rb
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>
The first part of this script will connect to each prospective OpenStack node and setup its network interfaces and hostnames. The second part of this script will generate a packstack answer file and modify its settings to exclude some of the components we&rsquo;re not going to use (like Nagios, Ceph and Ceilometer). Have a look at <strong>cookbooks/packstack/recipe/default.rb</strong> for the list of modifications. The final step is a command to kickoff the packstack installer which will use another configuration management system, Puppet, to install and configure OpenStack according to the provided answer file.</p>

<p>At the end of these steps you should have a fully functional 3-node OpenStack environment.</p>

<h2>To be continued&hellip;</h2>

<p>This is a part of a 2-post series. In the next post we&rsquo;ll look into how to use the same tools to perform the baremetal provisioning of our physical underlay network.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStack SDN - Interconnecting VMs and Physical Devices With Cumulus VX L2 Gateway]]></title>
    <link href="http://networkop.github.io/blog/2016/05/21/neutron-l2gw/"/>
    <updated>2016-05-21T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/05/21/neutron-l2gw</id>
    <content type="html"><![CDATA[<p>One of the basic function of any data centre network is the ability to communicate with baremetal servers. In this post we&rsquo;ll see how Neutron L2 Gateway plugin can be used to configure a Cumulus VX switch for VXLAN-VLAN bridging.</p>

<!--more-->


<p>Since I have all my OpenStack environment running inside UNetLab, it makes it really easy for me to extend my L3 fabric with a switch from another vendor. In my previous posts I&rsquo;ve used <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">Cisco</a> and <a href="http://networkop.github.io/blog/2016/05/11/neutron-routed-extnet/">Arista</a> switches to build a 4-leaf 2-spine CLOS fabric. For this task I&rsquo;ve decided to use a Cumulus VX switch which I&rsquo;ve <a href="https://cumulusnetworks.com/cumulus-vx/">downloaded</a> and imported into my lab.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-l2gw-overview.png"></p>

<p>To simulate the baremetal server (10.0.0.100) I&rsquo;ve VRF&rsquo;d an interface on Arista &ldquo;L4&rdquo; switch and connected it directly to a &ldquo;swp3&rdquo; interface of the Cumulus VX. This is not shown on the diagram.</p>

<h2>Solution overview</h2>

<p><a href="https://wiki.openstack.org/wiki/Neutron/L2-GW">L2 Gateway</a> is a relatively <a href="https://github.com/openstack/networking-l2gw/releases">new</a> service plugin for OpenStack Neutron.  It provides the ability to interconnect a given tenant network with a VLAN on a physical switch. There are three main components that compose this solution:</p>

<ul>
<li><strong>Hardware switch</strong> implementing the OVSDB hardware vtep schema. This is a special &ldquo;flavour&rdquo; of OVSDB designed specifically to enable connectivity between logical (VXLAN VTEP) and physical (switchport) interfaces.</li>
<li><strong>L2GW agent</strong> running on a network node. This is the process responsible for connecting to OVSDB server running on a hardware switch and updating that database based on instructions received from a L2GW service plugin.</li>
<li><strong>L2GW Service Plugin</strong> residing on a control node. The task of this plugin is to notify the L2GW agent and normal L2 OVS agents running on compute hosts about network events and distribute VTEP IP address information between them.</li>
</ul>


<p>Note that in our case both network and control nodes are running on the same VM.</p>

<h2>Cumulux VX configuration</h2>

<p>Cumulux is a debian-based linux distribution, therefore most of the basic networking configuration will be similar to how things are done in Ubuntu. First, let&rsquo;s start by configuring basic IP addressing on Loopback (VTEP IP), Eth0 (OOB management), swp1 and swp2 (fabric) interfaces.</p>

<figure class='code'><figcaption><span>/etc/network/interfaces</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>iface lo inet loopback
</span><span class='line'>        address 10.0.0.5/32
</span><span class='line'>
</span><span class='line'>auto eth0
</span><span class='line'>iface eth0 inet static
</span><span class='line'>        address 192.168.91.21/24
</span><span class='line'>
</span><span class='line'>auto swp1
</span><span class='line'>iface swp1 inet static
</span><span class='line'>        address 169.254.51.5/24
</span><span class='line'>
</span><span class='line'>auto swp2
</span><span class='line'>iface swp2 inet static
</span><span class='line'>        address 169.254.52.5/24
</span><span class='line'>
</span><span class='line'>auto swp3
</span><span class='line'>iface swp3
</span></code></pre></td></tr></table></div></figure>


<p>Next, let&rsquo;s enable OSPF</p>

<figure class='code'><figcaption><span>Enable OSPF process</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo sed -i s/zebra<span class="o">=</span>no/zebra<span class="o">=</span>yes/ /etc/quagga/daemons
</span><span class='line'>sudo sed -i s/ospfd<span class="o">=</span>no/ospfd<span class="o">=</span>yes/ /etc/quagga/daemons
</span><span class='line'>sudo service quagga restart
</span></code></pre></td></tr></table></div></figure>


<p>Once OSPFd is running, we can use <code>sudo vtysh</code> to connect to local quagga shell and finalise the configuration.</p>

<figure class='code'><figcaption><span>show run</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>interface lo
</span><span class='line'> ip ospf area 0.0.0.0
</span><span class='line'> link-detect
</span><span class='line'>!
</span><span class='line'>interface swp1
</span><span class='line'> ip ospf area 0.0.0.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> link-detect
</span><span class='line'>!
</span><span class='line'>interface swp2
</span><span class='line'> ip ospf area 0.0.0.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> link-detect
</span><span class='line'>!
</span><span class='line'>router ospf
</span><span class='line'> ospf router-id 10.0.0.5
</span><span class='line'> passive-interface default
</span><span class='line'> no passive-interface swp1
</span><span class='line'> no passive-interface swp2
</span></code></pre></td></tr></table></div></figure>


<p>At this stage our Cumulus VX switch should be fully adjacent to both spines and its loopback IP (10.0.0.5) should be reachable from all OpenStack nodes.</p>

<p>The final step is to enable the hardware VTEP functionality. The <a href="https://docs.cumulusnetworks.com/display/CL22/Integrating+Hardware+VTEPs+with+Midokura+MidoNet+and+OpenStack">process</a> is fairly simple and involves only a few commands.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sudo sed -i s/START<span class="o">=</span>no/START<span class="o">=</span>yes/g /etc/default/openvswitch-vtep
</span><span class='line'><span class="nv">$ </span>sudo service openvswitch-vtep start
</span><span class='line'><span class="nv">$ </span>sudo vtep-bootstrap L5 10.0.0.5 192.168.91.21 --no_encryption
</span></code></pre></td></tr></table></div></figure>


<p>The last command runs a bootstrap script that does the following things:</p>

<ul>
<li>Creates a hardware VTEP OVSDB schema</li>
<li>Inside that schema creates a new physical switch called &ldquo;L5&rdquo;</li>
<li>Sets the VTEP IP to 10.0.0.5</li>
<li>Starts listening to incoming OVSDB connections on 192.168.91.21</li>
</ul>


<h2>Hardware VTEP vs OpenvSwitch OVSDB schemas (Optional)</h2>

<p>By now you&rsquo;re probably wondering what&rsquo;s that hardware VTEP OVSDB schema and how it&rsquo;s different from a normal OVS schema. First of all, remember that <a href="https://tools.ietf.org/html/rfc7047">OVSDB</a> is just a database and OVSDB protocol is just a set of JSON RPC calls to work with that database. Information that can be stored in the database is defined by a schema - a structure that represents tables and their relations. Therefore, OVSDB can be used to store and manage <a href="https://twitter.com/ben_pfaff/status/453333818653417472">ANY</a> type of data which makes it very flexible. Specificallly OVS project defines two OVSDB schemas:</p>

<ul>
<li><strong><a href="http://openvswitch.org/ovs-vswitchd.conf.db.5.pdf">Open_vSwitch schema</a></strong> - used to manage bridges, ports and controllers of OpenvSwitch. This schema is used by OVS inside every compute host we have in our OpenStack environment.</li>
<li><strong><a href="http://openvswitch.org/docs/vtep.5.pdf">Hardware_vtep schema</a></strong> - designed to be used by physical switches. The goal of this schema is to extend the virtual L2 switch into a physical realm by providing the ability to map physical ports to logical networks. For each logical network the hardware VTEP database holds mappings of MAC addresses to VTEPs and physical switchport.</li>
</ul>


<p>The information from these databases is later consumed by another process that sets up the actual bridges and ports. The first schema is used by the <strong>ovs-vswitchd</strong> process running on all compute hosts to configure ports and flows of integration and tunnel bridges. In case of a Cumulus switch, the information from <strong>hardware_vtep</strong> OVSDB is used by a process called <strong>ovs-vtepd</strong> that is responsible for settings up VXLAN VTEP interfaces, provisioning of VLANs on physical switchports and interconnecting them with a Linux bridge.</p>

<p>If you want to learn more, check out this <a href="http://www.relaxdiego.com/2014/09/hardware_vtep.html">awesome post</a> about hardware VTEP and OVS.</p>

<h2>OpenStack Control node configuration</h2>

<p>Most of the following procedure has been borrowed from <a href="http://kimizhang.com/neutron-l2-gateway-hp-5930-switch-ovsdb-integration/">another blog</a>. It&rsquo;s included it this post because I had to do some modifications and also for the sake of completeness.</p>

<ol>
<li><p>Clone the L2GW repository</p>

<pre><code class="`"> git clone -b stable/mitaka https://github.com/openstack/networking-l2gw.git
</code></pre></li>
<li><p>Use pip to install the plugin</p>

<pre><code class="`"> pip install ./networking-l2gw/
</code></pre></li>
<li><p>Enable the L2GW service plugin</p>

<pre><code class="`"> sudo sed -ri 's/^(service_plugins.*)/\1,networking_l2gw.services.l2gateway.plugin.L2GatewayPlugin/' \
 /etc/neutron/neutron.conf
</code></pre></li>
<li><p>Copy L2GW configuration files into the neutron configuration directory</p>

<pre><code class="`"> cp  /usr/etc/neutron/l2g* /etc/neutron/
</code></pre></li>
<li><p>Point the L2GW plugin to our Cumulus VX switch</p>

<pre><code class="`"> sudo sed -ri "s/^#\s+(ovsdb_hosts).*/\1 = 'ovsdb1:192.168.91.21:6632'/" /etc/neutron/l2gateway_agent.ini
</code></pre></li>
<li><p>Update Neutron database with the new schema required by L2GW plugin</p>

<pre><code class="`"> systemctl stop neutron-server
 neutron-db-manage --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/l2gw_plugin.ini  upgrade head
 systemctl start neutron-server
</code></pre></li>
<li><p>Update Neutron startup script to load the L2GW plugin configuration file</p>

<pre><code class="`"> sed -ri "s/(ExecStart=.*)/\1 --config-file \/etc\/neutron\/l2gw_plugin.ini /" /usr/lib/systemd/system/neutron-server.service
</code></pre></li>
<li><p>Create a L2GW systemd unit file</p>

<pre><code class="`"> cat &gt;&gt; /usr/lib/systemd/system/neutron-l2gateway-agent.service &lt;&lt; EOF
 [Unit]
 Description=OpenStack Neutron L2 Gateway Agent
 After=neutron-server.service

 [Service]
 Type=simple
 User=neutron
 ExecStart=/usr/bin/neutron-l2gateway-agent --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/l2gateway_agent.ini
 KillMode=process

 [Install]
 WantedBy=multi-user.target
 EOF
</code></pre></li>
<li><p>Restart both L2GW and neutron server</p>

<pre><code class="`"> systemctl daemon-reload
 systemctl restart neutron-server.service
 systemctl start neutron-l2gateway-agent.service  
</code></pre></li>
<li><p>Enter the &ldquo;neutron configuration mode&rdquo;</p>

<pre><code>source ~/keystone_admin
neutron
</code></pre></li>
<li><p>Create a new L2 gateway device</p>

<pre><code>l2-gateway-create --device name="L5",interface_names="swp3" CUMULUS-L2GW
</code></pre></li>
<li><p>Create a connection between a &ldquo;private_network&rdquo; and a native vlan (dot1q 0) of swp3 interface</p>

<pre><code>l2-gateway-connection-create --default-segmentation-id 0 CUMULUS-L2GW private_network
</code></pre></li>
</ol>


<h2>Verification and Traffic Flows</h2>

<p>At this stage everything should be ready for testing. We&rsquo;ll start by examining the following traffic flow:</p>

<ul>
<li>From VM-2 10.0.0.4/fa:16:3e:d7:0e:14</li>
<li>To baremetal server 10.0.0.100/50:00:00:6b:2e:70</li>
</ul>


<p><img class="center" src="http://networkop.github.io/images/neutron-l2gw-detailed.png"></p>

<p>The communication starts with VM-2 sending an ARP request for the MAC address of the baremetal server. Packet flow inside the compute host will be exactly the same <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">as before</a>, with packet being flooded from the VM to the integration and tunnel bridges. Inside the tunnel bridge the packet gets resubmitted to table 22 where head-end replication of ARP request takes place.</p>

<p>The only exception is that this time the frame will get replicated to a new VXLAN port pointing towards the Cumulux VTEP IP. We&rsquo;ll use the <code>ovs-appctl ofproto/trace</code> command to see the full path a packet takes inside OVS, which is similar to <code>packet-tracer</code> command of Cisco ASA. To simulate an ARP packet we need to specify the incoming port(in_port), EtherType(arp), internal VLAN number for our tenant(dl_vlan) and an ARP request target IP address(arp_tpa). You can find the full list of fields that can be matched in <a href="http://openvswitch.org/support/dist-docs/ovs-ofctl.8.txt">this document</a>.</p>

<figure class='code'><figcaption><span>ARP request to the baremetal server</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-appctl ofproto/trace br-tun <span class="nv">in_port</span><span class="o">=</span>1,arp,dl_vlan<span class="o">=</span>1,arp_tpa<span class="o">=</span>10.0.0.100 <span class="p">|</span> grep -E <span class="s2">&quot;Rule|actions=&quot;</span>
</span><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>1
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">2</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">20</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">priority</span><span class="o">=</span>0
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,22<span class="o">)</span>
</span><span class='line'>                        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">22</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">dl_vlan</span><span class="o">=</span>1
</span><span class='line'>                        OpenFlow <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x45,output:9,output:4,output:6
</span></code></pre></td></tr></table></div></figure>


<p>The packet leaving port 9 will get encapsulated into a VXLAN header with destination IP of 10.0.0.5 and forwarded out the fabric-facing interface eth1.100. When VXLAN packet reaches the <strong>vxln69</strong> interface (10.0.0.5) of the Cumulus switch, the <strong>br-vxlan69</strong> Linux bridge floods the frame out the second connected interface - <strong>swp3</strong>.</p>

<figure class='code'><figcaption><span>brctl show br-vxln69</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>bridge name        bridge id          STP enabled     interfaces
</span><span class='line'>br-vxln69          8000.500000070003  no              swp3
</span><span class='line'>                                                      vxln69
</span></code></pre></td></tr></table></div></figure>


<p>The rest of the story is very simple. When ARP packet hits the baremetal server it populates its ARP cache. A unicast response travels all the way back to the Cumulus switch, gets matched by the static MAC (0e:14) entry created based on information provided by the L2GW plugin. This entry points to the VTEP IP of Compute host 2(10.0.2.10) which is where it gets forwarded next.</p>

<figure class='code'><figcaption><span>bridge fdb show</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>50:00:00:09:00:04 dev swp3 vlan <span class="m">0</span> master br-vxln69
</span><span class='line'>50:00:00:07:00:03 dev swp3 vlan <span class="m">0</span> master br-vxln69 permanent
</span><span class='line'>50:00:00:6b:2e:70 dev swp3 vlan <span class="m">0</span> master br-vxln69
</span><span class='line'>26:21:90:a8:8a:cc dev vxln69 vlan <span class="m">0</span> master br-vxln69 permanent
</span><span class='line'>fa:16:3e:57:1c:6c dev vxln69 dst 10.0.3.10 vlan <span class="m">65535</span> self permanent
</span><span class='line'>fa:16:3e:a4:12:e6 dev vxln69 dst 10.0.3.10 vlan <span class="m">65535</span> self permanent
</span><span class='line'>fa:16:3e:d7:0e:14 dev vxln69 dst 10.0.2.10 vlan <span class="m">65535</span> self permanent
</span><span class='line'>fa:16:3e:3c:51:d7 dev vxln69 dst 10.0.1.10 vlan <span class="m">65535</span> self permanent
</span></code></pre></td></tr></table></div></figure>


<p>The packet travels through compute host 2, populating the flow entries of all OVS bridges along the way. These entries are then used by subsequent unicast packets travelling from VM-2.</p>

<figure class='code'><figcaption><span>Unicast packet to the baremetal server</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-appctl ofproto/trace br-tun <span class="nv">in_port</span><span class="o">=</span>1,dl_vlan<span class="o">=</span>1,dl_dst<span class="o">=</span>50:00:00:6b:2e:70 <span class="p">|</span> grep -E <span class="s2">&quot;Rule|actions=&quot;</span>
</span><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xb5625033061a8ae5 <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>1
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">2</span> <span class="nv">cookie</span><span class="o">=</span>0xb5625033061a8ae5 <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">20</span> <span class="nv">cookie</span><span class="o">=</span>0xb5625033061a8ae5 <span class="nv">priority</span><span class="o">=</span>1,vlan_tci<span class="o">=</span>0x0001/0x0fff,dl_dst<span class="o">=</span>50:00:00:6b:2e:70
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:0x45-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:9
</span></code></pre></td></tr></table></div></figure>


<p>It all looks fine until the ARP cache of the baremetal server expires and you get an ARP request coming from the physical into the virtual world. There is a <a href="https://drive.google.com/file/d/0Bx8nDIFktlzBRm0tV3pmYURnZ3M/view">known issue</a> with BUM forwarding which requires a special <a href="http://blog.scottlowe.org/2014/02/27/learning-nsx-part-10-adding-a-service-node/">service node</a> to perform the head-end replication. The idea is that a switch that needs to flood a multicast packet, would send it to a service node which keeps track of all active VTEPs in the network and performs packet replication on behalf of the sender. OpenStack doesn&rsquo;t have a dedicated service node, however it is possible to trick the network node into performing a similar functionality, which is what I&rsquo;m going to demonstrate next.</p>

<h2>Programming Network Node as BUM replication service node</h2>

<p>First of all, we need to tell our Cumulus switch to send all multicast packets to the network node. To do that we need to modify OVSDB table called &ldquo;Mcast_Macs_Remote&rdquo;. You can view the contents of the database using the <code>ovsdb-client dump --pretty tcp:192.168.91.21:6632</code> command to make sure that this table is empty. Using the VTEP control command we need to force all <strong>unknown-dst</strong> (BUM) traffic to go to the network node(10.0.3.10). The UUID of the logical switch can be found with <code>sudo vtep-ctl list-ls</code> command.</p>

<figure class='code'><figcaption><span>Forward all BUM traffic to OpenStack network node</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo vtep-ctl add-mcast-remote 818b4779-645c-49bb-ae4a-aa9340604019 unknown-dst 10.0.3.10
</span></code></pre></td></tr></table></div></figure>


<p>At this stage all BUM traffic hits the network node and gets flooded to the DHCP and the virtual router namespaces. In order to force this traffic to also be replicated to all compute nodes we can use some of the existing tables of the tunnel bridge. Before we do anything let&rsquo;s have a look at the tables our ARP request has to go through inside the tunnel bridge.</p>

<figure class='code'><figcaption><span>Packet from Cumulus VTEP inside br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">2</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,4<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>4, <span class="nv">priority</span><span class="o">=</span>1,tun_id<span class="o">=</span>0x45 <span class="nv">actions</span><span class="o">=</span>mod_vlan_vid:1,resubmit<span class="o">(</span>,10<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>10,priority<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,cookie<span class="o">=</span>0x9f3e746b7ee48bbf,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:NXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span></code></pre></td></tr></table></div></figure>


<p>We also have a default head-end replication table 22 which floods all BUM traffic received from the integration bridge to all VTEPs:</p>

<figure class='code'><figcaption><span>BUM replication table</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>22, <span class="nv">dl_vlan</span><span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x45,output:2,output:4,output:6
</span></code></pre></td></tr></table></div></figure>


<p>So what we can do is create a new flow entry that would intercept all ARP packets inside Table 4 and resubmit them to tables 10 and 22. Table 10 will take our packet up to the integration bridge of the network node, since we still need to be able to talk the virtual router and the DHCP. Table 22 will receive a copy of the packet and flood it to all known VXLAN endpoints.</p>

<figure class='code'><figcaption><span>Manipulating OVS flows</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ovs-ofctl add-flow br-tun <span class="s2">&quot;table=4,arp,tun_id=0x45,priority=2,actions=mod_vlan_vid:1,resubmit(,10),resubmit(,22)&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can once again use the trace command to see the ARP request flow inside the tunnel bridge.</p>

<figure class='code'><figcaption><span>ARP request received from the Cumulus switch</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-appctl ofproto/trace br-tun <span class="nv">in_port</span><span class="o">=</span>2,arp,tun_id<span class="o">=</span>0x45 <span class="p">|</span> grep -E <span class="s2">&quot;Rule|actions=&quot;</span>
</span><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0x9f3e746b7ee48bbf <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>2
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,4<span class="o">)</span>
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">4</span> <span class="nv">cookie</span><span class="o">=</span><span class="m">0</span> <span class="nv">priority</span><span class="o">=</span>2,arp,tun_id<span class="o">=</span>0x45
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>mod_vlan_vid:1,resubmit<span class="o">(</span>,10<span class="o">)</span>,resubmit<span class="o">(</span>,22<span class="o">)</span>
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">10</span> <span class="nv">cookie</span><span class="o">=</span>0x9f3e746b7ee48bbf <span class="nv">priority</span><span class="o">=</span>1
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,cookie<span class="o">=</span>0x9f3e746b7ee48bbf,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:NXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span><span class='line'>                        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0x91b1a9a9b6e8d608 <span class="nv">priority</span><span class="o">=</span>0
</span><span class='line'>                        OpenFlow <span class="nv">actions</span><span class="o">=</span>NORMAL
</span><span class='line'>                                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xb36f6e358a37bea6 <span class="nv">priority</span><span class="o">=</span>2,in_port<span class="o">=</span>2
</span><span class='line'>                                OpenFlow <span class="nv">actions</span><span class="o">=</span>drop
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">22</span> <span class="nv">cookie</span><span class="o">=</span>0x9f3e746b7ee48bbf <span class="nv">dl_vlan</span><span class="o">=</span>1
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x45,output:2,output:4,output:6
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://networkop.github.io/images/neutron-l2gw-arp.png"></p>

<p>Now we should be able to clear the ARP cache on baremetal device and successfully ping both VM-2, VM-1 and the virtual router.</p>

<h2>Conclusion</h2>

<p>The workaround presented above is just a temporary solution for the problem. In order to fix the problem properly, OVS vtep schema needs to be updated to support source node replication. Luckily, the patch implementing this functionality has been <a href="https://github.com/openvswitch/ovs/commit/b351ac0c9bc270b3fff07ae8c7434c53d59b132c">merged</a> into master OVS branch only a few days ago. So hopefully, this update trickles down to Cumulus package repositories soon.</p>

<p>Despite all the issues, Neutron L2 gateway plugin is a cool project that provides a very important piece of functionality without having to rely on 3rd party SDN controllers. Let&rsquo;s hope it will continue to be supported and developed by the community.</p>

<h2>Coming up</h2>

<p>In the next post I was planning to examine another &ldquo;must have&rdquo; feature of any SDN solution - Distributed Virtual Routing. However due to my current circumstances I may need to take a few weeks' break before going on. Be back soon!</p>

<p><img class="center" src="http://networkop.github.io/images/be-back.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack SDN - Extending a L2 Provider Network Over a L3 Fabric]]></title>
    <link href="http://networkop.github.io/blog/2016/05/11/neutron-routed-extnet/"/>
    <updated>2016-05-11T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/05/11/neutron-routed-extnet</id>
    <content type="html"><![CDATA[<p>In the this post we&rsquo;ll tackle yet another Neutron scalability problem identified in my <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">earlier post</a> - a requirement to have a direct L2 adjacency between the external provider network and the network node.</p>

<!--more-->


<h2>Provider vs Tenant networks</h2>

<p>Before we start, let&rsquo;s recap the difference between the <a href="http://docs.openstack.org/mitaka/networking-guide/intro-os-networking-overview.html">two major</a> Neutron network types:</p>

<ul>
<li>Tenant networks are:

<ul>
<li>provisioned by tenants</li>
<li>used for inter-VM (east-west) communication</li>
<li>use Neutron virtual router as their default gateway</li>
</ul>
</li>
<li>Provider networks are:

<ul>
<li>provisioned by OpenStack administrator(for use by tenants)</li>
<li>match existing physical networks</li>
<li>can be either flat (untagged VLAN) or VLAN-based (multiple VLANs)</li>
<li>need to be L2 adjacent to network and/or compute nodes</li>
</ul>
</li>
</ul>


<p>These two network types are not mutually exclusive. In our case the <strong>admin tenant</strong> network is implemented as a VXLAN-based overlay whose only requirement is to have a layer-3 reachability in the underlay. However tenant network could also have been implemented using a VLAN-based provider network in which case a set of dot1Q tags pre-provisioned in the underlay would have been used for tenant network segregation.</p>

<h2>External provider network</h2>

<p>External network is used by VMs to communicate with the outside world (north-south). Since default gateway is located outside of OpenStack environment this, by definition, is a provider network. Normally, tenant networks will use the non-routable address space and will rely on a Neutron virtual router to perform some form of NAT translation. As we&rsquo;ve seen in the <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">earlier post</a>, Neutron virtual router is directly connected to the external bridge which allows it to &ldquo;borrow&rdquo; ip address from the external provider network to use for two types of NAT operations:</p>

<ul>
<li>SNAT - a source-based port address translation performed by the Neutron virtual router</li>
<li>DNAT - a static NAT created for every <a href="https://www.rdoproject.org/networking/difference-between-floating-ip-and-private-ip/">floating ip address</a> configured for a VM</li>
</ul>


<p>In default deployments all NATing functionality is performed by a network node, so external provider network only needs to be L2 adjacent with a limited number of physical hosts. In deployments where <abbr title=" Distributed Virtual Router">DVR</abbr> is used, the virtual router and NAT functionality gets distributed among all compute hosts which means that they, too, now need to be layer-2 adjacent to the external network.</p>

<h2>Solutions overview</h2>

<p>The direct adjacency requirement presents a big problem for deployments where layer-3 routed underlay is used for the tenant networks. There is a limited number of ways to satisfy this requirements, for example:</p>

<ul>
<li>Span a L2 segment across the whole DC fabric. This means that the fabric needs to be converted to layer-2, reintroducing spanning-tree and all the unique vendor solutions to overcome STP limitations(e.g. TRILL, Fabripath, SPB).</li>
<li>Build a dedicated physical network. This may not always be feasible, especially considering that it needs to be delivered to all compute hosts.</li>
<li>Extend the provider network over an existing L3 fabric with VXLAN overlay. This can easily be implemented with just a few commands, however it requires a border leaf switch capable of performing VXLAN-VLAN translation.</li>
</ul>


<h2>Detailed design</h2>

<p>As I&rsquo;ve said in my <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">earlier post</a>, I&rsquo;ve built the leaf-spine fabric out of Cisco IOU virtual switches, however the plan was to start introducing other vendors later in the series. So this time for the border leaf role I&rsquo;ve chosen Arista vEOS switch, however, technically, it could have been any other vendor capable of doing VXLAN-VLAN bridging (e.g. any hardware switch with <a href="http://blog.ipspace.net/2014/06/trident-2-chipset-and-nexus-9500.html">Trident 2</a> or similar ASIC).</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-extnet-l3.png"></p>

<h3>Arista vEOS configuration</h3>

<p>Configuration of Arista switches is very similar to Cisco IOS. In fact, I was able to complete all interface and OSPF routing configuration only with the help of CLI context help. The only bit that was new to me and that I had to lookup in the official guide was the <a href="https://eos.arista.com/vxlan-with-mlag-configuration-guide/">VXLAN configuration</a>. These similarities makes the transition from Cisco to Arista very easy and I can understand (but not approve!) why Cisco would file a lawsuit against Arista for copying its &ldquo;industry-standard CLI&rdquo;.</p>

<figure class='code'><figcaption><span>L4 configuration</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>interface Ethernet1
</span><span class='line'>   description SPINE-1:Eth0/3
</span><span class='line'>   no switchport
</span><span class='line'>   ip address 169.254.41.4/24
</span><span class='line'>   ip ospf network point-to-point
</span><span class='line'>!
</span><span class='line'>interface Ethernet2
</span><span class='line'>   description SPINE-2:Eth0/3
</span><span class='line'>   no switchport
</span><span class='line'>   ip address 169.254.42.4/24
</span><span class='line'>   ip ospf network point-to-point
</span><span class='line'>!
</span><span class='line'>interface Ethernet3
</span><span class='line'>   description VM-HOST-ONLY:PNET1
</span><span class='line'>   switchport access vlan 100
</span><span class='line'>   spanning-tree portfast
</span><span class='line'>!
</span><span class='line'>interface Loopback0
</span><span class='line'>   ip address 10.0.0.4/32
</span><span class='line'>!
</span><span class='line'>interface Vxlan1
</span><span class='line'>   vxlan source-interface Loopback0
</span><span class='line'>   vxlan udp-port 4789
</span><span class='line'>   vxlan vlan 100 vni 1000
</span><span class='line'>   vxlan vlan 100 flood vtep 10.0.3.10
</span><span class='line'>!
</span><span class='line'>router ospf 1
</span><span class='line'>   router-id 10.0.0.4
</span><span class='line'>   passive-interface default
</span><span class='line'>   no passive-interface Ethernet1
</span><span class='line'>   no passive-interface Ethernet2
</span><span class='line'>   network 0.0.0.0/0 area 0.0.0.0
</span><span class='line'>!
</span></code></pre></td></tr></table></div></figure>


<p>Interface VXLAN1 sets up VXLAN-VLAN bridging between VNI 1000 and VLAN 100. VLAN 100 is used to connect to VMware Workstation&rsquo;s host-only interface, the one that was <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">previously</a> connected directly to the L3 leaf switch. VXLAN interface does the multicast source replication by flooding unknown packets over the layer 3 fabric to the network node (10.0.3.10).</p>

<h3>OpenStack network node configuration</h3>

<p>Since we don&rsquo;t yet have the distributed routing feature enabled, the only OpenStack component that requires any changes is the network node. First, let&rsquo;s remove the physical interface from the external bridge, since it will no longer be used to connect to the external provider network.</p>

<figure class='code'><figcaption><span>Remove the physical interface from the external bridge</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-vsctl del-port br-ex eth1.300
</span></code></pre></td></tr></table></div></figure>


<p>Next let&rsquo;s add the VXLAN interface towards the Loopback IP address of the Arista border leaf switch. The key option sets the VNI which must be equal to the VNI defined on the border leaf.</p>

<figure class='code'><figcaption><span>add the VXLAN interface towards the Arista switch</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-vsctl add-port br-ex vxlan1 <span class="se">\</span>
</span><span class='line'>-- <span class="nb">set </span>interface vxlan1 <span class="se">\</span>
</span><span class='line'><span class="nb">type</span><span class="o">=</span>vxlan <span class="se">\</span>
</span><span class='line'>options:remote_ip<span class="o">=</span>10.0.0.4 <span class="se">\</span>
</span><span class='line'>options:key<span class="o">=</span>1000
</span></code></pre></td></tr></table></div></figure>


<p>Without any physical interfaces attached to the external bridge, the OVS will use the Linux network stack to find the outgoing interface. When a packet hits the <strong>vxlan1</strong> interface of the br-ex, it will get encapsulated in a VXLAN header and passed on to the OS network stack where it will follow the <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">pre-configured</a> static route forwarding all 10/8 traffic towards the leaf-spine fabric. Check out <a href="http://blog.scottlowe.org/2013/05/15/examining-open-vswitch-traffic-patterns/">this article</a> if you want to learn more about different types of interfaces and traffic forwarding behaviours in OpenvSwitch.</p>

<h3>Cleanup</h3>

<p>In order to make changes persistent and prevent the static interface configuration from interfering with OVS, remove all OVS-related configuration and shutdown interface eth1.300.</p>

<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-eth1.300</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">ONBOOT</span><span class="o">=</span>no
</span><span class='line'><span class="nv">VLAN</span><span class="o">=</span>yes
</span></code></pre></td></tr></table></div></figure>


<h2>Change in the packet flow</h2>

<p>None of the packet flows have changed as the result of this modification. All VMs will still use NAT to break out of the private environment, the NAT&rsquo;d packets will reach the external bridge <strong>br-ex</strong> as described in my <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">earlier post</a>. However this time <strong>br-ex</strong> will forward the packets out the <strong>vxlan1</strong> port which will deliver them to the Arista switch over the same L3 fabric used for east-west communication.</p>

<p>If we did a capture on the fabric-facing interface <strong>eth1</strong> of the control node while running a ping from one of the VMs to the external IP address, we would see a VXLAN-encapsulated packet destined for the Loopback IP of L4 leaf switch.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-provider-vxlan.png"></p>

<h2>Coming Up</h2>

<p>In the next post we&rsquo;ll examine the L2 gateway feature that allows tenant networks to communicate with physical servers through yet another VXLAN-VLAN hardware gateway.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack SDN - L2 Population and ARP Proxy]]></title>
    <link href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/"/>
    <updated>2016-05-06T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/05/06/neutron-l2pop</id>
    <content type="html"><![CDATA[<p>In the <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">previous post</a> we&rsquo;ve had a look at how native OpenStack SDN works and what are some of its limitations. In this post we&rsquo;ll tackle the first one of them - overhead created by multicast source replication.</p>

<!--more-->


<h2>MAC learning in a controller-less VXLAN overlay</h2>

<p>VXLAN <a href="https://tools.ietf.org/html/rfc7348">standard</a> does not specify any control plane protocol to exchange MAC-IP bindings between VTEPs. Instead it relies on data plane flood-and-learn behaviour, just like a normal switch. To force this behaviour in an underlay, the standard stipulates that each VXLAN network should be mapped to its own multicast address and each VTEP participating in a network should join the corresponding multicast group. That multicast group would be used to flood the <abbr title="Broadcast Unknown unicast and Multicast">BUM</abbr> traffic in an underlay to all subscribed VTEPs thereby populating dynamic MAC address tables.</p>

<p>Default OpenvSwitch implementation <a href="https://github.com/openvswitch/ovs/blob/master/FAQ.md#q-how-much-of-the-vxlan-protocol-does-open-vswitch-currently-support">does not support</a> VXLAN multicast flooding and uses unicast source replication instead. This decision comes with a number of tradeoffs:</p>

<ul>
<li>Duplicate packets consume additional bandwidth. Extra 100 bytes exchanged every 3 minutes in a 100-nodes environment generate around 500 kbit/s of traffic on average. This can be considered negligible inside modern high-speed DC fabrics.</li>
<li>Hardware VTEP gateways rely on multicast for MAC learning and VTEP discovery. As we&rsquo;ll see later in the series, these gateways can now be controlled by Neutron just like a normal OVS inside a compute host.</li>
<li>Duplicate packets are processed by hosts that do not need them, e.g. ARP request is processed by tunnel and integration bridges of all hosts that have VMs in the same broadcast domain. This presents some serious scaling limitation and is addressed by the L2 population feature described in this post.</li>
</ul>


<p>Despite all the tradeoffs, OVS with unicast source replication has become a de-facto standard in most recent OpenStack implementations. The biggest advantage of such approach is the lack of requirement for multicast in the underlay network.</p>

<h2>VXLAN MAC learning with an SDN controller</h2>

<p>Neutron server is aware of all active MAC and IP addresses within the environment. This information can be used to prepopulate forwarding entries on all tunnel bridges. This is accomplished by a <a href="https://github.com/openstack/neutron/tree/master/neutron/plugins/ml2/drivers/l2pop">L2 population</a> driver. However that in itself isn&rsquo;t enough. Whenever a VM doesn&rsquo;t know the destination MAC address, it will send a broadcast ARP request which needs to be intercepted and responded by a local host to stop it from being flooded in the network. The latter is accomplished by a feature called <a href="https://assafmuller.com/2014/05/21/ovs-arp-responder-theory-and-practice/">ARP responder</a> which simulates the functionality commonly known as <strong>ARP proxy</strong> inside the tunnel bridge.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-l2-arp.png"></p>

<h3>Configuration</h3>

<p>Configuration of these two features is <a href="https://kimizhang.wordpress.com/2014/04/01/how-ml2vxlan-works/">fairly straight-forward</a>. First, we need to add L2 population to the list of supported mechanism drivers on our control node and restart the neutron server.</p>

<figure class='code'><figcaption><span>Update on control node</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sed -ri <span class="s1">&#39;s/(mechanism_drivers.*)/\1,l2population/&#39;</span> /etc/neutron/plugin.ini
</span><span class='line'><span class="nv">$ </span>service neutron-server restart
</span></code></pre></td></tr></table></div></figure>


<p>Next we need to enable L2 population and ARP responder features on all 3 compute nodes.</p>

<figure class='code'><figcaption><span>Updates on all 3 compute nodes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sed -ri <span class="s1">&#39;s/.*(arp_responder).*/\1 = true/&#39;</span> /etc/neutron/plugins/ml2/openvswitch_agent.ini
</span><span class='line'><span class="nv">$ </span>sed -ri <span class="s1">&#39;s/.*(l2_population).*/\1 = true/&#39;</span> /etc/neutron/plugins/ml2/openvswitch_agent.ini
</span><span class='line'><span class="nv">$ </span>service neutron-openvswitch-agent restart
</span></code></pre></td></tr></table></div></figure>


<p>Since L2 population is triggered by the <a href="https://assafmuller.com/2014/02/23/ml2-address-population/">port_up</a> messages, we might need to restart both our VMs for the change to take effect.</p>

<h3>BUM frame from VM-1 for MAC address of VM-2 (Revisited)</h3>

<p>Now let&rsquo;s once again examine what happens when VM-1 issues an ARP request for VM-2&rsquo;s MAC address (1a:bf).</p>

<p>First, the frame hits the flood-and-learn rule of the integration bridge and gets flooded down to the tunnel bridge as desribed in the <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">previous post</a>. Once in the br-tun, the frames gets matched by the incoming port and resubmitted to table 2. In addition to a default unicast/multicast bit match, table 2 now also matches all ARP requests and resubmitts them to the new table 21. Note how the ARP entry has a higher priority to always match before the default catch-all multicast rule.</p>

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>1,arp,dl_dst<span class="o">=</span>ff:ff:ff:ff:ff:ff <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,21<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>01:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,22<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Inside table 21 are the entries created by the ARP responder feature. The following is an example entry that matches all ARP requests where target IP address field equals the IP of VM-2(10.0.0.9).</p>

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> <span class="nv">table</span><span class="o">=</span>21, <span class="nv">priority</span><span class="o">=</span>1,arp,dl_vlan<span class="o">=</span>1,arp_tpa<span class="o">=</span>10.0.0.9
</span><span class='line'> <span class="nv">actions</span><span class="o">=</span>move:NXM_OF_ETH_SRC<span class="o">[]</span>-&gt;NXM_OF_ETH_DST<span class="o">[]</span>,
</span><span class='line'> mod_dl_src:fa:16:3e:ab:1a:bf,
</span><span class='line'> load:0x2-&gt;NXM_OF_ARP_OP<span class="o">[]</span>,
</span><span class='line'> move:NXM_NX_ARP_SHA<span class="o">[]</span>-&gt;NXM_NX_ARP_THA<span class="o">[]</span>,
</span><span class='line'> move:NXM_OF_ARP_SPA<span class="o">[]</span>-&gt;NXM_OF_ARP_TPA<span class="o">[]</span>,
</span><span class='line'> load:0xfa163eab1abf-&gt;NXM_NX_ARP_SHA<span class="o">[]</span>,
</span><span class='line'> load:0xa000009-&gt;NXM_OF_ARP_SPA<span class="o">[]</span>,
</span><span class='line'> IN_PORT
</span></code></pre></td></tr></table></div></figure>


<p>The resulting action builds an ARP response by modifying the fields and headers on the original ARP request message, specifically OVS:</p>

<ol>
<li>Copies the source MAC address (VM-1) to the destination MAC address header</li>
<li>Spoofs the source MAC address to make it look like it comes from VM-2</li>
<li>Modifies the operation code of ARP message to 0x2, meaning <strong>reply</strong></li>
<li>Overwrites the target IP and MAC address fields inside the ARP packet with VM-1&rsquo;s values</li>
<li>Overwrites the source hardware address with VM-2&rsquo;s MAC</li>
<li>Overwrites the source IP address with the address of VM-2(0xa000009)</li>
<li>Sends the packet out the port from which it was received</li>
</ol>


<h3>Unicast frame from VM-1 to VM-2 (Revisited)</h3>

<p>Now that VM-1 has learned the MAC address of VM-2 it can start sending the unicast frames. The first few steps will again be the same. The frame hits the tunnel bridge, gets classified as a unicast and resubmitted to table 20. Table 20 will still have an entry generated by a <strong>learn</strong> action triggered by a packet coming from VM-2, however now it also has and identical entry with a higher priority(priority=2), which was preconfigured by a L2 population feature.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>20, <span class="nv">priority</span><span class="o">=</span>2,dl_vlan<span class="o">=</span>1,dl_dst<span class="o">=</span>fa:16:3e:ab:1a:bf <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x54,output:2
</span><span class='line'><span class="nv">table</span><span class="o">=</span>20, <span class="nv">priority</span><span class="o">=</span>1,vlan_tci<span class="o">=</span>0x0001/0x0fff,dl_dst<span class="o">=</span>fa:16:3e:ab:1a:bf <span class="nv">actions</span><span class="o">=</span>load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:0x54-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:2
</span></code></pre></td></tr></table></div></figure>


<h2>Other BUM traffic</h2>

<p>The two features described in this post only affect the ARP traffic to VMs <strong>known</strong> to the Neutron server. All the other BUM traffic will still be flooded as described in the <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">previous post</a>.</p>

<h2>Results</h2>

<p>As the result of enabling L2 population and ARP responder features we were able to reduce the amount of BUM traffic in the overlay network and reduce the eliminate processing on compute hosts incurred by ARP request flooding.</p>

<p>However one downside of this approach is the increased number of flow entries in tunnel bridges of compute hosts. Specifically, for each known VM there now will be two entries in the tunnel bridge with different priorities. This may have negative impact on performance and is something to keep in mind when designing OpenStack solutions for scale.</p>

<h2>Coming Up</h2>

<p>In the next post I&rsquo;ll show how to overcome the requirement of a direct L2 adjacency between the network node and external subnet. Specifically, I&rsquo;ll use Arista switch to extend a L2 provider network over a L3 leaf-spine Cisco fabric.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network Engineering Analysis of OpenStack SDN]]></title>
    <link href="http://networkop.github.io/blog/2016/04/22/neutron-native/"/>
    <updated>2016-04-22T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/04/22/neutron-native</id>
    <content type="html"><![CDATA[<p>Now that we have our 3-node OpenStack lab <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">up and running</a> we can start exploring how virtual networks are implemented under the hood.</p>

<!--more-->


<h2>Intro</h2>

<p>This is going to be quite a lengthy blogpost so I&rsquo;ll try to explain its structure first. I&rsquo;ll start with a high level overview of components used to build virtual networks by examining 3 types of traffic:</p>

<ul>
<li>Unicast traffic between VM1 and VM2</li>
<li>Unicast traffic between VM1 and the outside world (represented by an external subnet)</li>
<li>Broadcast, Unknown unicast and Multicast or BUM traffic from VM1</li>
</ul>


<p>Following that I&rsquo;ll give a brief overview of how to interpret the configuration and dynamic state of OpenvSwitch to manually trace the path of a packet. This will be required for the next section where I&rsquo;ll go over the same 3 types of traffic but this time corroborating every step with the actual outputs collected from the virtual switches. For the sake of brevity I&rsquo;ll abridge a lot of the output to only contain the relevant information.</p>

<h2>High Level Overview</h2>

<p><a href="http://www.innervoice.in/blogs/2015/03/31/openstack-neutron-plugins-and-agents/">Neutron</a> server, residing in a control node, is responsible for orchestrating and provisioning of all virtual networks within an OpenStack environment. Its goal is to enable end-to-end reachability among the VMs and between the VMs and external subnets. To do that, Neutron uses concepts that should be very familiar to every network engineer like subnet, router, firewall, DHCP and NAT. In the <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous post</a> we&rsquo;ve seen how to create a virtual router and attach it to public and private networks. We&rsquo;ve also attached both of our VMs to a newly created private network and verified connectivity by logging into those virtual machines. Now let&rsquo;s see how exactly these VMs communicate with each other and the outside world.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-high-level.png"></p>

<h3>Unicast frame between VM1 and VM2</h3>

<ol>
<li><p>As soon as the frame leaves the vNIC of VM1 it hits the firewall. The firewall is implemented on a <a href="http://www.innervoice.in/blogs/2013/12/08/tap-interfaces-linux-bridge/">tap interface</a> of the integration bridge. A set of <abbr title="Access Control List">ACL</abbr> rules, defined in a <strong>Security Group</strong> that VM belongs to, gets translated into Linux <a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TRAVERSINGOFTABLES">iptables</a> rules and attached to this tap interface. These simple reflexive access lists are what VMware and Cisco are calling microsegmentation and touting as one of the main use case of their SDN solutions.</p></li>
<li><p>Next our frame enters the integration bridge implemented using <a href="http://openvswitch.org/">OpenvSwitch</a>. Its primary function is to interconnect all virtual machines running on the host. Its secondary function is to provide isolation between different subnets and tenants by keeping them in different VLANs. VLAN IDs used for this are locally significant and don&rsquo;t propagate outside of the physical host.</p></li>
<li><p>A dot1q-tagged packet is forwarded down a layer 2 trunk to the tunnel bridge, also implemented using OpenvSwitch. It is programmed to strip the dot1q tags, replace them with VXLAN headers and forward an IP/UDP packet with VXLAN payload on to the physical network.</p></li>
<li><p>Our simple routed underlay delivers the packets to the destination host, where the tunnel bridge swaps the <abbr title=" VXLAN Network ID">VNI</abbr> with a dot1q tag and forwards the packet up to the integration bridge.</p></li>
<li><p>Integration bridge consults the local MAC table, finds the output interface, clears the dot1q tag and send the frame up to the VM.</p></li>
<li><p>The frame gets screened by incoming iptables rules and gets delivered to the VM2.</p></li>
</ol>


<h3>Unicast frame between VM1 and External host</h3>

<ol>
<li><p>The first 3 steps will still be the same. VM1 sends a frame with destination MAC address of a virtual router. This packet will get encapsulated in a VXLAN header and forwarded to the Network node.</p></li>
<li><p>The tunnel and integration bridges of the network node deliver the packet to the private interface of a virtual router. This virtual router lives in a <a href="http://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/">linux network namespaces</a> (similar to <abbr title="Virtual Routing and Forwarding">VRF</abbr>s) used to provide isolation between OpenStack tenants.</p></li>
<li><p>The router finds the outgoing interface (a port attached to the external bridge), and a next-hop IP which we have set when we configured a public subnet <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">earlier</a>.</p></li>
<li><p>The router then performs a source NAT on the packet before forwarding it out. This way the private IP of the VM stays completely hidden and hosts outside of OpenStack can talk back to the VM by sending packets to (publicly routable) external subnet.</p></li>
<li><p>External bridge (also an OpenvSwitch) receives the packet and forwards it out the attached physical interface (eth1.300).</p></li>
</ol>


<h3>BUM frame from VM1 for MAC address of VM2</h3>

<ol>
<li><p>VM1 sends a multicast frame, which gets examined by the iptables rules and enters the integration bridge.</p></li>
<li><p>The integration bridge follows the same process as for the unicast frame to assign the dot1q tag and floods the frame to the tunnel bridge.</p></li>
<li><p>The tunnel bridge sees the multicast bit in the destination MAC address and performs source replication by sending a duplicate copy of the frame to both compute host #2 and the network node.</p></li>
<li><p>Tunnel bridges of both receiving hosts strip the VXLAN header, add the dot1q tag and flood the frame to their respective integration bridges.</p></li>
<li><p>Integration bridges flood the frame within the VLAN identified by the dot1q header.</p></li>
<li><p>The response from VM2 follows the same process as the unicast frame.</p></li>
</ol>


<p>One thing worth noting is when an ARP packet enters the integration bridge, its source IP address (in case of IPv4) or source MAC address (in case of IPv6) gets examined to make sure it belong to that VM. This is how <strong>ARP spoofing protection</strong> is implemented in OpenStack.</p>

<h2>OpenvSwitch quick intro</h2>

<p>Before we dive deeper into the details of the packet flows inside OVS let me give a brief overview of how it works. There are two main protocols to configure OVS:</p>

<ul>
<li><p>OVSDB - a management protocol used to configure bridges, ports, VLANs, QoS, monitoring etc.</p></li>
<li><p>OpenFlow - used to install flow entries for traffic switching, similar to how you would configure a static route but allowing you to match on most of the L2-L4 protocol headers.</p></li>
</ul>


<p>Control node instructs all <a href="http://www.innervoice.in/blogs/2015/03/31/openstack-neutron-plugins-and-agents/">local OVS agents</a> about how to configure virtual networks. Each local OVS agent then uses these two protocols to configure OVS and install all the required forwarding entries. Each entry contains a set of matching fields (e.g. incoming port, MAC/IP addresses) and an action field which determines what to do with the packet. These forwarding entries are implemented as <a href="https://wiki.openstack.org/wiki/Ovs-flow-logic">tables</a>. This is how a packet traverses these tables:</p>

<ol>
<li><p>First packet always hits table 0. The entries are examined in order of their priority (highest first) to find the first match. Note that it&rsquo;s the first and not necessarily the more specific match. It&rsquo;s the responsibility of a controller to build tables so that more specific flows are matched first. Normally this is done by assigning a higher priority to a more specific flow. Exact matches (where all L2-L4 fields are specified) implicitly have the highest priority value of 65535.</p></li>
<li><p>When a flow is matched, the <strong>action</strong> field of that flow is examined. Here are some of the most commonly used actions:</p>

<table>
<thead>
<tr>
<th> Action </th>
<th></th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td> resubmit(X,) </td>
<td></td>
<td> Resubmit a packet to table X </td>
</tr>
<tr>
<td> output:Y </td>
<td></td>
<td> Send a packet out port Y </td>
</tr>
<tr>
<td> NORMAL </td>
<td></td>
<td> Use a standard flood-and-learn behaviour of a switch to populate a local dynamic MAC address table </td>
</tr>
<tr>
<td> learn(table=Z) </td>
<td></td>
<td> Create an exact-match entry for the matched flow in table Z (we&rsquo;ll see how its used later on) </td>
</tr>
</tbody>
</table>


<p> These actions can be combined in a sequence to create complex behaviours like sending the same packet to multiple ports for multicast source replication.</p></li>
<li><p>OVS also <a href="https://networkheresy.com/2014/11/13/accelerating-open-vswitch-to-ludicrous-speed/">implements</a> what Cisco calls <strong>Fast switching</strong>, where the first packet lookup triggers a cache entry to be installed in the kernel-space process to be used by all future packets from the same flow.</p></li>
</ol>


<h2>Detailed packet flow analysis</h2>

<p>Let&rsquo;s start by recapping what we know about our private virtual network. All these values can be obtained from Horizon GUI by examining the private network configuration under Project -> Network -> Networks -> private_network:</p>

<ul>
<li>VM1, IP=10.0.0.8, MAC=fa:16:3e:19:e4:91, port id = <strong>258336bc-4f</strong>38-4bec-9229-4bc76e27f568</li>
<li>VM2, IP=10.0.0.9, MAC=fa:16:3e:ab:1a:bf, port id = <strong>e5f7eaca-1a</strong>36-4b08-aa9b-14e9787f80b0</li>
<li>Router, IP=10.0.0.1, MAC=fa:16:3e:cf:89:47, port id = <strong>96dfc1d3-d2</strong>3f-4d28-a461-fa2404767df2</li>
</ul>


<p>The first 11 characters of port id will be used inside an integration bridge to build the port names, e.g.:</p>

<ul>
<li>tap258336bc-4f - interface connected to VM1</li>
<li>qr-96dfc1d3-d2 - interface connected to the router</li>
</ul>


<h3>Enumerating OVS ports</h3>

<p>In its forwarding entries OVS uses internal port numbers a lot, therefore it would make sense to collect all port number information before we start. This is how it can be done:</p>

<ul>
<li>Use <code>ovs-vsctl show</code> command to collect information about existing port names and their attributes (e.g. dot1q tag, VXLAN tunnel IPs, etc). This is the output collected on compute host #1:</li>
</ul>


<figure class='code'><figcaption><span>ovs-vsctl show | grep -E "Bridge|Port|tag|options"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Bridge br-tun
</span><span class='line'>    Port br-tun
</span><span class='line'>    Port patch-int
</span><span class='line'>            options: <span class="o">{</span><span class="nv">peer</span><span class="o">=</span>patch-tun<span class="o">}</span>
</span><span class='line'>    Port <span class="s2">&quot;vxlan-0a00020a&quot;</span>
</span><span class='line'>            options: <span class="o">{</span><span class="nv">df_default</span><span class="o">=</span><span class="s2">&quot;true&quot;</span>, <span class="nv">in_key</span><span class="o">=</span>flow, <span class="nv">local_ip</span><span class="o">=</span><span class="s2">&quot;10.0.1.10&quot;</span>, <span class="nv">out_key</span><span class="o">=</span>flow, <span class="nv">remote_ip</span><span class="o">=</span><span class="s2">&quot;10.0.2.10&quot;</span><span class="o">}</span>
</span><span class='line'>    Port <span class="s2">&quot;vxlan-0a00030a&quot;</span>
</span><span class='line'>            options: <span class="o">{</span><span class="nv">df_default</span><span class="o">=</span><span class="s2">&quot;true&quot;</span>, <span class="nv">in_key</span><span class="o">=</span>flow, <span class="nv">local_ip</span><span class="o">=</span><span class="s2">&quot;10.0.1.10&quot;</span>, <span class="nv">out_key</span><span class="o">=</span>flow, <span class="nv">remote_ip</span><span class="o">=</span><span class="s2">&quot;10.0.3.10&quot;</span><span class="o">}</span>
</span><span class='line'>Bridge br-int
</span><span class='line'>    Port br-int
</span><span class='line'>    Port <span class="s2">&quot;tap258336bc-4f&quot;</span>
</span><span class='line'>        tag: 5
</span><span class='line'>    Port patch-tun
</span><span class='line'>            options: <span class="o">{</span><span class="nv">peer</span><span class="o">=</span>patch-int<span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Use <code>ovs-ofctl dump-ports-desc &lt;bridge_ID&gt;</code> command to correlate port names and numbers. Example below is for integration bridge of compute host #1:</li>
</ul>


<figure class='code'><figcaption><span>ovs-ofctl dump-ports-desc br-int | grep addr</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> 2<span class="o">(</span>patch-tun<span class="o">)</span>: addr:5a:c5:44:fc:ac:72
</span><span class='line'> 7<span class="o">(</span>tap258336bc-4f<span class="o">)</span>: addr:fe:16:3e:19:e4:91
</span><span class='line'> LOCAL<span class="o">(</span>br-int<span class="o">)</span>: addr:46:fe:10:de:1b:4f
</span></code></pre></td></tr></table></div></figure>


<p>I&rsquo;ve put together a diagram showing all the relevant integration bridge (<strong>br-int</strong>) and tunnel bridge (<strong>br-tun</strong>) ports on all 3 hosts.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-port-details.png"></p>

<h3>Unicast frame between VM1 and VM2</h3>

<ol>
<li> Frame enters the br-int on port 7. Default iptables rules allow all outbound traffic from a VM.</li>

<li> Inside the br-int our frame is matched by the "catch-all" rule which triggers the flood-and-learn behaviour:

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>10,arp,in_port<span class="o">=</span><span class="m">7</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,24<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span><span class="m">0</span> <span class="nv">actions</span><span class="o">=</span>NORMAL
</span></code></pre></td></tr></table></div></figure></li>

<li> Since it's a unicast frame the MAC address table is already populated by ARP:

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">2</span>     <span class="m">5</span>  fa:16:3e:ab:1a:bf    1
</span></code></pre></td></tr></table></div></figure></li>

Target IP address is behind port 2 which is where the frame gets forwarded next.

<li> Inside the tunnel bridge the frame will match three different tables. The first table simply matches the incoming port and resubmits the frame to table 2. Table 2 will match the unicast bit of the MAC address (the least significant bit of the first byte) and resubmit the frame to unicast table 20:

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1, <span class="nv">in_port</span><span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0, <span class="nv">dl_dst</span><span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>20, <span class="nv">priority</span><span class="o">=</span>1, <span class="nv">vlan_tci</span><span class="o">=</span>0x0005/0x0fff,dl_dst<span class="o">=</span>fa:16:3e:ab:1a:bf <span class="nv">actions</span><span class="o">=</span>load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:0x54-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:2
</span></code></pre></td></tr></table></div></figure>

The final match is done on a VLAN tag and destination MAC address. Resulting action is a combination of three consecutive steps:
<ol>
  <li> Clear the dot1q tag - load:0->NXM_OF_VLAN_TCI[]</li>
  <li> Tag the frame with VNI 0x54 - load:0x54->NXM_NX_TUN_ID[]</li>
  <li> Send the frame to compute host 2 - output:2</li>
</ol>
This last match entry is quite interesting in a way that it contains the destination MAC address of VM2, which means this entry was created <b>after</b> the ARP process. In fact, as we'll see in the next step, this entry is populated by a <b>learn</b> action triggered by the ARP response coming from VM2.
</li>

<li>A VXLAN packet arrives at compute host 2 and enters the tunnel bridge through port 2. It's matched on the incoming port and resubmitted to a table where it is assigned with an internal VLAN ID 3 based on the matched tunnel id 0x54. 

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">2</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,4<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>4, <span class="nv">priority</span><span class="o">=</span>1,tun_id<span class="o">=</span>0x54 <span class="nv">actions</span><span class="o">=</span>mod_vlan_vid:3,resubmit<span class="o">(</span>,10<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>10, <span class="nv">priority</span><span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:NXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span></code></pre></td></tr></table></div></figure>

The last match does two things:
<ol>
  <li> Creates a mirroring entry in table 20 for the reverse packet flow. This is the entry similar to the one we've just seen in step 4.  </li>
  <li> Sends the packet towards the integration bridge.</li>
</ol>
</li>  
<li>The integration bridge checks the local dynamic MAC address table to find the MAC address of VM2(1a:bf).

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>port  VLAN  MAC                Age
</span><span class='line'>  <span class="m">5</span>     <span class="m">3</span>  fa:16:3e:ab:1a:bf    0
</span></code></pre></td></tr></table></div></figure>
</li>

<li>The frame is checked against the iptables rules configured on port 5 and gets sent up to VM2</li>
</ol>


<h3>Unicast frame to external host (192.168.247.1)</h3>

<ol>
  <li>
    The first 5 steps will be similar to the previous section. The only exception will be that the tunnel bridge of compute host 1 will send the VXLAN packet out port 3 towards the network node.
  </li>
  <li>
    The integration bridge of the network node consults the MAC address table to find the location of the virtual router (89:47) and forwards the packet out port 6.
<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">6</span>     <span class="m">1</span>  fa:16:3e:cf:89:47    1
</span></code></pre></td></tr></table></div></figure>
  </li>
  <li> The virtual router does the route lookup to find the outgoing interface (qg-18bff97b-57)
<figure class='code'><figcaption><span>ip route get 192.168.247.1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>192.168.247.1 dev qg-18bff97b-57  src 192.168.247.90
</span></code></pre></td></tr></table></div></figure>
Remember that since our virtual router resides in a network namespace all commands must be prepended with <code>ip netns exec qrouter-uuid</code>
  
  </li>
  <li> The virtual router performs the source IP translation to hide the private IP address: 
<figure class='code'><figcaption><span>iptables -t nat -S | grep qg-18bff97b-57</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>-A neutron-l3-agent-POSTROUTING ! -i qg-18bff97b-57 ! -o qg-18bff97b-57 -m conntrack ! --ctstate DNAT -j ACCEPT
</span><span class='line'>-A neutron-l3-agent-snat -o qg-18bff97b-57 -j SNAT --to-source 192.168.247.90
</span></code></pre></td></tr></table></div></figure>
By default all packets will get translated to the external address of the router. For each assigned floating IP address there will be a pair of source/destination NAT entries created in the same table. 

  </li>
  <li> The router consults its local ARP table to find the MAC address of the next hop:
<figure class='code'><figcaption><span>ip neigh show 192.168.247.1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>192.168.247.1 dev qg-18bff97b-57 lladdr 00:50:56:c0:00:01 DELAY
</span></code></pre></td></tr></table></div></figure>
  </li>
  <li> External bridge receives the frame from the virtual router on port 4, consults its own MAC address table built by ARP and forwards the packet to the final destination.
<figure class='code'><figcaption><span>ovs-appctl fdb/show br-ex</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">4</span>     <span class="m">0</span>  fa:16:3e:5c:90:e0    1
</span><span class='line'>    <span class="m">1</span>     <span class="m">0</span>  00:50:56:c0:00:01    1
</span></code></pre></td></tr></table></div></figure></li>
</ol>


<h3>BUM frame from VM1 for MAC address of VM2</h3>

<ol>
  <li>The integration bridge of the sending host will check the source IP of the ARP packet to make sure it hasn't been spoofed before flooding the packet within the local broadcast domain (VLAN 5).

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>10,arp,in_port<span class="o">=</span><span class="m">7</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,24<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>24, <span class="nv">priority</span><span class="o">=</span>2,arp,in_port<span class="o">=</span>7,arp_spa<span class="o">=</span>10.0.0.8 <span class="nv">actions</span><span class="o">=</span>NORMAL
</span></code></pre></td></tr></table></div></figure>
</li>
<li> The flooded packet reaches the tunnel bridge where it goes through 3 different tables. The first table matches the incoming interface, the second table matches the multicast bit of the MAC address.

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>01:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,22<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>22, <span class="nv">dl_vlan</span><span class="o">=</span><span class="m">5</span> <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x54,output:3,output:2
</span></code></pre></td></tr></table></div></figure>

The final table swaps the dot1q and VXLAN identifiers and does the source replication by forwarding the packet out ports 2 and 3.
</li>
<li> The following steps are similar to the unicast frame propagation with the exception that the local MAC table of the integration bridges will flood the packet to all interfaces in the same broadcast domain. That means that duplicate ARP requests will reach both the private interface of the virtual router and VM2. The latter, recognising its own IP, will send a unicast ARP response whose source IP will be verified by the ARP spoofing rule of the integration bridge. As the result of that process, both integration bridges on compute host 1 and 2 will populate their local MAC tables with addresses of VM1 and VM2.
</li>
</ol>


<h2>Native OpenStack SDN advantages and limitation</h2>

<p>Current implementation of OpenStack networking has several advantages compared to the traditional SDN solutions:</p>

<ul>
<li>Data-plane learning allows network to function even in the absence of the controller node</li>
<li>Multicast source replication does not rely on multicast support in the underlay network</li>
<li>ARP spoofing protection is the default security setting</li>
</ul>


<p>However at this point it should also be clear that there a number of limitations that can impact the overall network scalability and performance:</p>

<ul>
<li>Multicast source replication creates unnecessary overhead by flooding ARP packets to all hosts</li>
<li>All routed traffic has to go through the network node which becomes a bottleneck for the whole network</li>
<li>There is no ability to control physical devices, even the ones that support OVSDB/Openflow</li>
<li>Network node must be layer 2 adjacent with the external network segment</li>
</ul>


<h2>Things to explore next</h2>

<p>In the following posts I&rsquo;ll continue poking around Neutron and explore a number of features designed to address some of the limitations described above:</p>

<ul>
<li><a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">L2 population</a></li>
<li><a href="https://wiki.openstack.org/wiki/Neutron/DVR">Distributed Virtual Router</a></li>
<li><a href="https://wiki.openstack.org/wiki/Neutron/L2-GW">L2 hardware gateway</a></li>
<li><a href="https://wiki.openstack.org/wiki/Neutron/L3_High_Availability_VRRP">Network High Availability</a></li>
<li><a href="https://wiki.openstack.org/wiki/Neutron/LBaaS">Load-Balancing-as-a-Service</a></li>
<li><a href="https://github.com/openstack/networking-ovn">Open Virtual Network for OVS</a></li>
<li><a href="http://specs.openstack.org/openstack/neutron-specs/specs/mitaka/bgp-dynamic-routing.html">Neutron&rsquo;s dynamic BGP routing</a></li>
</ul>


<h2>C<sub>2</sub>O</h2>

<p>While writing this post I&rsquo;ve compiled a list of commands most useful to query the state of OpenvSwitch. So now, inspired by a similar  IOS to JUNOS (I2J) command <a href="http://www.net-gyver.com/?page_id=1166">conversion tables</a>, I&rsquo;ve put together my own Cisco to OVS conversion table, just for fun.</p>

<table>
<thead>
<tr>
<th> Action </th>
<th> Cisco </th>
<th> OpenvSwitch </th>
</tr>
</thead>
<tbody>
<tr>
<td> Show MAC address table </td>
<td> show mac address-table dynamic   </td>
<td> <code>ovs-appctl fdb/show &lt;bridge_id&gt;</code> </td>
</tr>
<tr>
<td> Clear MAC address table </td>
<td> clear mac address-table dynamic </td>
<td> <code>ovs-appctl fdb/flush &lt;bridge_id&gt;</code> </td>
</tr>
<tr>
<td> Show port numbers </td>
<td> show interface status </td>
<td> <code>ovs-ofctl dump-ports-desc &lt;bridge_ID&gt;</code> </td>
</tr>
<tr>
<td> Show OVS configuration </td>
<td> show run </td>
<td> <code>ovs-vsctl show</code> </td>
</tr>
<tr>
<td> Show packet forwarding rules </td>
<td> show ip route  </td>
<td> <code>ovs-ofctl dump-flows &lt;bridge_id&gt;</code> </td>
</tr>
<tr>
<td> Simulate packet flow </td>
<td> packet-tracer   </td>
<td> <code>ovs-appctl ofproto/trace &lt;bridge_id&gt; in_port=1</code> </td>
</tr>
<tr>
<td> View command history </td>
<td> show archive log config </td>
<td> <code>ovsdb-tool show-log -m</code> </td>
</tr>
</tbody>
</table>


<h2>References</h2>

<p>In this post I have glossed over some details like iptables and DHCP for the sake of brevity and readability. However this post wouldn&rsquo;t be complete if I didn&rsquo;t include references to other resources that contain a more complete, even if at times outdated, overview of OpenStack networking. This is also a way to pay tribute to blogs where I&rsquo;ve learned most of what I was writing about here:</p>

<ul>
<li><a href="https://www.rdoproject.org/networking/networking-in-too-much-detail/">Networking in too much detail</a></li>
<li><a href="http://www.opencloudblog.com/?p=300">Neutron using VXLAN</a></li>
<li><a href="http://docs.ocselected.org/openstack-manuals/kilo/networking-guide/content/under_the_hood_openvswitch.html">Under the hood of OVS</a></li>
<li><a href="https://kimizhang.wordpress.com/2014/04/01/how-ml2vxlan-works/">How ML2/VXLAN works</a></li>
<li><a href="http://docs.openstack.org/openstack-ops/content/network_troubleshooting.html">Official network troubleshooting guide</a></li>
<li><a href="http://therandomsecurityguy.com/openvswitch-cheat-sheet/">OVS commands cheat sheet</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Multi-node OpenStack Lab in UNetLab]]></title>
    <link href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/"/>
    <updated>2016-04-18T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/04/18/os-unl-lab</id>
    <content type="html"><![CDATA[<p>In the <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous post</a> I&rsquo;ve demonstrated how to get a working instance of a single-node OpenStack inside <a href="http://www.unetlab.com/">UNetLab</a>. In this post we&rsquo;ll continue building on that by adding two new compute nodes and redesigning our network to resemble something you might actually see in a real life.</p>

<!--more-->


<h2>OpenStack network requirements</h2>

<p>Depending on the number of deployed <a href="https://www.openstack.org/software/project-navigator/">components</a>, OpenStack physical network requirements could be different. In our case we&rsquo;re not going to deploy any storage solution and simply use the <strong>ephemeral</strong> storage, i.e. hard disk that&rsquo;s a part of a virtual machine. However, even in minimal installations, there are a number of networks that should be considered individually due to different connectivity requirements:</p>

<ul>
<li><p>Server <abbr title=" Out-Of-Band">OOB</abbr> <strong>management</strong> network - this is usually a dedicated physical network used mainly for server bootstrapping and OS deployment. It is a Layer 3 network with DHCP relays configured at each edge L3 interface and access to Internet package repositories.</p></li>
<li><p><strong>API</strong> network - used for internal communication between various OpenStack services. This can be a routed network without Internet access. The only requirement is any-to-any reachability within a single OpenStack environment.</p></li>
<li><p><strong>External</strong> network - used for public access to internal OpenStack virtual machines. This is the <em>outside</em> of OpenStack, with a pool of IP addresses used to NAT the internal IPs of public-facing virtual machines. This network <strong>must</strong> be Layer 2 adjacent <strong>only</strong> with a network control node.</p></li>
<li><p><strong>Tenant</strong> network - used for communication between virtual machines within OpenStack environment. Thanks to the use of VXLAN overlay, this can be a simple routed network that has any-to-any reachability between all Compute and Network nodes.</p></li>
</ul>


<h2>Building a lab network</h2>

<p>For labbing purposes it&rsquo;s possible to relax some of the above network requirements without seriously affecting the outcomes of our simulation. For example, it&rsquo;s possible to combine some of the networks and still satisfy the requirements stated above. These are the networks that will be configured inside UNetLab:</p>

<ul>
<li><p><strong>Management</strong> - this network will combine the functions of OOB and API networks. To isolate it from our data centre underlay I&rsquo;ll be using separate interfaces on virtual machines and connect them directly to Workstation&rsquo;s NAT interface (192.168.91.0/24 in my case)  to give them direct access to Internet.</p></li>
<li><p><strong>External</strong> - this network will be connected to Workstation&rsquo;s host-only NIC (192.168.247.0/24) through Vlan300 configured on one of the leaf switches. Since it must be L2 adjacent with the network control node our leaf switch will not perform any routing for this subnet.</p></li>
<li><p><strong>Tenant</strong> - this will be a routed leaf/spine <a href="https://en.wikipedia.org/wiki/Clos_network">Clos</a> fabric comprised of 3 leaf and 2 spine switches running a single-area OSPF process on all their links. Each server will have its own unique tenant subnet (Vlan100) terminated on the leaf switch and subnet injected into OSPF. The subnet used for this Vlan is going to be <code>10.0.X.0/24</code>, where X is the number of the leaf switch terminating the vlan.</p>

<p>  The links between switches are all L3 point-to-point with addresses borrowed from 169.254.0.0/16 range specifically to emphasize the fact that the internal addressing does not need to be known or routed outside of the fabric. The <strong>sole function of the fabric</strong> is to provide multiple equal cost paths between any pair of leafs, thereby achieving maximum link utilisation. Here&rsquo;s an example of a traceroute between Vlan100&rsquo;s of Leaf #1 and Leaf #3.</p></li>
</ul>


<figure class='code'><figcaption><span>Traceroute inside an ECMP routed Clos fabric</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>L3#traceroute 10.0.1.1 source 10.0.3.1
</span><span class='line'>Type escape sequence to abort.
</span><span class='line'>Tracing the route to 10.0.1.1
</span><span class='line'>VRF info: (vrf in name/id, vrf out name/id)
</span><span class='line'>  1 169.254.31.111 1 msec
</span><span class='line'>    169.254.32.222 0 msec
</span><span class='line'>    169.254.31.111 0 msec
</span><span class='line'>  2 169.254.12.1 1 msec
</span><span class='line'>    169.254.11.1 1 msec *
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>Building lab servers</h2>

<p>Based on my experience a standard server would have at least 3 physical interfaces - one for OOB management and a pair of interfaces for application traffic. The two application interfaces will normally be combined in a single <abbr title=" Link Aggregation Group">LAG</abbr> and connected to a pair of MLAG-capable TOR switches. Multi-chassis LAG or <a href="http://blog.ipspace.net/2010/10/multi-chassis-link-aggregation-basics.html">MLAG</a> is a pretty old and well-understood technology so I&rsquo;m not going to try and simulate it in the lab. Instead I&rsquo;ll simply assume that a server will be connected to a TOR switch via a single physical link. That link will be setup as a dot1q trunk to allow for multiple subnets to share it.</p>

<h2>Physical lab topology</h2>

<p>All the above requirements and assumptions result in the following topology that we need to build inside UNetLab:</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-native.png"></p>

<p>For servers I&rsquo;ll be using OpenStack node type that I&rsquo;ve described in my <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous post</a>. The two compute nodes do not need as much RAM as the control node, so I&rsquo;ll reduce it to just 2GB.</p>

<p>For switches I&rsquo;ll be using a Cisco&rsquo;s <a href="http://www.unetlab.com/2014/11/adding-cisco-iouiol-images/">L2 IOU</a> image for now, mainly due to the low resource requirements. In the future I&rsquo;ll try and swap it for something else. As you can see from the sample config below, fabric configuration is very basic and can be easily replaced by any other solution:</p>

<figure class='code'><figcaption><span>Leaf 1 configuration</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>interface Ethernet0/0
</span><span class='line'> no switchport
</span><span class='line'> ip address 169.254.11.1 255.255.255.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> duplex auto
</span><span class='line'>!
</span><span class='line'>interface Ethernet0/1
</span><span class='line'> no switchport
</span><span class='line'> ip address 169.254.12.1 255.255.255.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> duplex auto
</span><span class='line'>!
</span><span class='line'>interface Ethernet0/2
</span><span class='line'> switchport trunk allowed vlan 100
</span><span class='line'> switchport trunk encapsulation dot1q
</span><span class='line'> switchport mode trunk
</span><span class='line'>!
</span><span class='line'>interface Vlan100
</span><span class='line'> ip address 10.0.1.1 255.255.255.0
</span><span class='line'>!
</span><span class='line'>router ospf 1
</span><span class='line'> network 0.0.0.0 255.255.255.255 area 0
</span></code></pre></td></tr></table></div></figure>


<h2>Server configuration and OpenStack installation</h2>

<p>Refer to my <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous blogpost</a> for instructions on how to install OpenStack and follow the first 5 steps from &ldquo;Installing CentOS and Openstack&rdquo; section. Before doing the final step, we need to configure our VMs' new interfaces:</p>

<ul>
<li>Remove any IP configuration from <strong>eth1</strong> interface to make it look like this:</li>
</ul>


<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-eth1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="na">TYPE</span><span class="o">=</span><span class="s">Ethernet</span>
</span><span class='line'><span class="na">BOOTPROTO</span><span class="o">=</span><span class="s">none</span>
</span><span class='line'><span class="na">DEVICE</span><span class="o">=</span><span class="s">eth1</span>
</span><span class='line'><span class="na">ONBOOT</span><span class="o">=</span><span class="s">yes</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Configure <strong>Tenant network</strong>:</li>
</ul>


<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-eth1.100</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="na">VLAN</span><span class="o">=</span><span class="s">yes</span>
</span><span class='line'><span class="na">DEVICE</span><span class="o">=</span><span class="s">eth1.100</span>
</span><span class='line'><span class="na">BOOTPROTO</span><span class="o">=</span><span class="s">none</span>
</span><span class='line'><span class="na">IPADDR</span><span class="o">=</span><span class="s">10.0.X.10</span>
</span><span class='line'><span class="na">PREFIX</span><span class="o">=</span><span class="s">24</span>
</span><span class='line'><span class="na">ONBOOT</span><span class="o">=</span><span class="s">yes</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Setup a <strong>static route</strong> to all other leaf nodes:</li>
</ul>


<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/route-eth1.100</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="err">10.0.0.0/8</span> <span class="err">via</span> <span class="err">10.0.X.1</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>On Control node setup <strong>External network</strong> interface</li>
</ul>


<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/route-eth1.300</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="na">DEVICE</span><span class="o">=</span><span class="s">eth1.300</span>
</span><span class='line'><span class="na">IPADDR</span><span class="o">=</span><span class="s">192.168.247.100</span>
</span><span class='line'><span class="na">PREFIX</span><span class="o">=</span><span class="s">24</span>
</span><span class='line'><span class="na">ONBOOT</span><span class="o">=</span><span class="s">yes</span>
</span><span class='line'><span class="na">BOOTPROTO</span><span class="o">=</span><span class="s">none</span>
</span><span class='line'><span class="na">VLAN</span><span class="o">=</span><span class="s">yes</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now we&rsquo;re ready to kick off OpenStack installation. This can be done with a single command that needs to be executed on the Control node. Note that <code>eth1.100</code> interface is spelled as <code>eth1_100</code> in the last line.</p>

<figure class='code'><figcaption><span>Controller</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>packstack --allinone <span class="se">\</span>
</span><span class='line'>    --os-cinder-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-ceilometer-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-trove-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-ironic-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --nagios-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-swift-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-gnocchi-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-aodh-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-neutron-ovs-bridge-mappings<span class="o">=</span>extnet:br-ex <span class="se">\</span>
</span><span class='line'>    --os-neutron-ovs-bridge-interfaces<span class="o">=</span>br-ex:eth1.300 <span class="se">\</span>
</span><span class='line'>    --os-neutron-ml2-type-drivers<span class="o">=</span>vxlan,flat <span class="se">\</span>
</span><span class='line'>    --provision-demo<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-compute-hosts<span class="o">=</span>192.168.91.10,192.168.91.11,192.168.91.12 <span class="se">\</span>
</span><span class='line'>    --os-neutron-ovs-tunnel-if<span class="o">=</span>eth1_100
</span></code></pre></td></tr></table></div></figure>


<h2>Creating a virtual network for a pair of VMs</h2>

<p>Once again, follow all steps from &ldquo;Configuring Openstack networking&rdquo; section of my <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous blogpost</a>. Only this time when setting up a public subnet, update the subnet details to match our current environment:</p>

<figure class='code'><figcaption><span>Step 3 - Creating a public subnet</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>  neutron subnet-create --name public_subnet <span class="se">\</span>
</span><span class='line'>    --enable_dhcp<span class="o">=</span>False <span class="se">\</span>
</span><span class='line'>    --allocation-pool<span class="o">=</span><span class="nv">start</span><span class="o">=</span>192.168.247.90,end<span class="o">=</span>192.168.247.126 <span class="se">\</span>
</span><span class='line'>    --gateway<span class="o">=</span>192.168.247.1 external_network 192.168.247.0/24
</span></code></pre></td></tr></table></div></figure>


<h2>Nova-scheduler and setting up host aggregates</h2>

<p>OpenStack&rsquo;s Nova project is responsible for managing virtual machines. Nova controller views all available compute nodes as a single pool of resources. When a new VM is to be instantiated, a special process called nova-scheduler examines all available compute nodes and selects the &ldquo;best&rdquo; one based on a special algorithm, which normally takes into account amount of RAM, CPU and other host capabilities.</p>

<p>To make our host selection a little bit more deterministic, we can define a group of compute servers via <strong>host aggregates</strong>, which will be used by nova-scheduler in its selection algorithm. Normally it could include all servers in a single rack or a row of racks. In our case we&rsquo;ll setup two host aggregates each with a single compute host. This way we&rsquo;ll be able to select exactly which compute host to use when instantiating a new virtual machine.</p>

<p>To setup it up, from Horizon&rsquo;s dashboard navigate to Admin -> System and create two host aggregates <strong>comp-1</strong> and <strong>comp-2</strong>, each including a single compute host.</p>

<h2>Creating workloads and final testing</h2>

<p>Using a process described in &ldquo;Spinning up a VM&rdquo; section of my <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous blogpost</a>, create a couple of virtual machines assigning them to different host aggregates created earlier.</p>

<h2>Security and Remote access</h2>

<p>To access these virtual machines we need to give them a <a href="https://www.rdoproject.org/networking/floating-ip-range/">floating</a> ip address from the External subnet range. To do that navigate to Project -> Compute -> Instances and select <strong>Associate Floating IP</strong> from the Actions drop-down menu.</p>

<p>The final steps is to allow remote SSH access. Each new VM inherits ACLs from a default security group. So the easiest way to allow SSH is to go to Project -> Compute -> Access &amp; Security and add a rule to allow inbound SSH connections for the default security group.</p>

<h2>Verification</h2>

<p>At this stage you should be able to SSH into the floating IP addresses assigned to the two new VMs using the default credentials. Feel free to poke around and explore Horizon&rsquo;s interface a bit more. For example, try setting up an SSH key pair and re-build our two VMs to allow passwordless SSH access.</p>

<h2>What to expect next</h2>

<p>In the next post we&rsquo;ll explore some of the basic concepts of OpenStack&rsquo;s SDN. We&rsquo;ll peak inside the internal implementation of virtual networks and see what are some of their limitations and drawbacks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack on UNetlab]]></title>
    <link href="http://networkop.github.io/blog/2016/04/04/openstack-unl/"/>
    <updated>2016-04-04T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/04/04/openstack-unl</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;m going to show how to get a running instance of Openstack inside a UNetLab virtual machine.</p>

<!--more-->


<p><img class="center" src="http://networkop.github.io/images/unl-os.png"></p>

<h2>What the hell am I trying to do?</h2>

<p>I admit that running Openstack on anything other than baremetal is nonsense. So why would anyone want to run it with two layers of virtualisation underneath? My goal is to explore some of the new SDN/NFV technologies without leaving the confines on my home area network and/or racking up a triple-digit electricity bill. I also wanted to be able to swap underlay networks without spending hours trying to plumb together virtualized switches and servers from multiple vendors. That&rsquo;s why I&rsquo;ve decided to use UNetLab VM as a host for my Openstack lab. This would allow me to easily assemble any type of underlay, WAN or DCI network and with hardware virtualisation support I can afford to run Openstack double-nested inside Workstation and Qemu on my dual-core i7 without too much of a performance penalty. After all, <a href="https://www.ravellosystems.com/technology/hvx">some companies</a> even managed to turn similar things into a commercial product.</p>

<p>My interest in Openstack is strictly limited by networking, that&rsquo;s why a lot of the things you&rsquo;ll see in this and following posts will not be applicable to a real-life production environment. However, as far as networking is concerned, I&rsquo;ll try to stick as close to the official Openstack <a href="http://docs.openstack.org/openstack-ops/content/example_architecture.html">network design</a> as possible. I&rsquo;ll be using <a href="https://www.rdoproject.org">RDO</a> to deploy Openstack. The specific method will be Packstack which is a collection of Puppet modules used to deploy Openstack components.</p>

<p>Why have I not went the OpenDaylight/Mininet way if I wanted to play with SDN/NFV? Because I wanted something more realistic to play with, that wouldn&rsquo;t feel like vendor&rsquo;s powerpoint presentation. Plus there&rsquo;s plenty of resources on the &lsquo;net about it anyway.</p>

<p>So, without further ado, let&rsquo;s get cracking.</p>

<h2>Setting the scene</h2>

<p>On my Windows 8 laptop I&rsquo;ve got a UNL virtual machine running inside a VMWare Workstation.. I&rsquo;ve <a href="http://www.unetlab.com/download/">downloaded</a> and <a href="http://www.unetlab.com/2014/11/upgrade-unetlab-installation/">upgraded</a> a pre-built UNL VM image. I&rsquo;ve also downloaded a copy of the <a href="http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1511.iso">Centos 7 minimal ISO image</a> and copied it over to my UNL VM&rsquo;s home directory.</p>

<p>For network access I&rsquo;ll be using VMWware Workstation&rsquo;s NAT interface. It&rsquo;s currently configured with <code>192.168.91.0/24</code> subnet with DHCP range of <code>.128-.254</code>. Therefore I&rsquo;ll be using <code>.10-.126</code> to allocate IPs to my Openstack servers.</p>

<h2>Creating a custom node type in UNL</h2>

<p>Every node type inside UNL has its own unique settings. Some settings, like amount of RAM, CPU or number of network interfaces, can be changed during node instantiation, while some of them remain &ldquo;baked in&rdquo;. Say, for example, the default &ldquo;Linux&rdquo; template creates nodes with default <strong>Qemu Virtual CPU</strong> which doesn&rsquo;t support the hardware virtualisation (<strong>VT-X/AMD-V</strong>) <a href="http://docs.openstack.org/liberty/config-reference/content/kvm.html">required</a> by Openstack. In order to change that you can either edit the existing node template or follow these steps to create a new one:</p>

<ol>
<li><p>Add Openstack node definition to initialization file <code>/opt/unetlab/html/includes/init.php</code>.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'>    <span class="s1">&#39;linux&#39;</span>                 <span class="o">=&gt;</span>      <span class="s1">&#39;Linux&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s1">&#39;openstack&#39;</span>             <span class="o">=&gt;</span>      <span class="s1">&#39;Openstack&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s1">&#39;mikrotik&#39;</span>              <span class="o">=&gt;</span>      <span class="s1">&#39;MikroTik RouterOS&#39;</span><span class="p">,</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create a new Openstack node template based on existing linux node template.</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>cp /opt/unetlab/html/templates/linux.php /opt/unetlab/html/templates/openstack.php
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Edit the template file replacing all occurences of &lsquo;Linux&rsquo; with &lsquo;Openstack&rsquo;</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>sed -i <span class="s1">&#39;s/Linux/Openstack/g; s/linux/openstack/g&#39;</span> /opt/unetlab/html/templates/openstack.php
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Edit the template file to double the RAM and CPU and pass all host&rsquo;s CPU instructions to Openstack nodes</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>sed -i <span class="s1">&#39;s/2048/4096/; s/(cpu.*) = 1/\1 = 2/; s/(order=)dc/\1cd -cpu host/&#39;</span> /opt/unetlab/html/templates/openstack.php
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
</ol>


<p>At this point you should be able to navigate to UNL&rsquo;s web interface and find a new node of type Openstack. However you won&rsquo;t be able to create it until you have at least one image, which is what we&rsquo;re going to build next.</p>

<h2>Building a Linux VM inside UNetLab</h2>

<p>Now we need to create a CentOS image inside a UNL. One way to do it is build it inside a VMWare Workstation, copy it to UNL and convert the <strong>.vmdk</strong> to <strong>.qcow2</strong>. However, when I tried doing this I ran into a problem with CentOS not finding the correct disk partitions during bootup. The workaround was to boot into rescue mode and rebuild the initramfs. For those feeling adventurous, I would recommend checking out the following links [<a href="https://wiki.centos.org/TipsAndTricks/CreateNewInitrd">1</a>, <a href="http://advancelinux.blogspot.com.au/2013/06/how-to-rebuild-initrd-or-initramfs-in.html">2</a>, <a href="http://forums.fedoraforum.org/showthread.php?t=288020">3</a>] before trying this option.<br/>
The other option is to build CentOS inside UNL from scratch. This is how you can do it:</p>

<ol>
<li><p>Create a new directory for Openstack image</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>mkdir -p /opt/unetlab/addons/qemu/openstack-1
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create a link to CentOS ISO boot image from our new directory</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>ln -s ~/CentOS-7-x86_64-Minimal-1511.iso /opt/unetlab/addons/qemu/openstack-1/cdrom.iso
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create a blank 6Gb disk image</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>/opt/qemu/bin/qemu-img create -f qcow2 -o <span class="nv">preallocation</span><span class="o">=</span>metadata /opt/unetlab/addons/qemu/openstack-1/virtioa.qcow2 6G
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p> If you want to create <strong>snapshots</strong> at any stage of the process you&rsquo;d need to use a copy of this file under /opt/unetlab/tmp/pod_id/lab_uuid/node_id/ directory</p></li>
</ol>


<p>Now you should be able to successfully create an Openstack node and connect it to Internet. Create a new network that would have Internet connectivity (in my case it&rsquo;s <strong>pnet0</strong>) and connect it to Openstack&rsquo;s <strong>eth0</strong>.  At this stage we have everything ready to start installing Openstack, but before we move on let me take a quick detour to tell you about my ordeals with VNC integration.</p>

<h2>Optional: Integrating TightVNC with UNL</h2>

<p>For some unknown reason UltraVNC does not work well on my laptop. My sessions would often crash or start minimised with the only option to close the window. That&rsquo;s not the only thing not working properly on my laptop thanks to the corporate policies with half of the sh*t locked down for <em>security</em> reasons.<br/>
So instead of mucking around with <strong>Ultra</strong> I decided to give me old pal <strong>Tight</strong>VNC a go. The setup process is very similar to the <a href="http://www.unetlab.com/2015/03/url-telnet-ssh-vnc-integration-on-windows/">official VNC integration guide</a> with the following exceptions:</p>

<ol>
<li><p>The wrapper file simply strips the leading &lsquo;vnc://&rsquo; and trailing &lsquo;/&rsquo; off the passed argument</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='winbatch'><span class='line'>   <span class="k">SET</span> <span class="nv">arg</span><span class="o">=</span><span class="nv">%1</span>
</span><span class='line'>   <span class="k">SET</span> <span class="nv">arg</span><span class="o">=</span><span class="nv">%arg:~6%</span>
</span><span class='line'>   <span class="k">SET</span> <span class="nv">arg</span><span class="o">=</span><span class="nv">%arg:~0</span><span class="p">,</span><span class="m">-1</span>%
</span><span class='line'>   start <span class="s2">&quot;&quot;</span> <span class="s2">&quot;c:\Program Files\TightVNC\tvnviewer.exe&quot;</span> <span class="nv">%arg%</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>The registry entry now points to the TightVNC wrapper</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='registry'><span class='line'>   <span class="k">[</span><span class="nb">HKEY_CLASSES_ROOT</span><span class="k">\vnc\shell\open\command]</span>
</span><span class='line'>   <span class="na">@</span><span class="o">=</span><span class="s">&quot;\&quot;c:\Program Files\TightVNC\wrapper.bat\&quot; %1&quot;</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
</ol>


<h2>Installing CentOS and Openstack</h2>

<p>Finally, we&rsquo;ve got all our ducks lined up in a row and we&rsquo;re ready to shoot. Fire up the Openstack node inside UNL and click on it to open a vnc session. Proceed to install CentOS with default options. You need to confirm which <strong>hard disk</strong> to use and setup the <strong>hostname</strong> and the <strong>root password</strong> during installation process.
As I mentioned earlier, we&rsquo;ll be using RDO&rsquo;s Packstack to deploy all the necessary Openstack components. The whole installation process will be quite simple and can be found on the RDO&rsquo;s <a href="https://www.rdoproject.org/install/quickstart/">quickstart page</a>. Here is my slightly modified version of installation process:</p>

<ol>
<li><p>Disable Network Manager and SELinux.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>service NetworkManager stop
</span><span class='line'>    <span class="nv">$ </span>systemctl disable NetworkManager.service
</span><span class='line'>    <span class="nv">$ </span>setenforce 0
</span><span class='line'>    <span class="nv">$ </span>sed -i <span class="s1">&#39;s/enforcing/permissive/&#39;</span> /etc/selinux/config
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Configure static IP address <code>192.168.91.10</code> on the network interface. <br/>
 Assuming your interface name is <code>eth0</code> make sure you /etc/sysconfig/network-scripts/ifcfg-eth0 looks something like this:</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">TYPE</span><span class="o">=</span><span class="s2">&quot;Ethernet&quot;</span>
</span><span class='line'>    <span class="nv">BOOTPROTO</span><span class="o">=</span><span class="s2">&quot;static&quot;</span>
</span><span class='line'>    <span class="nv">IPADDR</span><span class="o">=</span>192.168.91.10
</span><span class='line'>    <span class="nv">PREFIX</span><span class="o">=</span>24
</span><span class='line'>    <span class="nv">GATEWAY</span><span class="o">=</span>192.168.91.2
</span><span class='line'>    <span class="nv">DNS1</span><span class="o">=</span>192.168.91.2
</span><span class='line'>    <span class="nv">NAME</span><span class="o">=</span><span class="s2">&quot;eth0&quot;</span>
</span><span class='line'>    <span class="nv">DEVICE</span><span class="o">=</span><span class="s2">&quot;eth0&quot;</span>
</span><span class='line'>    <span class="nv">ONBOOT</span><span class="o">=</span><span class="s2">&quot;yes&quot;</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  Issue a <code>service network restart</code> and reconnect to the new static IP address. Make sure that you still have access to Internet after making this change.</p></li>
<li><p>Setup RDO repositories</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>sudo yum install -y <a href="https://rdoproject.org/repos/rdo-release.rpm">https://rdoproject.org/repos/rdo-release.rpm</a>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Update your current packages</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>sudo yum update -y
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Install Packstack</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>sudo yum install -y openstack-packstack
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  That&rsquo;s where it&rsquo;d make sense to take a snapshot with <code>qemu-img snapshot -c pre-install virtioa.qcow2</code> command</p></li>
<li><p>Deploy a single-node Openstack environment</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>packstack <span class="se">-</span>-allinone <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-cinder-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-ceilometer-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-trove-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-ironic-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-nagios-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-swift-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-neutron-ovs-bridge-mappings<span class="o">=</span>extnet:br-ex <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-neutron-ovs-bridge-interfaces<span class="o">=</span>br-ex:eth0 <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-neutron-ml2-type-drivers<span class="o">=</span>vxlan,flat <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-provision-demo<span class="o">=</span>n
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  Here we&rsquo;re overriding some of the default Packstack options. We&rsquo;re not installing some of the components we&rsquo;re not going to use and setting up a name (<strong>extnet</strong>) for our external physical segment, which we&rsquo;ll use in the next section.</p></li>
</ol>


<p>At the end of these 4 steps you should be able to navigate to Horizon (Openstack&rsquo;s dashboard) by typing <code>http://192.168.91.10</code> in your browser. You can find login credentials in the <code>~/keystonerc_admin</code> file.</p>

<h2>Configuring Openstack networking</h2>

<p>At this stage we need to setup virtual networking infrastructure inside Openstack. This will be almost the same as described in RDO&rsquo;s external network <a href="https://www.rdoproject.org/networking/neutron-with-existing-external-network/">setup guide</a>. The only exceptions will be the <a href="https://www.rdoproject.org/networking/difference-between-floating-ip-and-private-ip/">floating IP range</a>, which will match our existing environment, and the fact that we&rsquo;re no going to setup any additional tenants yet. This is how our topology will look like:</p>

<p><img class="center" src="http://networkop.github.io/images/os-net-1.png"></p>

<ol>
<li><p>Switch to Openstack&rsquo;s <code>admin</code> user
 <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span><span class="nb">source</span> ~/keystonerc_admin
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create external network
 <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    neutron net-create external_network <span class="se">-</span>-provider:network_type flat <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-provider:physical_network extnet  <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-router:external <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-shared
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create a public subnet</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    neutron subnet-create <span class="se">-</span>-name public_subnet <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-enable_dhcp<span class="o">=</span>False <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-allocation-pool<span class="o">=</span><span class="nv">start</span><span class="o">=</span>192.168.91.90,end<span class="o">=</span>192.168.91.126 <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-gateway<span class="o">=</span>192.168.91.2 external_network 192.168.91.0/24
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  Default gateway is VMware&rsquo;s NAT IP address</p></li>
<li><p>Create a private network and subnet</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    neutron net-create private_network
</span><span class='line'>    neutron subnet-create <span class="se">-</span>-name private_subnet private_network 10.0.0.0/24 <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-dns-nameserver 8.8.8.8
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>   This network is not routable outside of Openstack and is used for inter-VM communication</p></li>
<li><p>Create a virtual router and attach it to both networks</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    neutron router-create router
</span><span class='line'>    neutron router-gateway-set router external_network
</span><span class='line'>    neutron router-interface-add router private_subnet
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
</ol>


<p>Make sure to check out the visualisation of our newly created network topology in Horizon, it&rsquo;s amazing.</p>

<h2>Spinning up a VM</h2>

<p>There&rsquo;s no point in installing Openstack just for the sake of it. Our final step would be to create a working virtual machine that would be able to connect to Internet.</p>

<ol>
<li><p>Download a test linux image</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    curl <a href="http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img">http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img</a> <span class="p">|</span> glance <span class="se">\</span>
</span><span class='line'>    image-create <span class="se">-</span>-name<span class="o">=</span><span class="s1">&#39;cirros image&#39;</span> <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-visibility<span class="o">=</span>public <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-container-format<span class="o">=</span>bare <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-disk-format<span class="o">=</span>qcow2
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>From Horizon&rsquo;s home page navigate to Project -> Compute -> Images.</p></li>
<li><p>Click on <code>Launch Instance</code> and give the new VM a name.</p></li>
<li><p>Make sure it&rsquo;s attached to <code>private_network</code> under the Networking tab.</p></li>
<li><p>Less then a minute later the status should change to <code>Active</code> and you can navigate to VM&rsquo;s console by clicking on its name and going to <code>Console</code> tab.</p></li>
<li><p>Login using the default credentials (<strong>cirros/cubswin:)</strong>) and verify Internet access by pinging google.com.</p></li>
</ol>


<p>Congratulations, we have successfully created a VM running inside a KVM inside a KVM inside a VMWare Workstation inside Windows!</p>

<h2>What to expect next</h2>

<p>Unlike my other post series, I don&rsquo;t have a clear goal at this stage so I guess I&rsquo;ll continue playing around with different underlays for multi-node Openstack and then move on to various SDN solutions available like OpenDayLight and OpenContrail. Unless I lose interest half way through, which happened in the past. But until that happens, stay tuned for more.</p>
]]></content>
  </entry>
  
</feed>
