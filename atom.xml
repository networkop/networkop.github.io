<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Network-oriented programming]]></title>
  <link href="http://networkop.github.io/atom.xml" rel="self"/>
  <link href="http://networkop.github.io/"/>
  <updated>2016-12-10T17:53:59+00:00</updated>
  <id>http://networkop.github.io/</id>
  <author>
    <name><![CDATA[Michael Kashin]]></name>
    <email><![CDATA[mmkashin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OpenStack SDN With OVN (Part 2) - Network Engineering Analysis]]></title>
    <link href="http://networkop.github.io/blog/2016/12/08/ovn-part2/"/>
    <updated>2016-12-08T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2016/12/08/ovn-part2</id>
    <content type="html"><![CDATA[<p>In this post we will see how OVN implements virtual networks for OpenStack. The structure of this post is such that starting from the highest level of networking abstraction we will delve deeper into implementation details with each subsequent section. The biggest emphasis will be on how networking data model gets transformed into a set of logical flows, which eventually become OpenFlow flows. The final section will introduce a new overlay protocol GENEVE and explain why VXLAN no longer satisfies the needs of an overlay protocol.</p>

<!--more-->


<h2>OpenStack - virtual network topology</h2>

<p>In the <a href="http://networkop.github.io/blog/2016/11/27/ovn-part1/">previous post</a> we have installed OpenStack and created a simple virtual topology as shown below. In OpenStack&rsquo;s data model this topology consists of the following elements:</p>

<ul>
<li><strong>Network</strong> defines a virtual L2 broadcast domain</li>
<li><strong>Subnet</strong> attached to the network, defines an IP subnet within the network</li>
<li><strong>Router</strong> provides connectivity between all directly connected subnets</li>
<li><strong>Port</strong> VM&rsquo;s point of attachment to the subnet</li>
</ul>


<p><img class="center" src="http://networkop.github.io/images/ovn-zoom1.png"></p>

<p>So far nothing unusual, this is a simple Neutron data model, all that information is stored in Neutron&rsquo;s database and can be queried with <code>neutron</code> CLI commands.</p>

<h2>OVN Northbound DB - logical network topology</h2>

<p>Every call to implement an element for the above data model is forwarded to OVN ML2 driver as defined by the <code>mechanism driver</code> setting of the ML2 plugin. This driver is responsible for the creation of an appropriate data model inside the OVN Northbound DB. The main elements of this data model are:</p>

<ul>
<li><strong>Switch</strong> equivalent of a Neutron&rsquo;s Subnet, enables L2 forwarding for all attached ports</li>
<li><strong>Distributed Router</strong> provides distributed routing between directly connected subnets</li>
<li><strong>Gateway Router</strong> provides connectivity between external networks and distributed routers, implements NAT and Load Balancing</li>
<li><strong>Port</strong> of a logical switch, attaches VM to the switch</li>
</ul>


<p>This is a visual representation of our network topology inside OVN&rsquo;s Northbound DB, built based on the output of <code>ovn-nbctl show</code> command:</p>

<p><img class="center" src="http://networkop.github.io/images/ovn-zoom2.png"></p>

<p>This topology is pretty similar to Neutron&rsquo;s native data model with the exception of a gateway router. In OVN, a gateway router is a special non-distributed router which performs functions that are very hard or impossible to distribute amongst all nodes, like NAT and Load Balancing. This router only exists on a single compute node which is selected by the scheduler based on the <code>ovn_l3_scheduler</code> setting of the ML2 plugin. It is attached to a distributed router via a point-to-point /30 subnet defined in the <code>ovn_l3_admin_net_cidr</code> setting of the ML2 plugin.</p>

<p>Apart from the logical network topology, Northbound database keeps track of all QoS, NAT and ACL settings and their parent objects. The detailed description of all tables and properties of this database can be found in the official <a href="http://openvswitch.org/support/dist-docs/ovn-nb.5.html">Northbound DB documentation</a>.</p>

<h2>OVN Southbound DB - logical flows</h2>

<p>OVN <a href="http://openvswitch.org/support/dist-docs/ovn-northd.8.html">northd</a> process running on the controller node translates the above logical topology into a set of tables stored in Southbound DB. Each row in those tables is a logical flow and together they form a <strong>forwarding pipeline</strong> by stringing together multiple actions to be performed on a packet. These actions range from packet drop through packet header modification to packet output. The stringing is implemented with a special <code>next</code> action which moves the packet one step down the pipeline starting from table 0. Let&rsquo;s have a look at the <strong>simplified</strong> versions of L2 and L3 forwarding pipelines using examples from our virtual topology.</p>

<h3>L2 datapath</h3>

<p>In the first example we&rsquo;ll explore the L2 datapath between VM1 and VM3. Both VMs are attached to the ports of the same logical switch. The full datapath of a logical switch consists of two parts - ingress and egress datapath (the direction is from the perspective of a logical switch). The ultimate goal of an ingress datapath is to determine the output port or ports (in case of multicast) and pass the packet to the egress datapath. The egress datapath does a few security checks before sending the packet out to its destination. Two things are worth noting at this stage:</p>

<ol>
<li>The two datapaths can be located either on the same or on two different hypervisor nodes. In the latter case, the packet is passed between the two nodes in an overlay tunnel.</li>
<li>The egress datapath does not have a destination lookup step which means that all information about the output port MUST be supplied by the ingress datapath. This means that destination lookup does not have to be done twice and it also has some interesting implications on the choice of encapsulation protocol as we&rsquo;ll see in the next section.</li>
</ol>


<p><img class="center" src="http://networkop.github.io/images/ovn-zoom3-l2.png"></p>

<p>Let&rsquo;s have a closer look at each of the stages of the forwarding pipeline. I&rsquo;ll include snippets of logical flows demonstrating the most interesting behaviour at each stage. Full logical datapath is quite long and can be viewed with <code>ovn-sbctl lflow-list [DATAPATH]</code> command. Here is some useful information, collected from the Northbound database, that will be used in the examples below:</p>

<hr />

<table>
<thead>
<tr>
<th> VM# </th>
<th> IP </th>
<th> MAC </th>
<th> Port UUID </th>
</tr>
</thead>
<tbody>
<tr>
<td> VM1 </td>
<td> 10.0.0.2 </td>
<td> fa:16:3e:4f:2f:b8 </td>
<td> 26c23a54-6a91-48fd-a019-3bd8a7e118de </td>
</tr>
<tr>
<td> VM3 </td>
<td> 10.0.0.5 </td>
<td> fa:16:3e:2a:60:32 </td>
<td> 5c62cfbe-0b2f-4c2a-98c3-7ee76c9d2879 </td>
</tr>
</tbody>
</table>


<hr />

<ul>
<li><strong>Port security</strong> - makes sure that incoming packet has the correct source MAC and IP addresses.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0 (ls_in_port_sec_l2), priority=50, match=(inport == "26c23a54-6a91-48fd-a019-3bd8a7e118de"
</span><span class='line'>  && eth.src == {fa:16:3e:4f:2f:b8}), action=(next;)
</span><span class='line'>table=1 (ls_in_port_sec_ip), priority=90, match=(inport == "26c23a54-6a91-48fd-a019-3bd8a7e118de"
</span><span class='line'>  && eth.src == fa:16:3e:4f:2f:b8 && ip4.src == {10.0.0.2}), action=(next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Egress ACL</strong> - set of tables that implement Neutron&rsquo;s Egress Port Security functionality. Default rules allow all egress traffic from a VM. The first flow below matches all new connections coming from VM1 and marks them for connection tracking with <code>reg0[1] = 1</code>. The next table catches these marked packets and commits them to the connection tracker. Special <code>ct_label=0/1</code> action ensures return traffic is allowed which is a standard behaviour of all stateful firewalls.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=6 (ls_in_acl), priority=2002 , match=(((ct.new && !ct.est) ||
</span><span class='line'>  (!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1)) &&
</span><span class='line'>  (inport == "26c23a54-6a91-48fd-a019-3bd8a7e118de" && ip4)),
</span><span class='line'>  action=(reg0[1] = 1; next;)
</span><span class='line'>table=9 (ls_in_stateful), priority=100  , match=(reg0[1] == 1),
</span><span class='line'>  action=(ct_commit(ct_label=0/1); next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>ARP Responder</strong> - matches an incoming ARP/ND request and generates an appropriate ARP/ND response. The way it is accomplished is similar to Neutron&rsquo;s native <a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">ARP responder</a> feature. Effectively an ARP request gets transformed into an ARP response by swapping source and destination fields.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=10(ls_in_arp_rsp), priority=50, match=(arp.tpa == 10.0.0.5 && arp.op == 1),
</span><span class='line'>  action=(eth.dst = eth.src; eth.src = fa:16:3e:2a:60:32; arp.op = 2; /* ARP reply */
</span><span class='line'>  arp.tha = arp.sha; arp.sha = fa:16:3e:2a:60:32; arp.tpa = arp.spa; arp.spa = 10.0.0.5;
</span><span class='line'>  outport = inport; flags.loopback = 1; output;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>DHCP Processing</strong> - set of tables that implement the DHCP server functionality using the approach similar to the ARP responder described above.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=12(ls_in_dhcp_response), priority=100, match=(inport == "26c23a54-6a91-48fd-a019-3bd8a7e118de"
</span><span class='line'>  && eth.src == fa:16:3e:4f:2f:b8 && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255
</span><span class='line'>  && udp.src == 68 && udp.dst == 67 && reg0[3]),
</span><span class='line'>  action=(eth.dst = eth.src; eth.src = fa:16:3e:94:b6:bc; ip4.dst = 10.0.0.2;
</span><span class='line'>  ip4.src = 10.0.0.1; udp.src = 67; udp.dst = 68; outport = inport; flags.loopback = 1; output;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Destination Lookup</strong> - implements L2 forwarding based on the destination MAC address of a frame. At this stage the <strong>outport</strong> variable is set to the VM3&rsquo;s port UUID.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=13(ls_in_l2_lkup), priority=50, match=(eth.dst == fa:16:3e:2a:60:32),
</span><span class='line'>  action=(outport = "5c62cfbe-0b2f-4c2a-98c3-7ee76c9d2879"; output;)
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Ingress ACL</strong> - set of tables that implement Neutron&rsquo;s Ingress Port security. For the sake of argument let&rsquo;s assume that we have enabled inbound SSH connections. The principle is same as before - the packet gets matched in one table and submitted to connection tracking in another table.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=4 (ls_out_acl), priority=2002 , match=(((ct.new && !ct.est)
</span><span class='line'>  || (!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1))
</span><span class='line'>  && (outport == "26c23a54-6a91-48fd-a019-3bd8a7e118de" && ip4
</span><span class='line'>  && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 22)),
</span><span class='line'>  action=(reg0[1] = 1; next;
</span><span class='line'>table=6 (ls_out_stateful), priority=100  , match=(reg0[1] == 1),
</span><span class='line'>  action=(ct_commit(ct_label=0/1); next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Port Security</strong> - implements inbound port security for destination VM by checking the sanity of destination MAC and IP addresses.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=7 (ls_out_port_sec_ip), priority=90, match=(outport == "5c62cfbe-0b2f-4c2a-98c3-7ee76c9d2879"
</span><span class='line'>  && eth.dst == fa:16:3e:2a:60:32 && ip4.dst == {255.255.255.255, 224.0.0.0/4, 10.0.0.5}),
</span><span class='line'>  action=(next;)
</span><span class='line'>table=8 (ls_out_port_sec_l2), priority=50, match=(outport == "5c62cfbe-0b2f-4c2a-98c3-7ee76c9d2879"
</span><span class='line'>  && eth.dst == {fa:16:3e:2a:60:32}),
</span><span class='line'>  action=(output;)</span></code></pre></td></tr></table></div></figure>


<h3>L3 datapath</h3>

<p>Similar to a logical switch pipeline, L3 datapath is split into ingress and egress parts. In this example we&rsquo;ll concentrate on  the Gateway router datapath. This router is connected to a distributed logical router via a transit subnet (SWtr) and to an external network via an external bridge (SWex) and performs NAT translation for all VM traffic.</p>

<p><img class="center" src="http://networkop.github.io/images/ovn-zoom3-l3.png"></p>

<p>Here is some useful information about router interfaces and ports that will be used in the examples below.</p>

<hr />

<table>
<thead>
<tr>
<th> SW function </th>
<th> IP </th>
<th> MAC </th>
<th> Port UUID </th>
</tr>
</thead>
<tbody>
<tr>
<td> External </td>
<td> 169.254.0.54/24 </td>
<td> fa:16:3e:39:c8:d8 </td>
<td> lrp-dc1ae9e3-d8fd-4451-aed8-3d6ddc5d095b </td>
</tr>
<tr>
<td> DVR-GW transit </td>
<td> 169.254.128.2/30 </td>
<td> fa:16:3e:7e:96:e7 </td>
<td> lrp-gtsp-186d8754-cc4b-40fd-9e5d-b0d26fc063bd </td>
</tr>
</tbody>
</table>


<hr />

<ul>
<li><strong>Port security</strong> - implements sanity check for all incoming packets.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0 (lr_in_admission), priority=50, match=((eth.mcast || eth.dst == fa:16:3e:7e:96:e7)
</span><span class='line'> && inport == "lrp-gtsp-186d8754-cc4b-40fd-9e5d-b0d26fc063bd"), action=(next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>IP Input</strong> - performs additional L3 sanity checks and implements typical IP services of a router (e.g. ICMP/ARP reply)</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=1 (lr_in_ip_input), priority=100, match=(ip4.src == {169.254.128.2, 169.254.128.3}),
</span><span class='line'>  action=(drop;)
</span><span class='line'>table=1 (lr_in_ip_input), priority=90, match=(inport == "lrp-gtsp-186d8754-cc4b-40fd-9e5d-b0d26fc063bd"
</span><span class='line'>  && arp.tpa == 169.254.128.2 && arp.op == 1),
</span><span class='line'>  action=(eth.dst = eth.src; eth.src = fa:16:3e:7e:96:e7; arp.op = 2;
</span><span class='line'>  /* ARP reply */ arp.tha = arp.sha; arp.sha = fa:16:3e:7e:96:e7;
</span><span class='line'>  arp.tpa = arp.spa; arp.spa = 169.254.128.2;
</span><span class='line'>  outport = "lrp-gtsp-186d8754-cc4b-40fd-9e5d-b0d26fc063bd"; flags.loopback = 1; output;)
</span><span class='line'>table=1 (lr_in_ip_input), priority=90, match=(ip4.dst == 169.254.128.2
</span><span class='line'>  && icmp4.type == 8 && icmp4.code == 0),
</span><span class='line'>  action=(ip4.dst &lt;-&gt; ip4.src; ip.ttl = 255; icmp4.type = 0; flags.loopback = 1; next; )</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>UNSNAT</strong> - translates the destination IP to the real address for packets coming from <strong>external</strong> networks</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=3 (lr_in_unsnat), priority=100, match=(ip && ip4.dst == 169.254.0.54),
</span><span class='line'>  action=(ct_snat; next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>DNAT</strong> - implements what is commonly known as static NAT, i.e. performs one-to-one destination IP translation for every configured floating IP.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=4 (lr_in_dnat), priority=100, match=(ip && ip4.dst == 169.254.0.52),
</span><span class='line'>  action=(flags.loopback = 1; ct_dnat(10.0.0.5);)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>IP routing</strong> - implements L3 forwarding based on the destination IP address. At this stage the <code>outport</code> is decided, IP TTL is decremented and the new next-hop IP is set in register0.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=5 (lr_in_ip_routing), priority=1, match=(ip4.dst == 0.0.0.0/0),
</span><span class='line'>  action=(ip.ttl--; reg0 = 169.254.0.1; reg1 = 169.254.0.54; eth.src = fa:16:3e:39:c8:d8;
</span><span class='line'>  outport = "lrp-dc1ae9e3-d8fd-4451-aed8-3d6ddc5d095b"; flags.loopback = 1; next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Next Hop Resolver</strong> - discovers the next-hop MAC address for a packet. This could either be a statically configured value when the next-hop is an OVN-managed router or a dynamic binding learned through ARP and stored in a special <code>MAC_Binding</code> table of Southbound DB.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=6 (lr_in_arp_resolve), priority=100, match=(outport == "lrp-gtsp-186d8754-cc4b-40fd-9e5d-b0d26fc063bd"
</span><span class='line'>  && reg0 == 169.254.128.1), action=(eth.dst = fa:16:3e:2a:7f:25; next;)
</span><span class='line'>table=6 (lr_in_arp_resolve), priority=0, match=(ip4),
</span><span class='line'>  action=(get_arp(outport, reg0); next;)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>SNAT</strong> - implements what is commonly known as overload NAT. Translates source IP, source UDP/TCP port number and ICMP Query ID to hide them behind a single IP address</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0 (lr_out_snat), priority=25, match=(ip && ip4.src == 10.0.0.0/24),
</span><span class='line'>  action=(ct_snat(169.254.0.54);)</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Output</strong> - send the packet out the port determined during the IP routing stage.</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=1 (lr_out_delivery), priority=100, match=(outport == "lrp-gtsp-186d8754-cc4b-40fd-9e5d-b0d26fc063bd"),
</span><span class='line'>  action=(output;)</span></code></pre></td></tr></table></div></figure>


<p>This was a very high-level, abridged and simplified version of how logical datapaths are built in OVN. Hopefully this lays enough groundwork to move on to the official <a href="http://openvswitch.org/support/dist-docs/ovn-northd.8.html">northd documentation</a> which describes both L2 and L3 datapaths in much greater detail.</p>

<p>Apart from the logical flows, Southbound DB also contains a number of tables that establish the logical-to-physical bindings. For example, the <code>Port_Binding</code> table establishes binding between logical switch, logical port, logical port overlay ID (a.k.a. tunnel key) and the unique hypervisor ID. In the next section we&rsquo;ll see how this information is used to translate logical flows into OpenFlow flows at each compute node. For full description of Southbound DB, its tables and their properties refer to the official SB <a href="http://openvswitch.org/support/dist-docs/ovn-sb.5.html">schema documentation</a>.</p>

<h2>OVN Controller - OpenFlow flows</h2>

<p><a href="http://openvswitch.org/support/dist-docs/ovn-controller.8.html">OVN Controller</a> process is the distributed part of OVN SDN controller. This process, running on each compute node, connects to Southbound DB via OVSDB and configures local OVS according to information received from it. It also uses Southbound DB to exchange the physical location information with other hypervisors. The two most important bits of information that OVN controller contributes to Southbound DB are physical location of logical ports and overlay tunnel IP address. These are the last two missing pieces to map logical flows to physical nodes and networks.</p>

<p>The whole flat space of OpenFlow tables is split into multiple areas. Tables 16 to 47 implement an ingress logical pipeline and tables 48 to 63 implement an egress logical pipeline. These tables have no notion of physical ports and are functionally equivalent to logical flows in Southbound DB. Tables 0 and 65 are responsible for mapping between the physical and logical realms. In table 0 packets are matched on the physical incoming port and assigned to a correct logical datapath as was defined by the <code>Port_Binding</code> table. In table 65 the information about the outport, that was determined during the ingress pipeline processing, is mapped to a local physical interface and the packet is sent out.</p>

<p>To demonstrate the details of OpenFlow implementation, I&rsquo;ll use the traffic flow between VM1 and external destination (8.8.8.8). For the sake of brevity I will only cover the major steps of packet processing inside OVS, omitting security checks and ARP/DHCP processing.</p>

<p><img class="center" src="http://networkop.github.io/images/ovn-zoom4-openflow.png"></p>

<p>When packets traverse OpenFlow tables they get labelled or annotated with special values to simplify matching in subsequent tables. For example, when table 0 matches the incoming port, it annotates the packet with the datapath ID. Since it would have been impractical to label packets with globally unique UUIDs from Soutbound DB, these UUIDs get mapped to smaller values called <strong>tunnel keys</strong>. To make things even more confusing, each port will have a local kernel ID, unique within each hypervisor. We&rsquo;ll need both tunnel keys and local port IDs to be able to track the packets inside the OVS. The figure below depicts all port and datapath IDs that have been collected from the Soutbound DB and local OVSDB on each hypervisor. Local port numbers are attached with a dotted line to their respective tunnel keys.</p>

<p><img class="center" src="http://networkop.github.io/images/ovn-zoom4-tunnelkey.png"></p>

<p>When VM1 sends the first packet to 8.8.8.8, it reaches OVS on local port 13. OVN Controller knows that this port belongs to VM1 and installs an OpenFlow rule to match all packets from this port and annotate them with datapath ID (OXM_OF_METADATA), incoming port ID (NXM_NX_REG14), conntrack zone (NXM_NX_REG13). It then moves these annotated packets to the first table of the ingress pipeline.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0, priority=100,in_port=13 actions=load:0x2-&gt;NXM_NX_REG13[],
</span><span class='line'>  load:0x2-&gt;OXM_OF_METADATA[],load:0x2-&gt;NXM_NX_REG14[],
</span><span class='line'>  resubmit(,16)</span></code></pre></td></tr></table></div></figure>


<p>Skipping to the L2 MAC address lookup stage, the output port (0x1) is decided based on the destination MAC address and saved in register 15.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=29, priority=50,metadata=0x2,dl_dst=fa:16:3e:0d:df:ea
</span><span class='line'>  actions=load:0x1-&gt;NXM_NX_REG15[],resubmit(,32)</span></code></pre></td></tr></table></div></figure>


<p>Finally, the packet reaches the last table where it is sent out the physical patch port interface towards R1.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=65, priority=100,reg15=0x1,metadata=0x2 actions=output:1</span></code></pre></td></tr></table></div></figure>


<p>The other end of this patch port is connected to a local instance of distributed router R1. That means our packet, unmodified, re-enters OpenFlow table 0, only this time on a different port. Local port 2 is associated with a logical pipeline of a router, hence <code>metadata</code> for this packet is set to 4.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0, priority=100,in_port=2 actions=load:0x4-&gt;OXM_OF_METADATA[],
</span><span class='line'>  load:0x1-&gt;NXM_NX_REG14[],resubmit(,16)</span></code></pre></td></tr></table></div></figure>


<p>The packet progresses through logical router datapath and finally gets to table 21 where destination IP lookup take place. It matches the catch-all <strong>default route</strong> rule and the values for its next-hop IP (0xa9fe8002), MAC address (fa:16:3e:2a:7f:25) and logical output port (0x03) are set.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=21, priority=1,ip,metadata=0x4 actions=dec_ttl(),load:0xa9fe8002-&gt;NXM_NX_XXREG0[96..127],
</span><span class='line'>  load:0xa9fe8001-&gt;NXM_NX_XXREG0[64..95],mod_dl_src:fa:16:3e:2a:7f:25,
</span><span class='line'>  load:0x3-&gt;NXM_NX_REG15[],load:0x1-&gt;NXM_NX_REG10[0],resubmit(,22)</span></code></pre></td></tr></table></div></figure>


<p>Table 65 converts the logical output port 3 to physical port 6, which is yet another patch port connected to a transit switch.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=65, priority=100,reg15=0x3,metadata=0x4 actions=output:6</span></code></pre></td></tr></table></div></figure>


<p>The packet once again re-enters OpenFlow pipeline from table 0, this time from port 5. Table 0 maps incoming port 5 to the logical datapath of a transit switch with Tunnel key 7.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0, priority=100,in_port=5 actions=load:0x7-&gt;OXM_OF_METADATA[],
</span><span class='line'>  load:0x1-&gt;NXM_NX_REG14[],resubmit(,16)</span></code></pre></td></tr></table></div></figure>


<p>Destination lookup determines the output port (2) but this time, instead of entering the egress pipeline locally, the packet gets sent out the physical tunnel port (7) which points to the IP address of a compute node hosting the GW router. The headers of an overlay packet are populated with logical datapath ID (0x7), logical input port (copied from register 14) and logical output port (0x2).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=29, priority=50,metadata=0x7,dl_dst=fa:16:3e:7e:96:e7
</span><span class='line'>  actions=load:0x2-&gt;NXM_NX_REG15[],resubmit(,32)
</span><span class='line'>table=32, priority=100,reg15=0x2,metadata=0x7 actions=load:0x7-&gt;NXM_NX_TUN_ID[0..23],
</span><span class='line'>  set_field:0x2/0xffffffff-&gt;tun_metadata0,move:NXM_NX_REG14[0..14]-&gt;NXM_NX_TUN_METADATA0[16..30],
</span><span class='line'>  output:7</span></code></pre></td></tr></table></div></figure>


<p>When packet reaches the destination node, it once again enters the OpenFlow table 0, but this time all information is extracted from the tunnel keys.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0, priority=100,in_port=17 actions=move:NXM_NX_TUN_ID[0..23]-&gt;OXM_OF_METADATA[0..23],
</span><span class='line'>  move:NXM_NX_TUN_METADATA0[16..30]-&gt;NXM_NX_REG14[0..14],
</span><span class='line'>  move:NXM_NX_TUN_METADATA0[0..15]-&gt;NXM_NX_REG15[0..15],
</span><span class='line'>  resubmit(,33)</span></code></pre></td></tr></table></div></figure>


<p>At the end of the transit switch datapath the packet gets sent out port 12, whose peer is patch port 16.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=65, priority=100,reg15=0x2,metadata=0x7 actions=output:12</span></code></pre></td></tr></table></div></figure>


<p>The packet re-enters OpenFlow table 0 from port 16, where it gets mapped to the logical datapath of a gateway router.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0, priority=100,in_port=16 actions=load:0x2-&gt;NXM_NX_REG11[],
</span><span class='line'>  load:0x6-&gt;NXM_NX_REG12[],load:0x6-&gt;OXM_OF_METADATA[],
</span><span class='line'>  load:0x2-&gt;NXM_NX_REG14[],resubmit(,16)</span></code></pre></td></tr></table></div></figure>


<p>Similar to a distributed router R1, table 21 determines the next-hop MAC address for a packet and saves the output port in register 15.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=21, priority=1,ip,metadata=0x6 actions=dec_ttl(),load:0xa9fe0001-&gt;NXM_NX_XXREG0[96..127],
</span><span class='line'>  load:0xa9fe0036-&gt;NXM_NX_XXREG0[64..95],mod_dl_src:fa:16:3e:39:c8:d8,
</span><span class='line'>  load:0x1-&gt;NXM_NX_REG15[],load:0x1-&gt;NXM_NX_REG10[0],resubmit(,22)</span></code></pre></td></tr></table></div></figure>


<p>The first table of an egress pipeline source-NATs packets to external IP address of the GW router.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=48, priority=33,ip,metadata=0x6,nw_src=10.0.0.2
</span><span class='line'>  actions=ct(commit,table=49,zone=NXM_NX_REG12[0..15],nat(src=169.254.0.56))</span></code></pre></td></tr></table></div></figure>


<p>The modified packet is sent out the physical port 14 towards the external switch.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=65, priority=100,reg15=0x1,metadata=0x6 actions=output:14</span></code></pre></td></tr></table></div></figure>


<p>External switch determines the output port connected to the <code>br-ex</code> on a local hypervisor and send the packet out.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>table=0, priority=100,in_port=13 actions=load:0x5-&gt;NXM_NX_REG11[],
</span><span class='line'>  load:0x3-&gt;NXM_NX_REG12[],load:0x3-&gt;OXM_OF_METADATA[],
</span><span class='line'>  load:0x2-&gt;NXM_NX_REG14[],resubmit(,16)
</span><span class='line'>table=29, priority=0,metadata=0x3 actions=load:0xfffe-&gt;NXM_NX_REG15[],resubmit(,32)
</span><span class='line'>table=33, priority=100,reg15=0xfffe,metadata=0x3
</span><span class='line'>  actions=load:0x1-&gt;NXM_NX_REG13[],load:0x1-&gt;NXM_NX_REG15[],
</span><span class='line'>  resubmit(,34),load:0xfffe-&gt;NXM_NX_REG15[]
</span><span class='line'>table=65, priority=100,reg15=0x1,metadata=0x3 actions=output:15</span></code></pre></td></tr></table></div></figure>


<p>As we&rsquo;ve just seen, OpenFlow repeats the logical topology by interconnecting logical datapaths of switches and routers with virtual point-to-point patch cables. This may seem like an unnecessary modelling element with a potential for a performance impact. However, when flows get installed in kernel datapath, these patch ports <a href="http://galsagie.github.io/2015/11/23/ovn-l3-deepdive">do not exist</a>, which means that there isn&rsquo;t any performance impact on packets in fastpath.</p>

<h2>Physical network - GENEVE overlay</h2>

<p>Before we wrap up, let us have a quick look at the new overlay protocol GENEVE. The goal of any overlay protocol is to transport all the necessary tunnel keys. With VXLAN the only tunnel key that could be transported is the Virtual Network Identifier (VNI). In OVN&rsquo;s case these tunnel keys include not only the logical datapath ID (commonly known as VNI) but also both input and output port IDs. You could have carved up the 24 bits of VXLAN tunnel ID to encode all this information but this would only have given you 256 unique values per key. Some other overlay protocols, like STT have even bigger tunnel ID header size but they, too, have a strict upper limit.</p>

<p>GENEVE was designed to have a variable-length header. The first few bytes are well-defined fixed size fields followed by variable-length Options. This kind of structure allows software developers to innovate at their own pace while still getting the benefits of hardware offload for the fixed-size portion of the header. OVN developers <a href="http://openvswitch.org/support/dist-docs/ovn-architecture.7.html">decided</a> to use Options header type 0x80 to store the 15-bit logical ingress port ID and a 16-bit egress port ID (an extra bit is for logical multicast groups).</p>

<p><img class="center" src="http://networkop.github.io/images/ovn-zoom5-geneve.png"></p>

<p>The figure above shows the ICMP ping coming from VM1(10.0.0.2) to Google&rsquo;s DNS. As I&rsquo;ve showed in the previous section, GENEVE is used between the ingress and egress pipelines of a transit switch (SWtr), whose datapath ID is encoded in the VNI field (0x7). Packets enter the transit switch on port 1 and leave it on port 2. These two values are encoded in the <code>00010002</code> value of the <code>Options Data</code> field.</p>

<p>So now that GENEVE has taken over as the inter-hypervisor overlay protocol, does that mean that VXLAN is dead? OVN still supports VXLAN but only for interconnects with 3rd party devices like VXLAN-VLAN gateways or VXLAN TOR switches. Rephrasing the official OVN <a href="http://openvswitch.org/support/dist-docs/ovn-architecture.7.html">documentation</a>, VXLAN gateways will continue to be supported but they will have a reduced feature set due to lack of extensibility.</p>

<h2>Conclusion</h2>

<p>OpenStack networking has always been one of the first use cases of any new SDN controller. All the major SDN platforms like ACI, NSX, Contrail, VSP or ODL have some form of OpenStack integration. And it made sense, since native Neutron networking has always been one of the biggest pain points in OpenStack deployments. As I&rsquo;ve just demonstrated, OVN can now do all of the common networking functionality natively, without having to rely on 3rd party agents. In addition to that it has a fantastic <a href="http://openvswitch.org/support/dist-docs/">documentation</a>, implements all forwarding inside a single OVS bridge and it is an open-source project. As an OpenStack networking solution it is still, perhaps, a few months away from being production ready - active/active HA is not supported with OVSDB, GW router scheduling options are limited, lack of native support for DNS and Metadata proxy. However I anticipate that starting from the next OpenStack release (Ocata, Feb 2017) OVN will be ready for mass deployment even by companies without an army of OVS/OpenStack developers. And when that happens there will even less need for proprietary OpenStack SDN platforms.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStack SDN With OVN (Part 1) - Build and Install]]></title>
    <link href="http://networkop.github.io/blog/2016/11/27/ovn-part1/"/>
    <updated>2016-11-27T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2016/11/27/ovn-part1</id>
    <content type="html"><![CDATA[<p>This is a first of a two-post series dedicated to project OVN. In this post I&rsquo;ll show how to build, install and configure OVN to work with a 3-node RDO OpenStack lab.</p>

<!--more-->


<p>Vanilla OpenStack networking has many functional, performance and scaling limitations. Projects like <a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">L2 population</a>, <a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">local ARP responder</a>, <a href="http://networkop.github.io/blog/2016/05/21/neutron-l2gw/">L2 Gateway</a> and <a href="http://networkop.github.io/blog/2016/10/13/os-dvr/">DVR</a> were conceived to address those issues. However good a job these projects do, they still remain a collection of separate projects, each with its own limitations, configuration options and sets of dependencies. That led to an effort outside of OpenStack to develop a special-purpose OVS-only SDN controller that would address those issues in a centralised and consistent manner. This post will be about one such SDN controller, coming directly from the people responsible for OpenvSwitch, Open Virtual Network (OVN).</p>

<h2>OVN quick introduction</h2>

<p>OVN is a distributed SDN controller implementing virtual networks with the help OVS. Even though it is positioned as a <abbr title="Cloud Management System">CMS</abbr>-independent controller, the main use case is still OpenStack. OVN was designed to address the following limitations of vanilla OpenStack networking:</p>

<ul>
<li>Security groups could not be implemented directly on OVS ports and, therefore, required a dedicated Linux bridge between the VM and the OVS integration bridge.</li>
<li>Routing and DHCP agents required dedicated network namespaces.</li>
<li>NAT was implemented using a combination of network namespaces, iptables and proxy-ARP.</li>
</ul>


<p>OVN implements security groups, distributed virtual routing, NAT and distributed DHCP server all inside a single OVS bridge. This dramatically improves performance by reducing the number of inter-process packet handling and ensures that all flows can benefit from kernel fast-path switching.</p>

<p>At a high level, OVN consists of 3 main components:</p>

<ol>
<li>OVN ML2 Plugin - performs translation between Neutron data model and OVN logical data model stored in Northbound DB.</li>
<li>OVN northd - the brains of OVN, translates the high level networking abstractions (logical switches, routers and ports) into logical flows. These <a href="https://blog.russellbryant.net/2016/11/11/ovn-logical-flows-and-ovn-trace/">logical flows</a> are not yet OpenFlow flows but similar in concept and a very powerful abstraction. All translated information is stored in Southbound DB.</li>
<li>OVN controllers - located on each compute node, receive identical copies of logical flows (centralised network view) and exchange logical port to overlay IP binding information via the central Southbound DB. This information is used to perform logical flow translation into OpenFlow which are then programmed into the local OVS instance.</li>
</ol>


<p><img class="center" src="http://networkop.github.io/images/ovn-arch.png"></p>

<p>If you want to learn more about OVN architecture and use cases, <a href="http://docs.openstack.org/developer/networking-ovn/readme.html">OpenStack OVN page</a> has an excellent collection of resources for further reading.</p>

<h2>OpenStack installation</h2>

<p>I&rsquo;ll use RDO packstack to help me build a 1 controller and 2 compute nodes OpenStack lab on CentOS7. I&rsquo;ll use the master trunk to deploy the latest OpenStack Ocata packages. This is required since at the time of writing (Nov 2016) some of the OVN features were not available in OpenStack Newton.</p>

<figure class='code'><figcaption><span>Install latest RDO repositories on all 3 nodes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> /etc/yum.repos.d/
</span><span class='line'>wget http://trunk.rdoproject.org/centos7/delorean-deps.repo
</span><span class='line'>wget https://trunk.rdoproject.org/centos7-master/current/delorean.repo
</span></code></pre></td></tr></table></div></figure>


<p>On the controller node, generate a sample answer file and modify settings to match the IPs of individual nodes. Optionally, you can disable some of the unused components like Nagios and Ceilometer similar to how I did it in my <a href="http://networkop.co.uk/blog/2016/04/18/os-unl-lab/">earlier post</a>.</p>

<figure class='code'><figcaption><span>Modify answer file and deploy OpenStack</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum install -y openstack-packstack crudini
</span><span class='line'>packstack --gen-answer-file<span class="o">=</span>/root/packstack.answer
</span><span class='line'>crudini --set --existing defautl CONFIG_COMPUTE_HOSTS 169.254.0.12,169.254.0.13
</span><span class='line'>crudini --set --existing defautl CONFIG_CONTROLLER_HOST 169.254.0.11
</span><span class='line'>crudini --set --existing defautl CONFIG_NETWORK_HOSTS 169.254.0.11
</span><span class='line'>packstack --answer-file<span class="o">=</span>/root/packstack.answer
</span></code></pre></td></tr></table></div></figure>


<p>After the last step we should have a working 3-node OpenStack lab, similar to the one depicted below. If you want to learn about how to automate this process, refer to my older posts about <a href="http://networkop.github.io/blog/2016/09/09/os-lab-p1/">OpenStack</a> and <a href="http://networkop.github.io/blog/2016/09/09/os-lab-p2/">underlay Leaf-Spine fabric</a> build using Chef.</p>

<p><img class="center" src="http://networkop.github.io/images/ovn-openstack.png"></p>

<h2>OVN Build</h2>

<p>OVN can be built directly from OVS source code. Instead of building and installing OVS on each of the OpenStack nodes individually, I&rsquo;ll build a set of RPM&rsquo;s on the Controller and will use them to install and upgrade OVS/OVN components on the remaining nodes.</p>

<p>Part of OVN build process includes building an OVS kernel module. In order to be able to use kmod RPM on all nodes we need to make sure all nodes use the same version of Linux kernel. The easiest way would be to fetch the latest updates from CentOS repos and reboot the nodes. This step should result in same kernel version on all nodes, which can be checked with <code>uname -r</code> command.</p>

<figure class='code'><figcaption><span>Upgrade kernel on all nodes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum -y update kernel
</span><span class='line'>reboot
</span></code></pre></td></tr></table></div></figure>


<p>The official <a href="https://github.com/openvswitch/ovs/blob/master/INSTALL.Fedora.rst">OVS installation procedure for CentOS7</a> is pretty accurate and requires only a few modifications to account for the packages missing in the minimal CentOS image I&rsquo;ve used as a base OS.</p>

<figure class='code'><figcaption><span>OVS build procedure</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum install rpm-build autoconf automake libtool systemd-units openssl openssl-devel python python-twisted-core python-zope-interface python-six desktop-file-utils groff graphviz procps-ng libcap-ng libcap-ng-devel
</span><span class='line'>yum install selinux-policy-devel kernel-devel-<span class="sb">`</span>uname -r<span class="sb">`</span> git
</span><span class='line'>git clone https://github.com/openvswitch/ovs.git
</span><span class='line'><span class="nb">cd </span>ovs
</span><span class='line'>./boot.sh
</span><span class='line'>./configure
</span><span class='line'>make rpm-fedora <span class="nv">RPMBUILD_OPT</span><span class="o">=</span><span class="s2">&quot;--without check&quot;</span>
</span><span class='line'>make rpm-fedora-kmod
</span></code></pre></td></tr></table></div></figure>


<p>At the end of the process we should have a set of rpms inside the <code>ovs/rpm/rpmbuild/RPMS/</code> directory.</p>

<h2>OVN Install</h2>

<p>Before we can begin installing OVN, we need to prepare the existing OpenStack environment by disabling and removing legacy Neutron OpenvSwitch agents. Since OVN natively implements L2 and L3 forwarding, DHCP and NAT, we won&rsquo;t need L3 and DHCP agents on any of the Compute nodes. Network node that used to provide North-South connectivity will no longer be needed.</p>

<h3>OpenStack preparation</h3>

<p>First, we need to make sure all Compute nodes have a bridge that would provide access to external provider networks. In my case, I&rsquo;ll move the <code>eth1</code> interface under the OVS <code>br-ex</code> on all Compute nodes.</p>

<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-eth1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">DEVICE</span><span class="o">=</span>eth1
</span><span class='line'><span class="nv">NAME</span><span class="o">=</span>eth1
</span><span class='line'><span class="nv">DEVICETYPE</span><span class="o">=</span>ovs
</span><span class='line'><span class="nv">TYPE</span><span class="o">=</span>OVSPort
</span><span class='line'><span class="nv">OVS_BRIDGE</span><span class="o">=</span>br-ex
</span><span class='line'><span class="nv">ONBOOT</span><span class="o">=</span>yes
</span><span class='line'><span class="nv">BOOTPROTO</span><span class="o">=</span>none
</span></code></pre></td></tr></table></div></figure>


<p>IP address needs to be moved to <code>br-ex</code> interface. Below example is for Compute node #2:</p>

<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-br-ex</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">ONBOOT</span><span class="o">=</span>yes
</span><span class='line'><span class="nv">DEFROUTE</span><span class="o">=</span>yes
</span><span class='line'><span class="nv">IPADDR</span><span class="o">=</span>169.254.0.12
</span><span class='line'><span class="nv">PREFIX</span><span class="o">=</span>24
</span><span class='line'><span class="nv">GATEWAY</span><span class="o">=</span>169.254.0.1
</span><span class='line'><span class="nv">DNS1</span><span class="o">=</span>8.8.8.8
</span><span class='line'><span class="nv">DEVICE</span><span class="o">=</span>br-ex
</span><span class='line'><span class="nv">NAME</span><span class="o">=</span>br-ex
</span><span class='line'><span class="nv">DEVICETYPE</span><span class="o">=</span>ovs
</span><span class='line'><span class="nv">OVSBOOTPROTO</span><span class="o">=</span>none
</span><span class='line'><span class="nv">TYPE</span><span class="o">=</span>OVSBridge
</span></code></pre></td></tr></table></div></figure>


<p>At the same time OVS configuration on Network/Controller node will need to be completely wiped out. Once that&rsquo;s done, we can remove the Neutron OVS package from all nodes.</p>

<figure class='code'><figcaption><span>Remove legacy Neutron OVS agents</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum remove openstack-neutron-openvswitch
</span></code></pre></td></tr></table></div></figure>


<h3>OVS packages installation</h3>

<p>Now everything is ready for OVN installation. First step is to install the kernel module and upgrade the existing OVS package. Reboot may be needed in order for the correct kernel module to be loaded.</p>

<figure class='code'><figcaption><span>Upgrade OVS on all nodes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>rpm -i openvswitch-kmod-2.6.90-1.el7.centos.x86_64.rpm
</span><span class='line'>rpm -U openvswitch-2.6.90-1.el7.centos.x86_64.rpm
</span><span class='line'>reboot
</span></code></pre></td></tr></table></div></figure>


<p>Now we can install OVN. Controllers will be running the <code>ovn-northd</code> process which can be installed as follows:</p>

<figure class='code'><figcaption><span>Install OVN on the Controller</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>rpm -i openvswitch-ovn-common-*.x86_64.rpm
</span><span class='line'>rpm -i openvswitch-ovn-central-*.x86_64.rpm
</span><span class='line'>systemctl start ovn-northd
</span></code></pre></td></tr></table></div></figure>


<p>The following packages install the <code>ovn-controller</code> on all Compute nodes:</p>

<figure class='code'><figcaption><span>Install OVN on Compute nodes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>rpm -i openvswitch-ovn-common-*.x86_64.rpm
</span><span class='line'>rpm -i openvswitch-ovn-host-*.x86_64.rpm
</span><span class='line'>systemctl start ovn-controller
</span></code></pre></td></tr></table></div></figure>


<p>The last thing is to install the OVN ML2 plugin, a python library that allows Neutron to talk to OVN Northbound database.</p>

<figure class='code'><figcaption><span>Install OVN ML2 plugin on the Controller</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum install python-networking-ovn
</span></code></pre></td></tr></table></div></figure>


<h2>OVN Configuration</h2>

<p>Now that we have all the required packages in place, it&rsquo;s time to reconfigure Neutron to start using OVN instead of a default openvswitch plugin. The installation procedure is described in the official <a href="http://docs.openstack.org/developer/networking-ovn/index.html">Neutron integration guide</a>. At the end, once we&rsquo;ve restarted <code>ovn-northd</code> on the controller and <code>ovn-controller</code> on the compute nodes, we should see the following output on the controller node:</p>

<figure class='code'><figcaption><span>ovs-sbctl show</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Chassis <span class="s2">&quot;d03bdd51-e687-4078-aa54-0ff8007db0b5&quot;</span>
</span><span class='line'>    hostname: <span class="s2">&quot;compute-3&quot;</span>
</span><span class='line'>    Encap geneve
</span><span class='line'>        ip: <span class="s2">&quot;10.0.0.4&quot;</span>
</span><span class='line'>        options: <span class="o">{</span><span class="nv">csum</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="o">}</span>
</span><span class='line'>    Encap vxlan
</span><span class='line'>        ip: <span class="s2">&quot;10.0.0.4&quot;</span>
</span><span class='line'>        options: <span class="o">{</span><span class="nv">csum</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="o">}</span>
</span><span class='line'>Chassis <span class="s2">&quot;b89b8683-7c74-43df-8ac6-1d57ddefec77&quot;</span>
</span><span class='line'>    hostname: <span class="s2">&quot;compute-2&quot;</span>
</span><span class='line'>    Encap vxlan
</span><span class='line'>        ip: <span class="s2">&quot;10.0.0.2&quot;</span>
</span><span class='line'>        options: <span class="o">{</span><span class="nv">csum</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="o">}</span>
</span><span class='line'>    Encap geneve
</span><span class='line'>        ip: <span class="s2">&quot;10.0.0.2&quot;</span>
</span><span class='line'>        options: <span class="o">{</span><span class="nv">csum</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This means that all instances of a distributed OVN controller located on each compute node have successfully registered with Southbound OVSDB and provided information about their physical overlay addresses and supported encapsulation types.</p>

<h2>(Optional) Automating everything with Chef</h2>

<p>At this point of time there&rsquo;s no way to automate OVN deployment with Packstack (TripleO already has OVN integration templates). For those who want to bypass the manual build process I have created a new Chef cookbook, automating all steps described above. This Chef playbook assumes that OpenStack environment has been built as described in my <a href="http://networkop.github.io/blog/2016/09/09/os-lab-p1/">earlier post</a>. Optionally, you can automate the build of underlay network as well by following my <a href="http://networkop.github.io/blog/2016/09/09/os-lab-p2/">other post</a>. Once you&rsquo;ve got both OpenStack and underlay built, you can use the following scripts to build, install and configure OVN:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git clone https://github.com/networkop/chef-unl-os.git
</span><span class='line'><span class="nb">cd </span>chef-unl-os
</span><span class='line'>chef-client -z -E lab ovn.rb
</span></code></pre></td></tr></table></div></figure>


<h2>Test topology setup</h2>

<p>Now we should be able to create a test topology with two tenant subnets and an external network interconnected by a virtual router.</p>

<figure class='code'><figcaption><span>Creating a test topology</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>neutron net-create NET-RED
</span><span class='line'>neutron net-create NET-BLUE
</span><span class='line'>neutron subnet-create --name SUB-BLUE NET-BLUE 10.0.0.0/24
</span><span class='line'>neutron subnet-create --name SUB-RED NET-RED 20.0.0.0/24
</span><span class='line'>neutron net-create NET-EXT --provider:network_type flat <span class="se">\</span>
</span><span class='line'>                           --provider:physical_network extnet <span class="se">\</span>
</span><span class='line'>                           --router:external --shared
</span><span class='line'>neutron subnet-create --name SUB-EXT --enable_dhcp<span class="o">=</span>False <span class="se">\</span>
</span><span class='line'>                      --allocation-pool<span class="o">=</span><span class="nv">start</span><span class="o">=</span>169.254.0.50,end<span class="o">=</span>169.254.0.99 <span class="se">\</span>
</span><span class='line'>                      --gateway<span class="o">=</span>169.254.0.1 NET-EXT 169.254.0.0/24
</span><span class='line'>neutron router-create R1
</span><span class='line'>neutron router-interface-add R1 SUB-BLUE
</span><span class='line'>neutron router-interface-add R1 SUB-RED
</span><span class='line'>neutron router-gateway-set R1 NET-EXT
</span></code></pre></td></tr></table></div></figure>


<p>When we attach a few test VMs to each subnet we should be able to successfully ping between the VMs, assuming the security groups are setup to allow ICMP/ND.</p>

<figure class='code'><figcaption><span>Create VMs</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>curl http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img <span class="p">|</span> glance <span class="se">\</span>
</span><span class='line'>image-create --name<span class="o">=</span><span class="s1">&#39;IMG-CIRROS&#39;</span> <span class="se">\</span>
</span><span class='line'>  --visibility<span class="o">=</span>public <span class="se">\</span>
</span><span class='line'>  --container-format<span class="o">=</span>bare <span class="se">\</span>
</span><span class='line'>  --disk-format<span class="o">=</span>qcow2
</span><span class='line'>nova aggregate-create AGG-RED AZ-RED
</span><span class='line'>nova aggregate-create AGG-BLUE AZ-BLUE
</span><span class='line'>nova aggregate-add-host AGG-BLUE compute-2
</span><span class='line'>nova aggregate-add-host AGG-RED compute-3
</span><span class='line'>nova boot --flavor m1.tiny --image <span class="s1">&#39;IMG-CIRROS&#39;</span> <span class="se">\</span>
</span><span class='line'>  --nic net-name<span class="o">=</span>NET-BLUE <span class="se">\</span>
</span><span class='line'>  --availability-zone AZ-BLUE <span class="se">\</span>
</span><span class='line'>  VM1
</span><span class='line'>
</span><span class='line'>nova boot --flavor m1.tiny --image <span class="s1">&#39;IMG-CIRROS&#39;</span> <span class="se">\</span>
</span><span class='line'>  --nic net-name<span class="o">=</span>NET-RED <span class="se">\</span>
</span><span class='line'>  --availability-zone AZ-RED <span class="se">\</span>
</span><span class='line'>  VM2
</span><span class='line'>nova boot --flavor m1.tiny --image <span class="s1">&#39;IMG-CIRROS&#39;</span> <span class="se">\</span>
</span><span class='line'>  --nic net-name<span class="o">=</span>NET-BLUE <span class="se">\</span>
</span><span class='line'>  --availability-zone AZ-RED <span class="se">\</span>
</span><span class='line'>  VM3
</span><span class='line'>openstack floating ip assign 169.254.0.52 VM3
</span><span class='line'>openstack server add floating ip VM3 169.254.0.52
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://networkop.github.io/images/ovn-topo.png"></p>

<p>In the next post we will use the above virtual topology to explore the dataplane packet flow inside an OVN-managed OpenvSwitch and how it uses the new encapsulation protocol GENEVE to optimise egress forwarding lookups on remote compute nodes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type-2 and Type-5 EPVN on vQFX 10k in UnetLab]]></title>
    <link href="http://networkop.github.io/blog/2016/10/26/qfx-unl/"/>
    <updated>2016-10-26T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/10/26/qfx-unl</id>
    <content type="html"><![CDATA[<p>I was fortunate enough to be given a chance to test the new virtual QFX 10k image from Juniper. In this post I will show how to import this image into UnetLab and demonstrate the basic L2 and L3 EVPN services.</p>

<!--more-->


<h2>News about UnetLab</h2>

<p>Those who read my blog regularly know that I&rsquo;m a big fan of a network simulator called UnetLab. For the last two years I&rsquo;ve done all my labbing in UNL and was constantly surprised by how extensible and stable it has been. I believe that projects like this are very important to our networking community because they help train the new generation of network engineers and enable them to expand their horizons. Recently UnetLab team has decided take the next step and create a new version of UNL. This new project, called <a href="https://www.indiegogo.com/projects/eve-ng-emulated-virtual-environment-next-gen#/">EVE-NG</a>, will help users build labs of any size and run full replicas of their production networks, which is ideal for <a href="http://networkop.github.io/blog/2016/02/19/network-ci-intro/">pre-deployment testing</a> of network changes. If you want to learn more, check out the <a href="https://www.indiegogo.com/projects/eve-ng-emulated-virtual-environment-next-gen#/">EVE-NG</a> page on indiegogo.</p>

<h2>Creating vQFX nodes in UnetLab</h2>

<p>Back to the business at hand, vQFX is not publically available yet but is expected to pop up at <a href="http://www.juniper.net/">Juniper.net</a> some time in the future. Similar to a recently released vMX, vQFX will consist of two virtual machines - one running the routing engine (RE) and second simulating the ASIC forwarding piplines (PFE). You can find more information about these images on Juniper&rsquo;s <a href="https://github.com/Juniper/vqfx10k-vagrant">Github page</a>. Images get distributed in multiple formats but in the context of this post we&rsquo;ll only deal with two VMDK files:</p>

<figure class='code'><figcaption><span>vQFX images</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>vqfx10k-re-15.1X53-D60.vmdk
</span><span class='line'>vqfx10k-pfe-20160609-2.vmdk
</span></code></pre></td></tr></table></div></figure>


<p>To be able to use these images in UnetLab, we first need to convert them to <strong>qcow2</strong> format and copy them to the directory where UNL stores all its qemu images:</p>

<figure class='code'><figcaption><span>Importing VMDK images</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> mkdir /opt/unetlab/addons/qemu/qfx_re-15d1X53
</span><span class='line'> mkdir /opt/unetlab/addons/qemu/qfx_pfe-20160609
</span><span class='line'>
</span><span class='line'>/opt/qemu/bin/qemu-img convert -f vmdk -O qcow2 vqfx10k-pfe-20160609-2.vmdk /opt/unetlab/addons/qemu/qfx_pfe-20160609/hda.qcow2
</span><span class='line'>
</span><span class='line'>/opt/qemu/bin/qemu-img convert -f vmdk -O qcow2 vqfx10k-re-15.1X53-D60.vmdk /opt/unetlab/addons/qemu/qfx_re-15d1X53/hda.qcow2
</span></code></pre></td></tr></table></div></figure>


<p>Next, we need to create new node definitions for RE and PFE VMs. The easiest way would be to clone the linux node type:</p>

<figure class='code'><figcaption><span>Creating vQFX node definitions</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">cd</span> /opt/unetlab/html/templates
</span><span class='line'>cp linux.php qfx_pfe.php
</span><span class='line'>cp linux.php qfx_re.php
</span><span class='line'>
</span><span class='line'>sed -i <span class="s1">&#39;s/2048/1024/; s/virtio-net-pci/e1000/; s/Server/Switch/&#39;</span> qfx_re.php
</span><span class='line'>sed -i <span class="s1">&#39;s/2048/1536/; s/virtio-net-pci/e1000/; s/Server/Switch/&#39;</span> qfx_pfe.php
</span><span class='line'>
</span><span class='line'>sed -i <span class="s1">&#39;s/Linux/QFX_RE/g; s/linux/qfx_re/g&#39;</span> qfx_re.php
</span><span class='line'>sed -i <span class="s1">&#39;s/Linux/QFX_PFE/g; s/linux/qfx_pfe/g&#39;</span> qfx_pfe.php
</span><span class='line'>
</span><span class='line'>sed -ri <span class="s1">&#39;s/(.*ethernet.*) = 1/\1 = 2/&#39;</span> qfx_pfe.php
</span><span class='line'>sed -ri <span class="s1">&#39;s/(.*ethernet.*) = 1/\1 = 8/&#39;</span> qfx_re.php
</span></code></pre></td></tr></table></div></figure>


<p>Now let&rsquo;s add the QFX to the list of nodes by modifying the following file:</p>

<figure class='code'><figcaption><span>/opt/unetlab/html/includes/init.php</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="s1">&#39;openstack&#39;</span>             <span class="o">=</span>&gt;      <span class="s1">&#39;Openstack&#39;</span>,
</span><span class='line'><span class="s1">&#39;qfx_re&#39;</span>                <span class="o">=</span>&gt;      <span class="s1">&#39;QFX10k-RE&#39;</span>,
</span><span class='line'><span class="s1">&#39;qfx_pfe&#39;</span>               <span class="o">=</span>&gt;      <span class="s1">&#39;QFX10k-PFE&#39;</span>,
</span><span class='line'><span class="s1">&#39;mikrotik&#39;</span>              <span class="o">=</span>&gt;      <span class="s1">&#39;MikroTik RouterOS&#39;</span>,
</span></code></pre></td></tr></table></div></figure>


<p>Optionally, <code>/opt/unetlab/html/includes/__node.php</code> can be modified to change the default naming convention similar to the <code>vmx</code> node.</p>

<p>Once you&rsquo;ve done all the above changes, you should have a working vQFX 10k node available in UNL GUI. For the purpose of demonstration of EVPN features I&rsquo;ve created the following topology:</p>

<p><img class="center" src="http://networkop.github.io/images/qfx-unl.png"></p>

<h2>EVPN L2 and L3 services</h2>

<p>EVPN standards define multiple routes types to distribute NLRI information across the network. The two most &ldquo;significant&rdquo; route types are 2 and 5. Type-2 NLRI was designed to carry the MAC (and optionally IP) address to VTEP IP binding information which is used to populate the dynamic MAC address table. This function, that was previously accomplished by a central SDN controller, is now performed in a scalable, standard-based, controller-independent fashion. <a href="http://www.juniper.net/documentation/en_US/junos16.1/topics/concept/evpn-route-type5-understanding.html">Type-5 NLRI</a> contains IP Prefix to VTEP IP mapping and is similar to the function of traditional L3 VPNs. In order to explore the capabilities of EVPN implementation on vQFX I&rsquo;ve created and artificial scenario with 3 virtual switches, 3 VLANs and 4 hosts.</p>

<p><img class="center" src="http://networkop.github.io/images/qfx-lab.png"></p>

<p>VLAN10 (green) is present on all 3 switches, VLAN20 (purple) is only configured on switches 1 and 2 and VLAN88 (red) only exists on SW3. I&rsquo;ve provided configuration snippets below for reference purposes only and only for SW1. Remaining switches are configured similarly.</p>

<h3>Configuring Basic IP and BGP setup</h3>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">set </span>interfaces xe-0/0/0 unit <span class="m">0</span> family inet address 12.12.12.1/24
</span><span class='line'><span class="nb">set </span>interfaces xe-0/0/2 unit <span class="m">0</span> family inet address 13.13.13.1/24
</span><span class='line'><span class="nb">set </span>interfaces lo0 unit <span class="m">0</span> family inet address 99.99.99.1/32
</span><span class='line'><span class="nb">set </span>routing-options static route 99.99.99.2/32 next-hop 12.12.12.2
</span><span class='line'><span class="nb">set </span>routing-options static route 99.99.99.3/32 next-hop 13.13.13.3
</span><span class='line'>
</span><span class='line'><span class="nb">set </span>routing-options router-id 99.99.99.1
</span><span class='line'><span class="nb">set </span>routing-options autonomous-system 555
</span><span class='line'>
</span><span class='line'><span class="nb">set </span>routing-options autonomous-system 555
</span><span class='line'><span class="nb">set </span>protocols bgp group EVPN <span class="nb">type </span>internal
</span><span class='line'><span class="nb">set </span>protocols bgp group EVPN <span class="nb">local</span>-address 99.99.99.1
</span><span class='line'><span class="nb">set </span>protocols bgp group EVPN family evpn signaling
</span><span class='line'><span class="nb">set </span>protocols bgp group EVPN neighbor 99.99.99.2
</span><span class='line'><span class="nb">set </span>protocols bgp group EVPN neighbor 99.99.99.3
</span></code></pre></td></tr></table></div></figure>


<h3>Configuring End-host connectivity and IRB</h3>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">set </span>vlans BD5010 vlan-id 10
</span><span class='line'><span class="nb">set </span>vlans BD5010 l3-interface irb.10
</span><span class='line'><span class="nb">set </span>vlans BD5020 vlan-id 20
</span><span class='line'><span class="nb">set </span>vlans BD5020 l3-interface irb.20
</span><span class='line'><span class="nb">set </span>interfaces xe-0/0/1 unit <span class="m">0</span> family ethernet-switching vlan members 10
</span><span class='line'><span class="nb">set </span>interfaces xe-0/0/3 unit <span class="m">0</span> family ethernet-switching vlan members 20
</span><span class='line'><span class="nb">set </span>interfaces irb unit <span class="m">10</span> family inet address 10.0.0.254/24
</span><span class='line'><span class="nb">set </span>interfaces irb unit <span class="m">20</span> family inet address 20.0.0.254/24
</span></code></pre></td></tr></table></div></figure>


<h3>Configuring L2 EVPN services</h3>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">set </span>protocols evpn encapsulation vxlan
</span><span class='line'><span class="nb">set </span>protocols evpn extended-vni-list all
</span><span class='line'><span class="nb">set </span>protocols evpn multicast-mode ingress-replication
</span><span class='line'>
</span><span class='line'><span class="nb">set </span>switch-options vtep-source-interface lo0.0
</span><span class='line'><span class="nb">set </span>switch-options route-distinguisher 555:0
</span><span class='line'><span class="nb">set </span>switch-options vrf-target target:555:123
</span><span class='line'>
</span><span class='line'><span class="nb">set </span>vlans BD5010 vxlan vni 5010
</span><span class='line'><span class="nb">set </span>vlans BD5010 vxlan ingress-node-replication
</span><span class='line'><span class="nb">set </span>vlans BD5020 vxlan vni 5020
</span><span class='line'><span class="nb">set </span>vlans BD5020 vxlan ingress-node-replication
</span></code></pre></td></tr></table></div></figure>


<h3>Configuring L3 EVPN service</h3>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF instance-type vrf
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF interface irb.10
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF interface irb.20
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF interface lo0.10
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF route-distinguisher 555:1
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF vrf-target target:123:5055
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF protocols evpn ip-prefix-routes advertise direct-nexthop
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF protocols evpn ip-prefix-routes encapsulation vxlan
</span><span class='line'><span class="nb">set </span>routing-instances EVPN-VRF protocols evpn ip-prefix-routes vni 5555
</span></code></pre></td></tr></table></div></figure>


<h2>Traffic flow overview</h2>

<p>Once all the nodes have been configured, we can have a closer look at the traffic flows, specifically at how packets are being forwarded and where the L2 and L3 lookups take place.</p>

<h3>L2 forwarding - H1 to H2 (00:50:79:66:68:06)</h3>

<p>Traffic from H1 to H2 will never leave its own broadcast domain. As soon as the packet hits the incoming interface of SW1, MAC address lookup occurs pointing to the remote VTEP interface of SW2.</p>

<figure class='code'><figcaption><span>SW1> show ethernet-switching table | match 00:50:79:66:68:06</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   BD5010              00:50:79:66:68:06   D        vtep.32769             99.99.99.2
</span></code></pre></td></tr></table></div></figure>


<p>Once SW2 decapsulates the packet, the lookup in the MAC address table returns the locally connected interface, where it gets forwarded next.</p>

<figure class='code'><figcaption><span>SW2> show ethernet-switching table | match 00:50:79:66:68:06</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   BD5010              00:50:79:66:68:06   D        xe-0/0/1.0
</span></code></pre></td></tr></table></div></figure>


<h3>L3 forwarding (symmetric) - H3 to H4</h3>

<p>The route to 8.8.8.0/24 is advertised by SW3 in type-5 NLRI</p>

<figure class='code'><figcaption><span>SW1> show route receive-protocol bgp 99.99.99.3 extensive</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>* 5:555:1::0::8.8.8.0::24/304 <span class="o">(</span><span class="m">1</span> entry, <span class="m">1</span> announced<span class="o">)</span>
</span><span class='line'>     Import Accepted
</span><span class='line'>     Route Distinguisher: 555:1
</span><span class='line'>     Route Label: 5555
</span><span class='line'>     Overlay gateway address: 0.0.0.0
</span><span class='line'>     Nexthop: 99.99.99.3
</span><span class='line'>     Localpref: 100
</span><span class='line'>     AS path: I
</span><span class='line'>     Communities: target:123:5055 encapsulation0:0:0:0:vxlan router-mac:02:05:86:71:72:00
</span></code></pre></td></tr></table></div></figure>


<p>This NLRI doesn&rsquo;t contain any overlay gateway address, however it does have a special &ldquo;router-mac&rdquo; community with a globally unique SW3&rsquo;s chassis MAC. This MAC is advertised as normal type-2 MAC address and points to the remote VTEP interface of SW3:</p>

<figure class='code'><figcaption><span>SW1> show ethernet-switching table | match 02:05:86:71:72:00</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   BD5010              02:05:86:71:72:00   D        vtep.32770             99.99.99.3
</span></code></pre></td></tr></table></div></figure>


<p>The above two pieces of information are fed into our EVPN-VRF routing table to produce the entry with the following parameters:</p>

<figure class='code'><figcaption><span>SW1> show route table EVPN-VRF.inet.0 detail 8.8.8.8 | match "VTEP|VNI|MAC"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Encap VNI: 5555, Decap VNI: 5555
</span><span class='line'>Source VTEP: 99.99.99.1, Destination VTEP: 99.99.99.3
</span><span class='line'>SMAC: 02:05:86:71:3b:00, DMAC: 02:05:86:71:72:00
</span></code></pre></td></tr></table></div></figure>


<p>This is the example of how &ldquo;symmetric&rdquo; IRB routing is performed. Instead of routing the packet at the ingress and switching at the egress node, how it was done in the case of Neutron&rsquo;s <a href="http://networkop.github.io/blog/2016/10/13/os-dvr/">DVR</a>, the routing is performed twice. First the packet is routed into a &ldquo;transit&rdquo; VNI 5555, which glues all the switches in the same EVI together from the L3 perspective. Once the packet reaches the destination node, it gets routed into the intended VNI (5088 in our case) and forwarded out the local interface. This way switches may have different sets of VLANs and IRBs and still be able route packets between VXLANs.</p>

<h3>L3 forwarding (asymmetric) - H1 to H4</h3>

<p>As you may have noticed, the green broadcast domain extends to all three switches, even though hosts are only attached to the first two. Let&rsquo;s see how it will affect the packet flows.
The flow from H1 to H4 will be similar to the one from H3 to H4 described above. However return packets will get routed on SW3 directly into VXLAN5010, since that switch has an IRB.10 interface and then switched all the way to H1.</p>

<figure class='code'><figcaption><span>SW3> show route forwarding-table destination 10.0.0.1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Routing table: EVPN-VRF.inet
</span><span class='line'>Internet:
</span><span class='line'>Destination        Type RtRef Next hop           Type Index    NhRef Netif
</span><span class='line'>10.0.0.1/32        dest     <span class="m">0</span> 0:50:79:66:68:5    ucst     <span class="m">1772</span>     <span class="m">1</span> vtep.32770
</span></code></pre></td></tr></table></div></figure>


<p>This is the example of &ldquo;asymmetric&rdquo; routing, similar to the one exhibited by Neutron <a href="http://networkop.github.io/blog/2016/10/13/os-dvr/">DVR</a>. You would see similar behaviour if you examined the flow between H3 and H2.</p>

<h2>Conclusion</h2>

<p>So why all the hassle configuring EPVN on data centre switches? For one, you can <a href="http://forums.juniper.net/t5/Data-Center-Technologists/MC-LAG-is-dead-Long-live-EVPN-Multi-homing/ba-p/298924">get rid</a> of MLAG in TOR switches and replace it with EVPN multihoming. However, the main benefit is that you can stretch L2 broadcast domains across your whole data centre without the need for an SDN controller. So, for example, we can now easily satisfy the requirement of having external floating IP network on all compute nodes introduced by <a href="http://networkop.github.io/blog/2016/10/13/os-dvr/">Neutron DVR</a>. EVPN-enabled switches can also now perform functions similar to DC gateway routers (the likes of ASR, MX or SR) while giving you the benefits of horizontal scaling of Leaf/Spine networks. As <a href="https://docs.cumulusnetworks.com/display/DOCS/Ethernet+Virtual+Private+Network+-+EVPN">more</a> and <a href="https://eos.arista.com/forum/evpn-control-plane-support-for-vxlan/">more</a> vendors introduce EVPN support, it is poised to become the ultimate DC routing protocol, complementing the functions already performed by the host-based virtual switches, and with all the DC switches <a href="http://networkop.github.io/blog/2016/09/09/os-lab-p2/">running BGP</a> already, introducing EVPN may be as easy as enabling a new address family.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStack SDN - Distributed Virtual Routing]]></title>
    <link href="http://networkop.github.io/blog/2016/10/13/os-dvr/"/>
    <updated>2016-10-13T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/10/13/os-dvr</id>
    <content type="html"><![CDATA[<p>In this post we&rsquo;ll explore how DVR is implemented in OpenStack Neutron and what are some of its benefits and shortcomings.</p>

<!--more-->


<p>To be honest I was a little hesitant to write this post because the topic of Neutron&rsquo;s DVR has already been <abbr title="beaten to death">exhaustively covered</abbr> by many, including <a href="https://assafmuller.com/category/dvr/">Assaf Muller</a>, <a href="http://blog.gampel.net/2014/12/openstack-neutron-distributed-virtual.html">Eran Gampel</a> and in the official OpenStack <a href="http://docs.openstack.org/mitaka/networking-guide/scenario-dvr-ovs.html">networking guide</a>. The coverage of the topic was so thorough that I barely had anything to add. However I still decided to write a DVR post of my own for the following two reasons:</p>

<ol>
<li>I often use my own posts as references and it&rsquo;s always easier for me to find information in my own writings.</li>
<li>I wanted to use this post as a reference platform for subsequent posts about dynamic routing and OVN project.</li>
</ol>


<p>The topic of Neutron&rsquo;s DVR is quite vast so I had to compromise between the length of this post and the level of details. In the end, I edited out most of the repeated content and replaced it with references to my older posts. I think I left everything that should be needed to follow along the narrative so hopefully it won&rsquo;t seem too patchy.</p>

<h2>Virtual topology overview</h2>

<p>Let&rsquo;s see what we&rsquo;re going to be dealing with in this post. This is a simple virtual topology with two VMs sitting in two different subnets. VM1 has a floating IP assigned that is used for external access.</p>

<p><img class="center" src="http://networkop.github.io/images/dvr-topo.png"></p>

<p>Before we get to the packet walk details, let me briefly describe how to build the above topology using Neutron CLI. I&rsquo;ll assume that OpenStack has just been installed and nothing has been configured yet, effectively we&rsquo;ll pick up from where we left our lab in the <a href="http://networkop.github.io/blog/2016/09/09/os-lab-p2/">previous post</a>.</p>

<h2>Virtual topology setup</h2>

<ol>
<li>Upload Cirros Linux image to OpenStack's image repository

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img | glance \
</span><span class='line'>     image-create --name='IMG-CIRROS' \
</span><span class='line'>     --visibility=public \
</span><span class='line'>     --container-format=bare \
</span><span class='line'>     --disk-format=qcow2</span></code></pre></td></tr></table></div></figure>
</li>
<li>Create 2 virtual subnets - RED and BLUE

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>neutron net-create NET-BLUE
</span><span class='line'>neutron subnet-create --name SUB-BLUE NET-BLUE 10.0.0.0/24 \
</span><span class='line'>  --dns-nameserver 8.8.8.8
</span><span class='line'>
</span><span class='line'>neutron net-create NET-RED
</span><span class='line'>neutron subnet-create --name SUB-RED NET-RED 10.0.1.0/24 \
</span><span class='line'>  --dns-nameserver 8.8.8.8</span></code></pre></td></tr></table></div></figure>
</li>
<li>Create external network

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>neutron net-create EXT-NET --provider:network_type flat \
</span><span class='line'>  --provider:physical_network extnet  \
</span><span class='line'>  --router:external \
</span><span class='line'>  --shared
</span><span class='line'>
</span><span class='line'>neutron subnet-create --name EXT-SUB \
</span><span class='line'> --enable_dhcp=False \
</span><span class='line'> --allocation-pool=start=169.254.0.50,end=169.254.0.99 \
</span><span class='line'> --gateway=169.254.0.1 EXT-NET 169.254.0.0/24</span></code></pre></td></tr></table></div></figure>
</li>

<li>Create a router and attach it to all three networks created above

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>neutron router-create R1
</span><span class='line'>neutron router-interface-add R1 SUB-RED
</span><span class='line'>neutron router-interface-add R1 SUB-BLUE
</span><span class='line'>neutron router-gateway-set R1 EXT-NET</span></code></pre></td></tr></table></div></figure>
</li>

<li>Create two host aggregates to spread the VMs across two different hosts

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nova aggregate-create AGG-RED AZ-RED
</span><span class='line'>nova aggregate-create AGG-BLUE AZ-BLUE
</span><span class='line'>nova aggregate-add-host AGG-BLUE compute-2
</span><span class='line'>nova aggregate-add-host AGG-RED compute-3</span></code></pre></td></tr></table></div></figure>
</li>

<li>Boot VMs on two different hypervisors

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nova boot --flavor m1.tiny --image 'IMG-CIRROS' \
</span><span class='line'>     --nic net-name=NET-BLUE \
</span><span class='line'>    --availability-zone AZ-BLUE \
</span><span class='line'>     VM1
</span><span class='line'>
</span><span class='line'>nova boot --flavor m1.tiny --image 'IMG-CIRROS' \
</span><span class='line'>    --nic net-name=NET-RED \
</span><span class='line'>    --availability-zone AZ-RED \
</span><span class='line'>    VM2</span></code></pre></td></tr></table></div></figure>
</li>

<li>Assign a floating IP (Static NAT) to VM1

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nova floating-ip-create EXT-NET
</span><span class='line'>nova floating-ip-associate VM1 169.254.0.55</span></code></pre></td></tr></table></div></figure>
</li>

<li>Enable ingress ICMP and SSH access

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>nova secgroup-add-rule default tcp 22 22 0.0.0.0/0
</span><span class='line'>nova secgroup-add-rule default icmp -1 -1 0.0.0.0/0</span></code></pre></td></tr></table></div></figure>
</li>

<li>Make sure that both VMs are up and running.

<figure class='code'><figcaption><span>nova list</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>+--------------------------------------+------+--------+------------+-------------+----------------------------------+
</span><span class='line'><span class="p">|</span> ID                                   <span class="p">|</span> Name <span class="p">|</span> Status <span class="p">|</span> Task State <span class="p">|</span> Power State <span class="p">|</span> Networks                         <span class="p">|</span>
</span><span class='line'>+--------------------------------------+------+--------+------------+-------------+----------------------------------+
</span><span class='line'><span class="p">|</span> 92263ae8-43d1-4cd0-b271-2b11f0efbe7f <span class="p">|</span> VM1  <span class="p">|</span> ACTIVE <span class="p">|</span> -          <span class="p">|</span> Running     <span class="p">|</span> NET-BLUE<span class="o">=</span>10.0.0.12, 169.254.0.55 <span class="p">|</span>
</span><span class='line'><span class="p">|</span> b4562f24-2461-49fb-875b-fa1bf869dc4a <span class="p">|</span> VM2  <span class="p">|</span> ACTIVE <span class="p">|</span> -          <span class="p">|</span> Running     <span class="p">|</span> NET-RED<span class="o">=</span>10.0.1.4                 <span class="p">|</span>
</span><span class='line'>+--------------------------------------+------+--------+------------+-------------+----------------------------------+
</span></code></pre></td></tr></table></div></figure>
</li>
</ol>


<h2>non-DVR traffic flow</h2>

<p>Using the technique described in my <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">earlier post</a> I&rsquo;ve collected the dynamically allocated port numbers and created a physical representation of our virtual network.</p>

<p><img class="center" src="http://networkop.github.io/images/dvr-before.png"></p>

<p>For the sake of brevity I will omit the verification commands. The traffic flow between VM1 and VM2 will follow the standard path that I&rsquo;ve explored in my <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">native Neutron SDN post</a>.<br/>
It is obvious that in this case traffic flows are suboptimal. Instead of going directly between the peer compute nodes, the packet has to hairpin through a Neutron router. This adds to the end-to-end latency and creates unnecessary load on the Network node. These are one of the main reasons why Distributed Virtual Routing was introduced in OpenStack Juno.</p>

<h2>Enabling DVR</h2>

<p>Enabling DVR requires configuration changes of multiple files on all OpenStack nodes. At a high level, all compute nodes will now run Neutron&rsquo;s L3-agent service which will be responsible for provisioning of DVR and other auxiliary namespaces. The details of specific configuration options that need to be enabled can be found in the official OpenStack <a href="http://docs.openstack.org/mitaka/networking-guide/scenario-dvr-ovs.html">Networking guide</a>. As usual, I&rsquo;ve incorporated all the necessary changes into a single Chef <a href="https://github.com/networkop/chef-unl-os/tree/master/cookbooks/neutron">cookbook</a>, so in order to enable DVR in our lab all what you need to do is run the following commands from the UNetLab VM:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git pull origin master
</span><span class='line'>chef-client -z -E lab neutron.rb
</span></code></pre></td></tr></table></div></figure>


<p>Once all changes has been made, we need to either create a new router or update the existing one to enable the DVR functionality:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>neutron router-update --admin-state-up False --distributed True R1
</span><span class='line'>neutron router-update --admin-state-up True R1
</span></code></pre></td></tr></table></div></figure>


<h2>DVR East-West traffic flow</h2>

<p>Now let&rsquo;s see how the traffic flows have changed with the introduction of DVR.</p>

<p><img class="center" src="http://networkop.github.io/images/dvr-ew.png"></p>

<p>We&rsquo;re going to be examining the following traffic flow:</p>

<ul>
<li>From VM1 (10.0.0.12/fa:16:3e:83:92:96)</li>
<li>Via router R1 (10.0.0.1/fa:16:3e:72:7a:50; 10.0.1.1/fa:16:3e:6a:2c:8b)</li>
<li>To VM2 (10.0.1.4/fa:16:3e:76:31:68)</li>
</ul>


<p>R1 now has an instance on all compute nodes that have VMs in the BLUE or RED networks. That means that VM1 will send a packet directly to the R1&rsquo;s BLUE interface via the integration bridge.</p>

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">2</span>     <span class="m">1</span>  fa:16:3e:83:92:96    1
</span><span class='line'>    <span class="m">4</span>     <span class="m">1</span>  fa:16:3e:72:7a:50    1
</span><span class='line'>    <span class="m">5</span>     <span class="m">2</span>  fa:16:3e:6a:2c:8b    1
</span></code></pre></td></tr></table></div></figure>


<p>This is dynamically populated MAC address table of the integration bridge. You can see that the MAC address of VM1 and both interfaces of R1 have been learned. That means that when VM1 sends a packet to its default gateway&rsquo;s MAC address, it will go directly to R1&rsquo;s BLUE interface on port 4.</p>

<p>In this post I will omit the details of ARP resolution process which remains the same as <a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">before</a>, however there&rsquo;s one interesting detail that is worth mentioning before we move on. During the initial flood-and-learn phase on the <strong>br-int</strong>, the ARP request will get flooded down to the tunnel bridge. As per the standard behaviour, the packet should get replicated to all nodes. However, in this case we don&rsquo;t want to hear responses from other nodes, since the router is hosted locally. In order to help that, tunnel bridges explicitly drop all packets coming from integration bridges and destined for MAC addresses of locally hosted routers:</p>

<figure class='code'><figcaption><span>ovs-appctl ofproto/trace br-tun in_port=1,dl_vlan=1,dl_dst=fa:16:3e:72:7a:50 | grep -E "Rule|action"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xa3536ac94478bd1d <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>1
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>goto_table:1
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">1</span> <span class="nv">cookie</span><span class="o">=</span>0xa3536ac94478bd1d <span class="nv">priority</span><span class="o">=</span>2,dl_vlan<span class="o">=</span>1,dl_dst<span class="o">=</span>fa:16:3e:72:7a:50
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>drop
</span></code></pre></td></tr></table></div></figure>


<p>Getting back to our traffic flow, once the IP packet has reached the DVR instance of R1 on compute node #2, the routing lookup occurs and the packet is sent back to the integration bridge with a new source MAC of R1&rsquo;s RED interface.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip route</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>10.0.0.0/24 dev qr-102c4426-86  proto kernel  scope link  src 10.0.0.1
</span><span class='line'>10.0.1.0/24 dev qr-3779302e-62  proto kernel  scope link  src 10.0.1.1
</span></code></pre></td></tr></table></div></figure>


<p>Tunnel bridge will do its usual work by locating the target compute node based on the destination MAC address of VM2 (DVR requires <a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">L2 population</a> to be enabled) and will send the packet directly to the compute node #3.</p>

<figure class='code'><figcaption><span>ovs-appctl ofproto/trace br-tun in_port=1,dl_vlan=2,dl_src=fa:16:3e:6a:2c:8b,dl_dst=fa:16:3e:76:31:68 | grep -E "Rule|action"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xa3536ac94478bd1d <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>1
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>goto_table:1
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">1</span> <span class="nv">cookie</span><span class="o">=</span>0xa3536ac94478bd1d <span class="nv">priority</span><span class="o">=</span>1,dl_vlan<span class="o">=</span>2,dl_src<span class="o">=</span>fa:16:3e:6a:2c:8b
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>set_field:fa:16:3f:d3:10:60-&gt;eth_src,goto_table:2
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">2</span> <span class="nv">cookie</span><span class="o">=</span>0xa3536ac94478bd1d <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>goto_table:20
</span><span class='line'>                        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">20</span> <span class="nv">cookie</span><span class="o">=</span>0xa3536ac94478bd1d <span class="nv">priority</span><span class="o">=</span>2,dl_vlan<span class="o">=</span>2,dl_dst<span class="o">=</span>fa:16:3e:76:31:68
</span><span class='line'>                        OpenFlow <span class="nv">actions</span><span class="o">=</span>pop_vlan,set_field:0x4d-&gt;tun_id,output:3
</span></code></pre></td></tr></table></div></figure>


<p>Since all instances of R1 have the same set of IP/MAC addresses, the MAC address of a local router can be learned by the remote integration bridge hosting the same instance of DVR. In order to prevent that from happening, the sending <strong>br-tun</strong> replaces the source MAC address of the frame with the <code>set_field:fa:16:3f:d3:10:60-&gt;eth_src</code> action. This way the real R1&rsquo;s MAC address gets masked as the frame leaves the node. These &ldquo;mask&rdquo; MACs are generated by and learned from the Neutron server, which ensures that each node gets a unique address.</p>

<p>The receiving node&rsquo;s <strong>br-tun</strong> will swap the VXLAN header with a VLAN ID and forward the frame up to the integration bridge.</p>

<figure class='code'><figcaption><span>ovs-appctl ofproto/trace br-tun in_port=3,tun_id=0x4d,dl_dst=fa:16:3e:76:31:68 | grep -E "Rule|action"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0x8a7dedf35101427f <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>3
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>goto_table:4
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">4</span> <span class="nv">cookie</span><span class="o">=</span>0x8a7dedf35101427f <span class="nv">priority</span><span class="o">=</span>1,tun_id<span class="o">=</span>0x4d
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>push_vlan:0x8100,set_field:4097-&gt;vlan_vid,goto_table:9
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">9</span> <span class="nv">cookie</span><span class="o">=</span>0x8a7dedf35101427f <span class="nv">priority</span><span class="o">=</span>0
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>goto_table:10
</span><span class='line'>                        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">10</span> <span class="nv">cookie</span><span class="o">=</span>0x8a7dedf35101427f <span class="nv">priority</span><span class="o">=</span>1
</span><span class='line'>                        OpenFlow <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,cookie<span class="o">=</span>0x8a7dedf35101427f,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:OXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span><span class='line'>                                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0x9a1e0026794eadc5 <span class="nv">priority</span><span class="o">=</span>1
</span><span class='line'>                                OpenFlow <span class="nv">actions</span><span class="o">=</span>NORMAL
</span></code></pre></td></tr></table></div></figure>


<p>Integration bridge of compute node #3 will lookup the destination MAC address and send the packet out port 2.</p>

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">2</span>     <span class="m">1</span>  fa:16:3e:76:31:68    0
</span><span class='line'>    <span class="m">4</span>     <span class="m">2</span>  fa:16:3e:72:7a:50    0
</span><span class='line'>    <span class="m">5</span>     <span class="m">1</span>  fa:16:3e:6a:2c:8b    0
</span><span class='line'>    <span class="m">1</span>     <span class="m">1</span>  fa:16:3e:29:de:20    0
</span></code></pre></td></tr></table></div></figure>


<p>The reverse packet flow is similar - the packet will get routed on the compute node #3 and sent in a BLUE network to the compute node #2.</p>

<h2>External connectivity</h2>

<p>External connectivity will be very different for VMs with and without a floating IP. We will examine each case individually.</p>

<h3>Case 1 - Overload NAT (VM2 with no FIP)</h3>

<p><img class="center" src="http://networkop.github.io/images/dvr-snat.png"></p>

<p>External connectivity for VMs with no floating IP is still performed by the Network node. This time however, NATing is performed by a new element - SNAT namespace. As per the normal behaviour, VM2 will send a packet to its default gateway first. Let&rsquo;s have a closer look at the routing table of the DVR:</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip route</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>10.0.0.0/24 dev qr-102c4426-86  proto kernel  scope link  src 10.0.0.1
</span><span class='line'>10.0.1.0/24 dev qr-3779302e-62  proto kernel  scope link  src 10.0.1.1
</span></code></pre></td></tr></table></div></figure>


<p>There&rsquo;s no default route in the main routing table, so how would it get routed out? DVRs extensively use <a href="http://linux-ip.net/html/tools-ip-rule.html">Linux routing policy database</a> (RPDB), a feature that has a lot in common with OpenFlow tables. The principle of RPDB is that every packet gets matched against a set of routing tables until there&rsquo;s a hit. The tables are checked in the order of their priority (lowest to highest). One of the main features of RPDB is the ability to perform matches based on something other than the destination IP address, which is why it&rsquo;s often referred to as policy-based routing. To view the contents of RPDB use the <code>ip rule</code> command under the DVR namespace:</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip rule</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>0:      from all lookup <span class="nb">local</span>
</span><span class='line'>32766:  from all lookup main
</span><span class='line'>32767:  from all lookup default
</span><span class='line'>167772161:      from 10.0.0.1/24 lookup 167772161
</span><span class='line'>167772417:      from 10.0.1.1/24 lookup 167772417
</span></code></pre></td></tr></table></div></figure>


<p>In our case table 167772161 matches all packets sourced from the BLUE subnet and if we examine the corresponding routing table we&rsquo;ll find the missing default route there.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip route list table 167772417</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>default via 10.0.1.12 dev qr-3779302e-62
</span></code></pre></td></tr></table></div></figure>


<p>The next hop of this default route points to the SNAT&rsquo;s interface in the BLUE network. MAC address is statically programmed by the local L3-agent.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip neigh | grep 10.0.1.12</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>10.0.1.12 dev qr-3779302e-62 lladdr fa:16:3e:29:de:20 PERMANENT
</span></code></pre></td></tr></table></div></figure>


<p>Integration bridge sends the packet out port 1 to the tunnel bridge.</p>

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int | grep fa:16:3e:29:de:20</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="m">1</span>     <span class="m">1</span>  fa:16:3e:29:de:20    1
</span></code></pre></td></tr></table></div></figure>


<p>Tunnel bridge finds the corresponding match and sends the VXLAN-encapsulated packet to the Network node.</p>

<figure class='code'><figcaption><span>ovs-appctl ofproto/trace br-tun in_port=1,dl_vlan=1,dl_dst=fa:16:3e:29:de:20 | tail -n 1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Datapath actions: <span class="nb">set</span><span class="o">(</span>tunnel<span class="o">(</span><span class="nv">tun_id</span><span class="o">=</span>0x4d,src<span class="o">=</span>10.0.0.4,dst<span class="o">=</span>10.0.0.0,ttl<span class="o">=</span>64,flags<span class="o">(</span>df<span class="p">|</span>key<span class="o">)))</span>,pop_vlan,3
</span></code></pre></td></tr></table></div></figure>


<p>Tunnel bridge of the Network node forwards the frame up to the integration bridge.</p>

<figure class='code'><figcaption><span>ovs-appctl ofproto/trace br-tun in_port=3,tun_id=0x4d,dl_dst=fa:16:3e:29:de:20 | grep output</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,cookie<span class="o">=</span>0xb9be3fe62922c800,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:OXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span></code></pre></td></tr></table></div></figure>


<p>Integration bridge sends the frame to port 10, which is where SNAT namespace is attached</p>

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int | grep fa:16:3e:29:de:20</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="m">10</span>     <span class="m">1</span>  fa:16:3e:29:de:20    0
</span></code></pre></td></tr></table></div></figure>


<p>SNAT is a namespace with an interface in each of the subnets - BLUE, RED and External subnet</p>

<figure class='code'><figcaption><span>ip netns exec snat-uuid ip a | grep -E "UP|inet"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>16: sg-fefd493b-a5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1450</span> qdisc noqueue state UNKNOWN
</span><span class='line'>    link/ether fa:16:3e:99:5c:3a brd ff:ff:ff:ff:ff:ff
</span><span class='line'>    inet 10.0.0.6/24 brd 10.0.0.255 scope global sg-fefd493b-a5
</span><span class='line'>18: sg-b3d58360-b4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1450</span> qdisc noqueue state UNKNOWN
</span><span class='line'>    link/ether fa:16:3e:29:de:20 brd ff:ff:ff:ff:ff:ff
</span><span class='line'>    inet 10.0.1.12/24 brd 10.0.1.255 scope global sg-b3d58360-b4
</span><span class='line'>19: qg-765b5aca-ce: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UNKNOWN
</span><span class='line'>    link/ether fa:16:3e:d5:75:0e brd ff:ff:ff:ff:ff:ff
</span><span class='line'>    inet 169.254.0.57/24 brd 169.254.0.255 scope global qg-765b5aca-ce
</span></code></pre></td></tr></table></div></figure>


<p>SNAT has a single default route pointing to the External network&rsquo;s gateway.</p>

<figure class='code'><figcaption><span>ip netns exec snat-uuid ip route | grep default</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>default via 169.254.0.1 dev qg-765b5aca-ce
</span></code></pre></td></tr></table></div></figure>


<p>Before sending the packet out, iptables will NAT the packet to hide it behind SNAT&rsquo;s <strong>qg</strong> external interface IP.</p>

<figure class='code'><figcaption><span>ip netns exec snat-uuid iptables -t nat -L | grep SNAT</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>SNAT       all  --  anywhere             anywhere             to:169.254.0.57
</span></code></pre></td></tr></table></div></figure>


<h3>Case 2 - Static NAT (VM1 with FIP)</h3>

<p><img class="center" src="http://networkop.github.io/images/dvr-dnat.png"></p>

<p>The first step in this scenario is the same - VM1 sends a packet to the MAC address of its default gateway. As before, the default route is missing in the main routing table.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip route list table main</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>10.0.0.0/24 dev qr-102c4426-86  proto kernel  scope link  src 10.0.0.1
</span><span class='line'>10.0.1.0/24 dev qr-3779302e-62  proto kernel  scope link  src 10.0.1.1
</span><span class='line'>169.254.106.114/31 dev rfp-e4d4897e-7  proto kernel  scope link  src 169.254.106.114
</span></code></pre></td></tr></table></div></figure>


<p>Looking at the <strong>ip rule</strong> configuration we can find that table 16 matches all packets from that particular VM (10.0.0.12).</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip rule</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>0:      from all lookup <span class="nb">local</span>
</span><span class='line'>32766:  from all lookup main
</span><span class='line'>32767:  from all lookup default
</span><span class='line'>57481:  from 10.0.0.12 lookup 16
</span><span class='line'>167772161:      from 10.0.0.1/24 lookup 167772161
</span><span class='line'>167772417:      from 10.0.1.1/24 lookup 167772417
</span></code></pre></td></tr></table></div></figure>


<p>Routing table 16 sends the packet via a point-to-point veth pair link to the FIP namespace.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid ip route list table 16</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>default via 169.254.106.115 dev rfp-e4d4897e-7
</span></code></pre></td></tr></table></div></figure>


<p>Before sending the packet out, DVR translates the source IP of the packet to the FIP assigned to that VM.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid iptables -t nat -L | grep NAT</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>SNAT       all  --  10.0.0.12            anywhere             to:169.254.0.55
</span></code></pre></td></tr></table></div></figure>


<p>A FIP namespace is a simple router designed to connect multiple DVRs to external network. This way all routers can share the same &ldquo;uplink&rdquo; namespace and don&rsquo;t have to consume valuable addresses from external subnet.</p>

<figure class='code'><figcaption><span>ip netns exec fip-uuid ip a | grep -E "UP|inet"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>2: fpr-e4d4897e-7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc pfifo_fast state UP qlen 1000
</span><span class='line'>    inet 169.254.106.115/31 scope global fpr-e4d4897e-7
</span><span class='line'>15: <span class="nb">fg</span>-d3bb699d-af: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UNKNOWN
</span><span class='line'>    inet 169.254.0.58/24 brd 169.254.0.255 scope global <span class="nb">fg</span>-d3bb699d-af
</span></code></pre></td></tr></table></div></figure>


<p>Default route inside the FIP namespace points to the External subnet&rsquo;s gateway IP.</p>

<figure class='code'><figcaption><span>ip netns exec fip-uuid ip route | grep default</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>default via 169.254.0.1 dev <span class="nb">fg</span>-d3bb699d-af
</span></code></pre></td></tr></table></div></figure>


<p>The MAC address of the gateway is statically configured by the L3 agent.</p>

<figure class='code'><figcaption><span>ip netns exec fip-uuid ip neigh | grep 169.254.0.1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>169.254.0.1 dev <span class="nb">fg</span>-d3bb699d-af lladdr 32:3e:7d:13:ca:78 DELAY
</span></code></pre></td></tr></table></div></figure>


<p>The packet is sent to the <strong>br-int</strong> with the destination MAC address of the default gateway, which is learned on port 3.</p>

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int | grep 32:3e:7d:13:ca:78</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>  <span class="m">3</span>     <span class="m">3</span>  32:3e:7d:13:ca:78    1
</span></code></pre></td></tr></table></div></figure>


<p>External bridge strips the VLAN ID of the packet coming from the <strong>br-int</strong> and does the lookup in the dynamic MAC address table.</p>

<figure class='code'><figcaption><span>ovs-appctl ofproto/trace br-ex in_port=2,dl_vlan=3 | grep actions=</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>pop_vlan,NORMAL
</span></code></pre></td></tr></table></div></figure>


<p>The frame is forwarded out the physical interface.</p>

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-ex | grep 32:3e:7d:13:ca:78</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="m">1</span>     <span class="m">0</span>  32:3e:7d:13:ca:78    1
</span></code></pre></td></tr></table></div></figure>


<p>Reverse packet flow will be quite similar, however in this case FIP namespace must be able to respond to ARP requests for the IPs that only exist on DVRs. In order to do that, it uses a proxy-ARP feature. First, L3 agent installs a static route for the FIP pointing back to the correct DVR over the veth pair interface:</p>

<figure class='code'><figcaption><span>ip netns exec fip-uuid ip route get 169.254.0.55</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>169.254.0.55 via 169.254.106.114 dev fpr-e4d4897e-7  src 169.254.106.115
</span></code></pre></td></tr></table></div></figure>


<p>Now that the FIP namespace knows the route to the floating IP, it can respond to ARPs on behalf of DVR as long as proxy-ARP is enabled on the external <strong>fg</strong> interface:</p>

<figure class='code'><figcaption><span>ip netns exec fip-uuid</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>cat /proc/sys/net/ipv4/conf/fg-d3bb699d-af/proxy_arp
</span><span class='line'>1
</span></code></pre></td></tr></table></div></figure>


<p>Finally, the DVR NATs the packet back to its internal IP in the BLUE subnet and forwards it straight to VM1.</p>

<figure class='code'><figcaption><span>ip netns exec qrouter-uuid iptables -t nat -L | grep DNAT</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>DNAT       all  --  anywhere             169.254.0.55         to:10.0.0.12
</span></code></pre></td></tr></table></div></figure>


<h2>DVR Pros and Cons</h2>

<p>Without a doubt DVR has introduced a number of much needed <strong>improvements</strong> to OpenStack networking:</p>

<ul>
<li>East-West traffic now follows the most optimal path thereby reducing the load on the Network node.</li>
<li>External connectivity to floating IPs now also follows the most optimal path directly to the compute node hosting the VM.</li>
</ul>


<p>However, there&rsquo;s a number of <strong>issues</strong> that either remain unaddressed or result directly from the current DVR architecture:</p>

<ul>
<li>DHCP and SNAT are still hosted on the Network node.</li>
<li>Asymmetric routing means that every DVR needs to have an interface in every configured subnet, even when there are no VMs that belong to those subnets on the current compute node.</li>
<li>Direct connectivity to FIP means that all compute nodes now need to have direct L2 adjacency to external subnets.</li>
<li>FIP namespace on compute nodes consumes IP addresses from external subnets which can be a problem if external subnet is in a public IPv4 address range.</li>
<li>DVR implementation as a network namespace creates additional overhead in packet processing.</li>
</ul>


<p>Some of the above issues are not critical and can be fixed with a little effort:</p>

<ul>
<li>In order to reduce the scope of a External network VLAN span inside the DC, dedicate a subset of hosts that will have a direct L2 adjacency to external networks and only deploy external-facing VMs on those hosts.</li>
<li>Since FIP namespace only requires an external IP address for <a href="http://lists.openstack.org/pipermail/openstack-dev/2016-June/096386.html">debugging purposes</a>, we can create an additional, secondary, subnet in RFC1918 space for FIP connectivity. This is enabled by a feature called subnet <a href="https://specs.openstack.org/openstack/neutron-specs/specs/newton/subnet-service-types.html">&ldquo;Service types&rdquo;</a> and is <a href="https://github.com/openstack/neutron-specs/blob/master/specs/newton/subnet-service-types.rst">available</a> in the latest Newton release.</li>
</ul>


<p>However the main issue still remains unresolved. Every North-South packet has to hop several times between the global and DVR/FIP/NAT namespaces. These kind of operations are very expensive in terms of consumed CPU and memory resources and can be very detrimental to network performance. Using namespaces may be the most straight-forward and non-disruptive way of implementing DVR, however it&rsquo;s definitely not the most optimal. Ideally we&rsquo;d like to see both L2 and L3 pipelines implemented in OpenvSwitch tables. This way all packets can benefit from OVS <a href="https://networkheresy.com/2014/11/13/accelerating-open-vswitch-to-ludicrous-speed/">fast-path flow caching</a>. But fear not, the solution to this already exists in a shape of <a href="https://www.openstack.org/summit/vancouver-2015/summit-videos/presentation/ovn-native-virtual-networking-for-open-vswitch">Open Virtual Network</a>. OVN is a project spawned from the OVS and aims to <a href="https://blog.russellbryant.net/2016/09/29/ovs-2-6-and-the-first-release-of-ovn/">address</a> a number of shortcomings existing in current implementations of virtual networks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automating the Build of OpenStack Lab (Part 2)]]></title>
    <link href="http://networkop.github.io/blog/2016/09/09/os-lab-p2/"/>
    <updated>2016-09-09T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/09/09/os-lab-p2</id>
    <content type="html"><![CDATA[<p>In this post we&rsquo;ll use Chef, unnumbered BGP and Cumulus VX to build a massively scalable &ldquo;Lapukhov&rdquo; Leaf-Spine data centre.</p>

<!--more-->


<hr />

<p>In the <a href="http://networkop.github.io/blog/2016/08/26/os-lab-p1/">last post</a> we&rsquo;ve seen how to use Chef to automate the build of a 3-node OpenStack cloud. The only thing remaining is to build an underlay network supporting communication between the nodes, which is what we&rsquo;re going to do next. The build process will, again, be relatively simple and will include only a few manual steps, but before we get there let me go over some of the decisions and assumptions I&rsquo;ve made in my network design.</p>

<h2>High-level design</h2>

<p>The need to provide more bandwidth for East-West traffic has made the Clos Leaf-Spine architecture a de facto standard in any data centre network design. The use of virtual overlay networks has obviated the requirement to have a strict VLAN and IP numbering schemes in the underlay. The only requirement for the compute nodes now is to have any-to-any layer 3 connectivity. This is how the underlay network design has converged to a Layer 3 Leaf-Spine architecture.<br/>
The choice of a routing protocol is not so straight-forward. My fellow countryman Petr Lapukhov and co-authors of <a href="https://tools.ietf.org/html/draft-ietf-rtgwg-bgp-routi3ng-large-dc-11">RFC draft</a> claim that having a single routing protocol in your WAN and DC reduces complexity and makes interoperability and operations a lot easier. This draft presents some of the design principles that can be used to build a L3 data centre with BGP as the only routing protocol. In our lab we&rsquo;re going to implement a single &ldquo;cluster&rdquo; of the multi-tier topology proposed in that RFC.</p>

<p><img class="center" src="http://networkop.github.io/images/os-lab-chef-full.png"></p>

<p>In order to help us build this in an automated and scalable way, we&rsquo;re going to use a relatively new feature called <strong>unnumbered BGP</strong>.</p>

<h2>Unnumbered BGP as a replacement for IGP</h2>

<p>As we all know, one of the main advantages of interior gateway protocols is the automatic discovery of adjacent routers which is accomplished with the help of link-local multicasts. On the other hand, BGP traditionally required you to explicitly define neighbor&rsquo;s IP address in order to establish a peering relationship with it. This is where IPv6 comes to the rescue. With the help of neighbor discovery protocol and router advertisement messages, it becomes possible to accurately determine the address of the peer BGP router on an intra-fabric link. The only question is how we would exchange IPv4 information over and IPv6-only BGP network.<br/>
<a href="https://tools.ietf.org/html/rfc5549">RFC 5549</a>, described an &ldquo;extended nexthop encoding capability&rdquo; which allows BGP to exchange routing updates with nexthops that don&rsquo;t belong to the address family of the advertised prefix. In plain English it means that BGP is now capable of advertising an IPV4 prefix with an IPv6 nexthop. This makes it possible to configure all transit links inside the Clos fabric with IPv6 link-local addresses and still maintain reachability between the edge IPv4 host networks. Since nexthop IPs will get updated at every hop, there is no need for an underlying IGP to distribute them between all BGP routers. What we see is, effectively, BGP <strong>absorbing</strong> the functions of an IGP protocol inside the data centre.</p>

<h2>Configuration example on Cumulus VX</h2>

<p>In order to implement BGP unnumbered on Cumulus Linux all you need to is:</p>

<ol>
<li>Enable IPv6 router advertisements on all transit links</li>
<li>Enable BGP on the same interfaces</li>
</ol>


<p>Example Quagga configuration snippet will look like this:</p>

<figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>interface swp1
</span><span class='line'>  ipv6 nd ra-interval 5
</span><span class='line'>  no ipv6 nd suppress-ra
</span><span class='line'>
</span><span class='line'>rouer bgp &lt;ASN&gt;
</span><span class='line'>  neighbor swp1 interface
</span><span class='line'>  neighbor swp1 external
</span></code></pre></td></tr></table></div></figure>


<p>As you can see, Cumulus simplifies it even more by allowing you to only specify the BGP peering type (external/internal) and learning the value of peer BGP AS dynamically from a neighbor.</p>

<h2>Design assumptions and caveats</h2>

<p>With all the above in mind, this is the list of decisions I&rsquo;ve made while building the fabric configuration:</p>

<ul>
<li>All switches inside the fabric will be running BGP peerings using <strong>IPv6 link-local</strong> addresses</li>
<li><strong>eBGP</strong> will be used throughout to simplify configuration automation (all peers will be external)</li>
<li>Each Leaf/Spine switch will have a <strong>unique IPv4 loopback</strong> address assigned for management purposes (ICMP, SSH)</li>
<li>On each Leaf switch <strong>all directly connected IPv4</strong> prefixes will get redistributed into BGP</li>
<li>BGP multipath rule will be &ldquo;relaxed&rdquo; to allow for different AS-PATHs. This is not used in our current topology but is required in an HA Leaf switch design (same IPv4 prefix will be advertised from two Leaf switches with different ASN)</li>
<li>Loop prevention on Leaf switches will also be &ldquo;relaxed&rdquo;. This, again, is not used in our single &ldquo;cluster&rdquo; topology, however it will allow same Leaf ASNs to be reused in a different cluster.</li>
</ul>


<h2>Implementation steps</h2>

<p>Picking up where we left off after the OpenStack node provisioning described in the <a href="http://networkop.github.io/blog/2016/08/26/os-lab-p1/">previous post</a></p>

<ol>
<li><p>Get the latest <a href="https://github.com/networkop/chef-unl-os">OpenStack lab cookbooks</a></p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    git clone <a href="https://github.com/networkop/chef-unl-os.git">https://github.com/networkop/chef-unl-os.git</a>
</span><span class='line'>    <span class="nb">cd </span>chef-unl-os
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p><a href="https://cumulusnetworks.com/cumulus-vx/">Download</a> and import Cumulus VX image similar to how it&rsquo;s described <a href="http://www.unetlab.com/2015/06/adding-cisco-asav-images/">here</a>.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    /opt/unetlab/addons/qemu/cumulus-vx/hda.qcow2
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Build the topology inside UNL. Make sure that Node IDs inside UNL match the ones in <strong>chef-unl-os/environment/lab.rb</strong> file and that interfaces are connected as shown in the diagram below</p>

<p> <img class="center" src="http://networkop.github.io/images/os-lab-unl.png"></p></li>
<li><p>Re-run UNL self-provisioning cookbook to create a <a href="https://github.com/networkop/chef-unl-os/blob/master/cookbooks/pxe/templates/ztp.erb">zero touch provisioning</a> file and update DHCP server configuration with static entries for the switches.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    chef-client -z -E lab -o pxe
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  Cumulus <a href="https://docs.cumulusnetworks.com/display/DOCS/Zero+Touch+Provisioning+-+ZTP">ZTP</a> allows you to run a predefined script on the first boot of the operating system. In our case we inject a UNL VM&rsquo;s public key and enable passwordless <strong>sudo</strong> for cumulus user.</p></li>
<li><p>Kickoff Chef provisioning to bootstrap and configure the DC fabric.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    chef-client -z -E lab fabric.rb
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  This command instructs Chef provisioning to connect to each switch, download and install the Chef client and run a simple recipe to create quagga configuration file from a template.</p></li>
</ol>


<p>At the end of step 5 we should have a fully functional BGP-only fabric and all 3 compute nodes should be able to reach each other in at most 4 hops.</p>

<figure class='code'><figcaption><span>[root@controller-1 ~]# traceroute 10.0.0.4</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>traceroute to 10.0.0.4 <span class="o">(</span>10.0.0.4<span class="o">)</span>, <span class="m">30</span> hops max, <span class="m">60</span> byte packets
</span><span class='line'> <span class="m">1</span>  10.0.0.1 <span class="o">(</span>10.0.0.1<span class="o">)</span>  0.609 ms  0.589 ms  0.836 ms
</span><span class='line'> <span class="m">2</span>  10.255.255.7 <span class="o">(</span>10.255.255.7<span class="o">)</span>  0.875 ms  2.957 ms  3.083 ms
</span><span class='line'> <span class="m">3</span>  10.255.255.6 <span class="o">(</span>10.255.255.6<span class="o">)</span>  3.473 ms  5.486 ms  3.147 ms
</span><span class='line'> <span class="m">4</span>  10.0.0.4 <span class="o">(</span>10.0.0.4<span class="o">)</span>  4.231 ms  4.159 ms  4.115 ms
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automating the Build of OpenStack Lab (Part 1)]]></title>
    <link href="http://networkop.github.io/blog/2016/08/26/os-lab-p1/"/>
    <updated>2016-08-26T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/08/26/os-lab-p1</id>
    <content type="html"><![CDATA[<p>In this post we will explore what&rsquo;s required to perform a zero-touch deployment of an OpenStack cloud. We&rsquo;ll get a 3-node lab up and running inside UNetLab with just a few commands.</p>

<!--more-->


<hr />

<p>Now that I&rsquo;m finally beginning to settle down at my new place of residence I can start spending more time on research and blogging. I have left off right before I was about to start exploring the native OpenStack distributed virtual routing function. However as I&rsquo;d started rebuilding my OpenStack lab from scratch I realised that I was doing a lot of repetitive tasks which can be easily automated. Couple that with the fact that I needed to learn Chef for my new work and you&rsquo;ve got this blogpost describing a few Chef <a href="https://github.com/networkop/chef-unl-os.git">cookbooks</a> (similar to Ansible&rsquo;s playbook) automating all those manual steps described in my earlier blogposts <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">1</a> and <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">2</a>.<br/>
In addition to that in this post I&rsquo;ll show how to build a very simple OpenStack baremetal provisioner and installer. Some examples of production-grade baremetal provisioners are <a href="https://wiki.openstack.org/wiki/Ironic">Ironic</a>, <a href="http://crowbar.github.io/">Crowbar</a> and <a href="http://maas.io/">MAAS</a>. In our case we&rsquo;ll turn UNetLab VM into an <strong>undercloud</strong>, a server used to provision and deploy our OpenStack lab, an <strong>overcloud</strong>. To do that we&rsquo;ll first install and configure DHCP, TFTP and Apache servers to PXE-boot our UNL OpenStack nodes. Once all the nodes are bootstrapped, we&rsquo;ll use Chef to configure the server networking and kickoff the packstack OpenStack installer.</p>

<p><img class="center" src="http://networkop.github.io/images/os-lab-chef.png"></p>

<p>In this post I&rsquo;ll try to use Chef recipes that I&rsquo;ve written as much as possible, therefore you won&rsquo;t see the actual configuration commands, e.g. how to configure Apache or DHCP servers. However I will try to describe everything that happens at each step and hopefully that will provide enough incentive for the curious to look into the Chef code and see how it&rsquo;s done. To help with the Chef code understanding let me start with a brief overview of what to look for in a cookbook.</p>

<h2>How to read a Chef cookbook (Optional)</h2>

<p>A cookbook directory (<strong>/cookbooks/[cookbook_name]</strong>) contains all its configuration scripts in <strong>/recipes</strong>. Each file inside a recipe contains a list of steps to be performed on a server. Each step is an operation (add/delete/update) on a <strong>resource</strong>. Here are some of the common Chef resources:</p>

<ul>
<li>Package - allows you to add, remove or update a package</li>
<li>Template - creates a file from an <strong>erb</strong>-formatted template</li>
<li>Execute - runs an ad-hoc CLI command</li>
</ul>


<p>Just these three basic resources allow you to do 95% of administrative tasks on any server. Most importantly they do it in platform-independent (any flavour of Linux) and idempotent (only make changes if current state is different from a desired state) way. Other directories you might want to explore are:</p>

<ul>
<li>/templates - contains all the <strong>erb</strong>-formatted templates</li>
<li>/attributes - contains recipe variables (file paths, urls etc.)</li>
<li>/files - contains the non-template files, i.e. files with static content</li>
</ul>


<h2>Bootstrapping the OpenStack nodes</h2>

<ol>
<li><p>If you haven&rsquo;t done it yet, download a copy of the <strong>UNetLab VM</strong> from the <a href="http://www.unetlab.com/">official website</a>. Set it up inside your hypervisor so that you can access Internet through the first interface <strong>pnet0</strong> (i.e. connect the first NIC of the VM to hypervisor&rsquo;s NAT interface). Make sure the VM has got at least 6GB of RAM and VT-x support enabled for nested virtualization.</p></li>
<li><p>Follow the official <a href="https://downloads.chef.io/chef-dk/">installation instructions</a> to <strong>install Chef Development Kit</strong> inside UNetLab VM.</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   wget <a href="https://packages.chef.io/stable/ubuntu/12.04/chefdk_0.16.28-1_amd64.deb">https://packages.chef.io/stable/ubuntu/12.04/chefdk_0.16.28-1_amd64.deb</a>
</span><span class='line'>   dpkg -i chefdk_0.16.28-1_amd64.deb
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p><strong>Install git</strong> and clone <a href="https://github.com/networkop/chef-unl-os.git">chef cookbooks</a>.</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   apt-get -y update
</span><span class='line'>   apt-get -y install git
</span><span class='line'>   git clone <a href="https://github.com/networkop/chef-unl-os.git">https://github.com/networkop/chef-unl-os.git</a>
</span><span class='line'>   <span class="nb">cd </span>chef-unl-os
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Examine the lab <strong>environment settings</strong> to see what values are going to be used. You can modify that file to your liking.</p>

<blockquote><p>Note that the OpenStack node IDs (keys of <em>os_lab</em> hash) MUST have one to one correspondence with the UNL node IDs which will be created at step 5</p></blockquote>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   cat environment/lab.rb
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Run Chef against a local server to setup the <strong>baremetal provisioner</strong>. This step installs and configures DHCP, TFTP and Apache servers. It also creates all the necessary PXE-boot and kickstart files based on our environment settings. Note that a part of the process is the download of a 700MB CentOS image so it might take a while to complete.</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   chef-client -z -E lab -o pxe
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p> At the start of the PXE-boot process, DCHP server sends an OFFER which, along with the standard IP information, includes the name of the PXE boot image and the IP address of TFTP server where to get it from. A server loads this image and then searches the TFTP server for the boot configuration file which tells it what kernel to load and where to get a kickstart file. Both kickstart and the actual installation files are accessed via HTTP and served by the same Apache server that runs UNL GUI.</p></li>
<li><p>From <strong>UNL GUI</strong> create a new lab, add 3 OpenStack nodes and connect them all to <strong>pnet10</strong> interface as described in <a href="http://www.unetlab.com/2014/11/using-cloud-devices/">this guide</a>. Note that the <strong>pnet10</strong> interface has already been created by Chef so you don&rsquo;t have to re-create it again.</p>

<blockquote><p>Make sure that the UNL node IDs match the ones defined in the environment setting file</p></blockquote></li>
<li><p>Fire-up the nodes and watch them being bootstrapped by our UNL VM.</p></li>
</ol>


<h2>Server provisioning</h2>

<p>Next step is to configure the server networking and kickoff the OpenStack installer. These steps will also be done with a single command:</p>

<p>   <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   chef-client -z -E lab lab.rb
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>
The first part of this script will connect to each prospective OpenStack node and setup its network interfaces and hostnames. The second part of this script will generate a packstack answer file and modify its settings to exclude some of the components we&rsquo;re not going to use (like Nagios, Ceph and Ceilometer). Have a look at <strong>cookbooks/packstack/recipe/default.rb</strong> for the list of modifications. The final step is a command to kickoff the packstack installer which will use another configuration management system, Puppet, to install and configure OpenStack according to the provided answer file.</p>

<p>At the end of these steps you should have a fully functional 3-node OpenStack environment.</p>

<h2>To be continued&hellip;</h2>

<p>This is a part of a 2-post series. In the next post we&rsquo;ll look into how to use the same tools to perform the baremetal provisioning of our physical underlay network.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenStack SDN - Interconnecting VMs and Physical Devices With Cumulus VX L2 Gateway]]></title>
    <link href="http://networkop.github.io/blog/2016/05/21/neutron-l2gw/"/>
    <updated>2016-05-21T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/05/21/neutron-l2gw</id>
    <content type="html"><![CDATA[<p>One of the basic function of any data centre network is the ability to communicate with baremetal servers. In this post we&rsquo;ll see how Neutron L2 Gateway plugin can be used to configure a Cumulus VX switch for VXLAN-VLAN bridging.</p>

<!--more-->


<p>Since I have all my OpenStack environment running inside UNetLab, it makes it really easy for me to extend my L3 fabric with a switch from another vendor. In my previous posts I&rsquo;ve used <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">Cisco</a> and <a href="http://networkop.github.io/blog/2016/05/11/neutron-routed-extnet/">Arista</a> switches to build a 4-leaf 2-spine CLOS fabric. For this task I&rsquo;ve decided to use a Cumulus VX switch which I&rsquo;ve <a href="https://cumulusnetworks.com/cumulus-vx/">downloaded</a> and imported into my lab.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-l2gw-overview.png"></p>

<p>To simulate the baremetal server (10.0.0.100) I&rsquo;ve VRF&rsquo;d an interface on Arista &ldquo;L4&rdquo; switch and connected it directly to a &ldquo;swp3&rdquo; interface of the Cumulus VX. This is not shown on the diagram.</p>

<h2>Solution overview</h2>

<p><a href="https://wiki.openstack.org/wiki/Neutron/L2-GW">L2 Gateway</a> is a relatively <a href="https://github.com/openstack/networking-l2gw/releases">new</a> service plugin for OpenStack Neutron.  It provides the ability to interconnect a given tenant network with a VLAN on a physical switch. There are three main components that compose this solution:</p>

<ul>
<li><strong>Hardware switch</strong> implementing the OVSDB hardware vtep schema. This is a special &ldquo;flavour&rdquo; of OVSDB designed specifically to enable connectivity between logical (VXLAN VTEP) and physical (switchport) interfaces.</li>
<li><strong>L2GW agent</strong> running on a network node. This is the process responsible for connecting to OVSDB server running on a hardware switch and updating that database based on instructions received from a L2GW service plugin.</li>
<li><strong>L2GW Service Plugin</strong> residing on a control node. The task of this plugin is to notify the L2GW agent and normal L2 OVS agents running on compute hosts about network events and distribute VTEP IP address information between them.</li>
</ul>


<p>Note that in our case both network and control nodes are running on the same VM.</p>

<h2>Cumulux VX configuration</h2>

<p>Cumulux is a debian-based linux distribution, therefore most of the basic networking configuration will be similar to how things are done in Ubuntu. First, let&rsquo;s start by configuring basic IP addressing on Loopback (VTEP IP), Eth0 (OOB management), swp1 and swp2 (fabric) interfaces.</p>

<figure class='code'><figcaption><span>/etc/network/interfaces</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>iface lo inet loopback
</span><span class='line'>        address 10.0.0.5/32
</span><span class='line'>
</span><span class='line'>auto eth0
</span><span class='line'>iface eth0 inet static
</span><span class='line'>        address 192.168.91.21/24
</span><span class='line'>
</span><span class='line'>auto swp1
</span><span class='line'>iface swp1 inet static
</span><span class='line'>        address 169.254.51.5/24
</span><span class='line'>
</span><span class='line'>auto swp2
</span><span class='line'>iface swp2 inet static
</span><span class='line'>        address 169.254.52.5/24
</span><span class='line'>
</span><span class='line'>auto swp3
</span><span class='line'>iface swp3
</span></code></pre></td></tr></table></div></figure>


<p>Next, let&rsquo;s enable OSPF</p>

<figure class='code'><figcaption><span>Enable OSPF process</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo sed -i s/zebra<span class="o">=</span>no/zebra<span class="o">=</span>yes/ /etc/quagga/daemons
</span><span class='line'>sudo sed -i s/ospfd<span class="o">=</span>no/ospfd<span class="o">=</span>yes/ /etc/quagga/daemons
</span><span class='line'>sudo service quagga restart
</span></code></pre></td></tr></table></div></figure>


<p>Once OSPFd is running, we can use <code>sudo vtysh</code> to connect to local quagga shell and finalise the configuration.</p>

<figure class='code'><figcaption><span>show run</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>interface lo
</span><span class='line'> ip ospf area 0.0.0.0
</span><span class='line'> link-detect
</span><span class='line'>!
</span><span class='line'>interface swp1
</span><span class='line'> ip ospf area 0.0.0.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> link-detect
</span><span class='line'>!
</span><span class='line'>interface swp2
</span><span class='line'> ip ospf area 0.0.0.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> link-detect
</span><span class='line'>!
</span><span class='line'>router ospf
</span><span class='line'> ospf router-id 10.0.0.5
</span><span class='line'> passive-interface default
</span><span class='line'> no passive-interface swp1
</span><span class='line'> no passive-interface swp2
</span></code></pre></td></tr></table></div></figure>


<p>At this stage our Cumulus VX switch should be fully adjacent to both spines and its loopback IP (10.0.0.5) should be reachable from all OpenStack nodes.</p>

<p>The final step is to enable the hardware VTEP functionality. The <a href="https://docs.cumulusnetworks.com/display/CL22/Integrating+Hardware+VTEPs+with+Midokura+MidoNet+and+OpenStack">process</a> is fairly simple and involves only a few commands.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sudo sed -i s/START<span class="o">=</span>no/START<span class="o">=</span>yes/g /etc/default/openvswitch-vtep
</span><span class='line'><span class="nv">$ </span>sudo service openvswitch-vtep start
</span><span class='line'><span class="nv">$ </span>sudo vtep-bootstrap L5 10.0.0.5 192.168.91.21 --no_encryption
</span></code></pre></td></tr></table></div></figure>


<p>The last command runs a bootstrap script that does the following things:</p>

<ul>
<li>Creates a hardware VTEP OVSDB schema</li>
<li>Inside that schema creates a new physical switch called &ldquo;L5&rdquo;</li>
<li>Sets the VTEP IP to 10.0.0.5</li>
<li>Starts listening to incoming OVSDB connections on 192.168.91.21</li>
</ul>


<h2>Hardware VTEP vs OpenvSwitch OVSDB schemas (Optional)</h2>

<p>By now you&rsquo;re probably wondering what&rsquo;s that hardware VTEP OVSDB schema and how it&rsquo;s different from a normal OVS schema. First of all, remember that <a href="https://tools.ietf.org/html/rfc7047">OVSDB</a> is just a database and OVSDB protocol is just a set of JSON RPC calls to work with that database. Information that can be stored in the database is defined by a schema - a structure that represents tables and their relations. Therefore, OVSDB can be used to store and manage <a href="https://twitter.com/ben_pfaff/status/453333818653417472">ANY</a> type of data which makes it very flexible. Specificallly OVS project defines two OVSDB schemas:</p>

<ul>
<li><strong><a href="http://openvswitch.org/ovs-vswitchd.conf.db.5.pdf">Open_vSwitch schema</a></strong> - used to manage bridges, ports and controllers of OpenvSwitch. This schema is used by OVS inside every compute host we have in our OpenStack environment.</li>
<li><strong><a href="http://openvswitch.org/docs/vtep.5.pdf">Hardware_vtep schema</a></strong> - designed to be used by physical switches. The goal of this schema is to extend the virtual L2 switch into a physical realm by providing the ability to map physical ports to logical networks. For each logical network the hardware VTEP database holds mappings of MAC addresses to VTEPs and physical switchport.</li>
</ul>


<p>The information from these databases is later consumed by another process that sets up the actual bridges and ports. The first schema is used by the <strong>ovs-vswitchd</strong> process running on all compute hosts to configure ports and flows of integration and tunnel bridges. In case of a Cumulus switch, the information from <strong>hardware_vtep</strong> OVSDB is used by a process called <strong>ovs-vtepd</strong> that is responsible for settings up VXLAN VTEP interfaces, provisioning of VLANs on physical switchports and interconnecting them with a Linux bridge.</p>

<p>If you want to learn more, check out this <a href="http://www.relaxdiego.com/2014/09/hardware_vtep.html">awesome post</a> about hardware VTEP and OVS.</p>

<h2>OpenStack Control node configuration</h2>

<p>Most of the following procedure has been borrowed from <a href="http://kimizhang.com/neutron-l2-gateway-hp-5930-switch-ovsdb-integration/">another blog</a>. It&rsquo;s included it this post because I had to do some modifications and also for the sake of completeness.</p>

<ol>
<li><p>Clone the L2GW repository</p>

<pre><code class="`"> git clone -b stable/mitaka https://github.com/openstack/networking-l2gw.git
</code></pre></li>
<li><p>Use pip to install the plugin</p>

<pre><code class="`"> pip install ./networking-l2gw/
</code></pre></li>
<li><p>Enable the L2GW service plugin</p>

<pre><code class="`"> sudo sed -ri 's/^(service_plugins.*)/\1,networking_l2gw.services.l2gateway.plugin.L2GatewayPlugin/' \
 /etc/neutron/neutron.conf
</code></pre></li>
<li><p>Copy L2GW configuration files into the neutron configuration directory</p>

<pre><code class="`"> cp  /usr/etc/neutron/l2g* /etc/neutron/
</code></pre></li>
<li><p>Point the L2GW plugin to our Cumulus VX switch</p>

<pre><code class="`"> sudo sed -ri "s/^#\s+(ovsdb_hosts).*/\1 = 'ovsdb1:192.168.91.21:6632'/" /etc/neutron/l2gateway_agent.ini
</code></pre></li>
<li><p>Update Neutron database with the new schema required by L2GW plugin</p>

<pre><code class="`"> systemctl stop neutron-server
 neutron-db-manage --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/l2gw_plugin.ini  upgrade head
 systemctl start neutron-server
</code></pre></li>
<li><p>Update Neutron startup script to load the L2GW plugin configuration file</p>

<pre><code class="`"> sed -ri "s/(ExecStart=.*)/\1 --config-file \/etc\/neutron\/l2gw_plugin.ini /" /usr/lib/systemd/system/neutron-server.service
</code></pre></li>
<li><p>Create a L2GW systemd unit file</p>

<pre><code class="`"> cat &gt;&gt; /usr/lib/systemd/system/neutron-l2gateway-agent.service &lt;&lt; EOF
 [Unit]
 Description=OpenStack Neutron L2 Gateway Agent
 After=neutron-server.service

 [Service]
 Type=simple
 User=neutron
 ExecStart=/usr/bin/neutron-l2gateway-agent --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/l2gateway_agent.ini
 KillMode=process

 [Install]
 WantedBy=multi-user.target
 EOF
</code></pre></li>
<li><p>Restart both L2GW and neutron server</p>

<pre><code class="`"> systemctl daemon-reload
 systemctl restart neutron-server.service
 systemctl start neutron-l2gateway-agent.service  
</code></pre></li>
<li><p>Enter the &ldquo;neutron configuration mode&rdquo;</p>

<pre><code>source ~/keystone_admin
neutron
</code></pre></li>
<li><p>Create a new L2 gateway device</p>

<pre><code>l2-gateway-create --device name="L5",interface_names="swp3" CUMULUS-L2GW
</code></pre></li>
<li><p>Create a connection between a &ldquo;private_network&rdquo; and a native vlan (dot1q 0) of swp3 interface</p>

<pre><code>l2-gateway-connection-create --default-segmentation-id 0 CUMULUS-L2GW private_network
</code></pre></li>
</ol>


<h2>Verification and Traffic Flows</h2>

<p>At this stage everything should be ready for testing. We&rsquo;ll start by examining the following traffic flow:</p>

<ul>
<li>From VM-2 10.0.0.4/fa:16:3e:d7:0e:14</li>
<li>To baremetal server 10.0.0.100/50:00:00:6b:2e:70</li>
</ul>


<p><img class="center" src="http://networkop.github.io/images/neutron-l2gw-detailed.png"></p>

<p>The communication starts with VM-2 sending an ARP request for the MAC address of the baremetal server. Packet flow inside the compute host will be exactly the same <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">as before</a>, with packet being flooded from the VM to the integration and tunnel bridges. Inside the tunnel bridge the packet gets resubmitted to table 22 where head-end replication of ARP request takes place.</p>

<p>The only exception is that this time the frame will get replicated to a new VXLAN port pointing towards the Cumulux VTEP IP. We&rsquo;ll use the <code>ovs-appctl ofproto/trace</code> command to see the full path a packet takes inside OVS, which is similar to <code>packet-tracer</code> command of Cisco ASA. To simulate an ARP packet we need to specify the incoming port(in_port), EtherType(arp), internal VLAN number for our tenant(dl_vlan) and an ARP request target IP address(arp_tpa). You can find the full list of fields that can be matched in <a href="http://openvswitch.org/support/dist-docs/ovs-ofctl.8.txt">this document</a>.</p>

<figure class='code'><figcaption><span>ARP request to the baremetal server</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-appctl ofproto/trace br-tun <span class="nv">in_port</span><span class="o">=</span>1,arp,dl_vlan<span class="o">=</span>1,arp_tpa<span class="o">=</span>10.0.0.100 <span class="p">|</span> grep -E <span class="s2">&quot;Rule|actions=&quot;</span>
</span><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>1
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">2</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">20</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">priority</span><span class="o">=</span>0
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,22<span class="o">)</span>
</span><span class='line'>                        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">22</span> <span class="nv">cookie</span><span class="o">=</span>0xb3c018296c2aa8a3 <span class="nv">dl_vlan</span><span class="o">=</span>1
</span><span class='line'>                        OpenFlow <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x45,output:9,output:4,output:6
</span></code></pre></td></tr></table></div></figure>


<p>The packet leaving port 9 will get encapsulated into a VXLAN header with destination IP of 10.0.0.5 and forwarded out the fabric-facing interface eth1.100. When VXLAN packet reaches the <strong>vxln69</strong> interface (10.0.0.5) of the Cumulus switch, the <strong>br-vxlan69</strong> Linux bridge floods the frame out the second connected interface - <strong>swp3</strong>.</p>

<figure class='code'><figcaption><span>brctl show br-vxln69</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>bridge name        bridge id          STP enabled     interfaces
</span><span class='line'>br-vxln69          8000.500000070003  no              swp3
</span><span class='line'>                                                      vxln69
</span></code></pre></td></tr></table></div></figure>


<p>The rest of the story is very simple. When ARP packet hits the baremetal server it populates its ARP cache. A unicast response travels all the way back to the Cumulus switch, gets matched by the static MAC (0e:14) entry created based on information provided by the L2GW plugin. This entry points to the VTEP IP of Compute host 2(10.0.2.10) which is where it gets forwarded next.</p>

<figure class='code'><figcaption><span>bridge fdb show</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>50:00:00:09:00:04 dev swp3 vlan <span class="m">0</span> master br-vxln69
</span><span class='line'>50:00:00:07:00:03 dev swp3 vlan <span class="m">0</span> master br-vxln69 permanent
</span><span class='line'>50:00:00:6b:2e:70 dev swp3 vlan <span class="m">0</span> master br-vxln69
</span><span class='line'>26:21:90:a8:8a:cc dev vxln69 vlan <span class="m">0</span> master br-vxln69 permanent
</span><span class='line'>fa:16:3e:57:1c:6c dev vxln69 dst 10.0.3.10 vlan <span class="m">65535</span> self permanent
</span><span class='line'>fa:16:3e:a4:12:e6 dev vxln69 dst 10.0.3.10 vlan <span class="m">65535</span> self permanent
</span><span class='line'>fa:16:3e:d7:0e:14 dev vxln69 dst 10.0.2.10 vlan <span class="m">65535</span> self permanent
</span><span class='line'>fa:16:3e:3c:51:d7 dev vxln69 dst 10.0.1.10 vlan <span class="m">65535</span> self permanent
</span></code></pre></td></tr></table></div></figure>


<p>The packet travels through compute host 2, populating the flow entries of all OVS bridges along the way. These entries are then used by subsequent unicast packets travelling from VM-2.</p>

<figure class='code'><figcaption><span>Unicast packet to the baremetal server</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-appctl ofproto/trace br-tun <span class="nv">in_port</span><span class="o">=</span>1,dl_vlan<span class="o">=</span>1,dl_dst<span class="o">=</span>50:00:00:6b:2e:70 <span class="p">|</span> grep -E <span class="s2">&quot;Rule|actions=&quot;</span>
</span><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xb5625033061a8ae5 <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>1
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">2</span> <span class="nv">cookie</span><span class="o">=</span>0xb5625033061a8ae5 <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">20</span> <span class="nv">cookie</span><span class="o">=</span>0xb5625033061a8ae5 <span class="nv">priority</span><span class="o">=</span>1,vlan_tci<span class="o">=</span>0x0001/0x0fff,dl_dst<span class="o">=</span>50:00:00:6b:2e:70
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:0x45-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:9
</span></code></pre></td></tr></table></div></figure>


<p>It all looks fine until the ARP cache of the baremetal server expires and you get an ARP request coming from the physical into the virtual world. There is a <a href="https://drive.google.com/file/d/0Bx8nDIFktlzBRm0tV3pmYURnZ3M/view">known issue</a> with BUM forwarding which requires a special <a href="http://blog.scottlowe.org/2014/02/27/learning-nsx-part-10-adding-a-service-node/">service node</a> to perform the head-end replication. The idea is that a switch that needs to flood a multicast packet, would send it to a service node which keeps track of all active VTEPs in the network and performs packet replication on behalf of the sender. OpenStack doesn&rsquo;t have a dedicated service node, however it is possible to trick the network node into performing a similar functionality, which is what I&rsquo;m going to demonstrate next.</p>

<h2>Programming Network Node as BUM replication service node</h2>

<p>First of all, we need to tell our Cumulus switch to send all multicast packets to the network node. To do that we need to modify OVSDB table called &ldquo;Mcast_Macs_Remote&rdquo;. You can view the contents of the database using the <code>ovsdb-client dump --pretty tcp:192.168.91.21:6632</code> command to make sure that this table is empty. Using the VTEP control command we need to force all <strong>unknown-dst</strong> (BUM) traffic to go to the network node(10.0.3.10). The UUID of the logical switch can be found with <code>sudo vtep-ctl list-ls</code> command.</p>

<figure class='code'><figcaption><span>Forward all BUM traffic to OpenStack network node</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo vtep-ctl add-mcast-remote 818b4779-645c-49bb-ae4a-aa9340604019 unknown-dst 10.0.3.10
</span></code></pre></td></tr></table></div></figure>


<p>At this stage all BUM traffic hits the network node and gets flooded to the DHCP and the virtual router namespaces. In order to force this traffic to also be replicated to all compute nodes we can use some of the existing tables of the tunnel bridge. Before we do anything let&rsquo;s have a look at the tables our ARP request has to go through inside the tunnel bridge.</p>

<figure class='code'><figcaption><span>Packet from Cumulus VTEP inside br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">2</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,4<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>4, <span class="nv">priority</span><span class="o">=</span>1,tun_id<span class="o">=</span>0x45 <span class="nv">actions</span><span class="o">=</span>mod_vlan_vid:1,resubmit<span class="o">(</span>,10<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>10,priority<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,cookie<span class="o">=</span>0x9f3e746b7ee48bbf,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:NXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span></code></pre></td></tr></table></div></figure>


<p>We also have a default head-end replication table 22 which floods all BUM traffic received from the integration bridge to all VTEPs:</p>

<figure class='code'><figcaption><span>BUM replication table</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>22, <span class="nv">dl_vlan</span><span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x45,output:2,output:4,output:6
</span></code></pre></td></tr></table></div></figure>


<p>So what we can do is create a new flow entry that would intercept all ARP packets inside Table 4 and resubmit them to tables 10 and 22. Table 10 will take our packet up to the integration bridge of the network node, since we still need to be able to talk the virtual router and the DHCP. Table 22 will receive a copy of the packet and flood it to all known VXLAN endpoints.</p>

<figure class='code'><figcaption><span>Manipulating OVS flows</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ovs-ofctl add-flow br-tun <span class="s2">&quot;table=4,arp,tun_id=0x45,priority=2,actions=mod_vlan_vid:1,resubmit(,10),resubmit(,22)&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can once again use the trace command to see the ARP request flow inside the tunnel bridge.</p>

<figure class='code'><figcaption><span>ARP request received from the Cumulus switch</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-appctl ofproto/trace br-tun <span class="nv">in_port</span><span class="o">=</span>2,arp,tun_id<span class="o">=</span>0x45 <span class="p">|</span> grep -E <span class="s2">&quot;Rule|actions=&quot;</span>
</span><span class='line'>Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0x9f3e746b7ee48bbf <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span>2
</span><span class='line'>OpenFlow <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,4<span class="o">)</span>
</span><span class='line'>        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">4</span> <span class="nv">cookie</span><span class="o">=</span><span class="m">0</span> <span class="nv">priority</span><span class="o">=</span>2,arp,tun_id<span class="o">=</span>0x45
</span><span class='line'>        OpenFlow <span class="nv">actions</span><span class="o">=</span>mod_vlan_vid:1,resubmit<span class="o">(</span>,10<span class="o">)</span>,resubmit<span class="o">(</span>,22<span class="o">)</span>
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">10</span> <span class="nv">cookie</span><span class="o">=</span>0x9f3e746b7ee48bbf <span class="nv">priority</span><span class="o">=</span>1
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,cookie<span class="o">=</span>0x9f3e746b7ee48bbf,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:NXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span><span class='line'>                        Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0x91b1a9a9b6e8d608 <span class="nv">priority</span><span class="o">=</span>0
</span><span class='line'>                        OpenFlow <span class="nv">actions</span><span class="o">=</span>NORMAL
</span><span class='line'>                                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">0</span> <span class="nv">cookie</span><span class="o">=</span>0xb36f6e358a37bea6 <span class="nv">priority</span><span class="o">=</span>2,in_port<span class="o">=</span>2
</span><span class='line'>                                OpenFlow <span class="nv">actions</span><span class="o">=</span>drop
</span><span class='line'>                Rule: <span class="nv">table</span><span class="o">=</span><span class="m">22</span> <span class="nv">cookie</span><span class="o">=</span>0x9f3e746b7ee48bbf <span class="nv">dl_vlan</span><span class="o">=</span>1
</span><span class='line'>                OpenFlow <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x45,output:2,output:4,output:6
</span></code></pre></td></tr></table></div></figure>


<p><img class="center" src="http://networkop.github.io/images/neutron-l2gw-arp.png"></p>

<p>Now we should be able to clear the ARP cache on baremetal device and successfully ping both VM-2, VM-1 and the virtual router.</p>

<h2>Conclusion</h2>

<p>The workaround presented above is just a temporary solution for the problem. In order to fix the problem properly, OVS vtep schema needs to be updated to support source node replication. Luckily, the patch implementing this functionality has been <a href="https://github.com/openvswitch/ovs/commit/b351ac0c9bc270b3fff07ae8c7434c53d59b132c">merged</a> into master OVS branch only a few days ago. So hopefully, this update trickles down to Cumulus package repositories soon.</p>

<p>Despite all the issues, Neutron L2 gateway plugin is a cool project that provides a very important piece of functionality without having to rely on 3rd party SDN controllers. Let&rsquo;s hope it will continue to be supported and developed by the community.</p>

<h2>Coming up</h2>

<p>In the next post I was planning to examine another &ldquo;must have&rdquo; feature of any SDN solution - Distributed Virtual Routing. However due to my current circumstances I may need to take a few weeks' break before going on. Be back soon!</p>

<p><img class="center" src="http://networkop.github.io/images/be-back.jpg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack SDN - Extending a L2 Provider Network Over a L3 Fabric]]></title>
    <link href="http://networkop.github.io/blog/2016/05/11/neutron-routed-extnet/"/>
    <updated>2016-05-11T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/05/11/neutron-routed-extnet</id>
    <content type="html"><![CDATA[<p>In the this post we&rsquo;ll tackle yet another Neutron scalability problem identified in my <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">earlier post</a> - a requirement to have a direct L2 adjacency between the external provider network and the network node.</p>

<!--more-->


<h2>Provider vs Tenant networks</h2>

<p>Before we start, let&rsquo;s recap the difference between the <a href="http://docs.openstack.org/mitaka/networking-guide/intro-os-networking-overview.html">two major</a> Neutron network types:</p>

<ul>
<li>Tenant networks are:

<ul>
<li>provisioned by tenants</li>
<li>used for inter-VM (east-west) communication</li>
<li>use Neutron virtual router as their default gateway</li>
</ul>
</li>
<li>Provider networks are:

<ul>
<li>provisioned by OpenStack administrator(for use by tenants)</li>
<li>match existing physical networks</li>
<li>can be either flat (untagged VLAN) or VLAN-based (multiple VLANs)</li>
<li>need to be L2 adjacent to network and/or compute nodes</li>
</ul>
</li>
</ul>


<p>These two network types are not mutually exclusive. In our case the <strong>admin tenant</strong> network is implemented as a VXLAN-based overlay whose only requirement is to have a layer-3 reachability in the underlay. However tenant network could also have been implemented using a VLAN-based provider network in which case a set of dot1Q tags pre-provisioned in the underlay would have been used for tenant network segregation.</p>

<h2>External provider network</h2>

<p>External network is used by VMs to communicate with the outside world (north-south). Since default gateway is located outside of OpenStack environment this, by definition, is a provider network. Normally, tenant networks will use the non-routable address space and will rely on a Neutron virtual router to perform some form of NAT translation. As we&rsquo;ve seen in the <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">earlier post</a>, Neutron virtual router is directly connected to the external bridge which allows it to &ldquo;borrow&rdquo; ip address from the external provider network to use for two types of NAT operations:</p>

<ul>
<li>SNAT - a source-based port address translation performed by the Neutron virtual router</li>
<li>DNAT - a static NAT created for every <a href="https://www.rdoproject.org/networking/difference-between-floating-ip-and-private-ip/">floating ip address</a> configured for a VM</li>
</ul>


<p>In default deployments all NATing functionality is performed by a network node, so external provider network only needs to be L2 adjacent with a limited number of physical hosts. In deployments where <abbr title=" Distributed Virtual Router">DVR</abbr> is used, the virtual router and NAT functionality gets distributed among all compute hosts which means that they, too, now need to be layer-2 adjacent to the external network.</p>

<h2>Solutions overview</h2>

<p>The direct adjacency requirement presents a big problem for deployments where layer-3 routed underlay is used for the tenant networks. There is a limited number of ways to satisfy this requirements, for example:</p>

<ul>
<li>Span a L2 segment across the whole DC fabric. This means that the fabric needs to be converted to layer-2, reintroducing spanning-tree and all the unique vendor solutions to overcome STP limitations(e.g. TRILL, Fabripath, SPB).</li>
<li>Build a dedicated physical network. This may not always be feasible, especially considering that it needs to be delivered to all compute hosts.</li>
<li>Extend the provider network over an existing L3 fabric with VXLAN overlay. This can easily be implemented with just a few commands, however it requires a border leaf switch capable of performing VXLAN-VLAN translation.</li>
</ul>


<h2>Detailed design</h2>

<p>As I&rsquo;ve said in my <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">earlier post</a>, I&rsquo;ve built the leaf-spine fabric out of Cisco IOU virtual switches, however the plan was to start introducing other vendors later in the series. So this time for the border leaf role I&rsquo;ve chosen Arista vEOS switch, however, technically, it could have been any other vendor capable of doing VXLAN-VLAN bridging (e.g. any hardware switch with <a href="http://blog.ipspace.net/2014/06/trident-2-chipset-and-nexus-9500.html">Trident 2</a> or similar ASIC).</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-extnet-l3.png"></p>

<h3>Arista vEOS configuration</h3>

<p>Configuration of Arista switches is very similar to Cisco IOS. In fact, I was able to complete all interface and OSPF routing configuration only with the help of CLI context help. The only bit that was new to me and that I had to lookup in the official guide was the <a href="https://eos.arista.com/vxlan-with-mlag-configuration-guide/">VXLAN configuration</a>. These similarities makes the transition from Cisco to Arista very easy and I can understand (but not approve!) why Cisco would file a lawsuit against Arista for copying its &ldquo;industry-standard CLI&rdquo;.</p>

<figure class='code'><figcaption><span>L4 configuration</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>interface Ethernet1
</span><span class='line'>   description SPINE-1:Eth0/3
</span><span class='line'>   no switchport
</span><span class='line'>   ip address 169.254.41.4/24
</span><span class='line'>   ip ospf network point-to-point
</span><span class='line'>!
</span><span class='line'>interface Ethernet2
</span><span class='line'>   description SPINE-2:Eth0/3
</span><span class='line'>   no switchport
</span><span class='line'>   ip address 169.254.42.4/24
</span><span class='line'>   ip ospf network point-to-point
</span><span class='line'>!
</span><span class='line'>interface Ethernet3
</span><span class='line'>   description VM-HOST-ONLY:PNET1
</span><span class='line'>   switchport access vlan 100
</span><span class='line'>   spanning-tree portfast
</span><span class='line'>!
</span><span class='line'>interface Loopback0
</span><span class='line'>   ip address 10.0.0.4/32
</span><span class='line'>!
</span><span class='line'>interface Vxlan1
</span><span class='line'>   vxlan source-interface Loopback0
</span><span class='line'>   vxlan udp-port 4789
</span><span class='line'>   vxlan vlan 100 vni 1000
</span><span class='line'>   vxlan vlan 100 flood vtep 10.0.3.10
</span><span class='line'>!
</span><span class='line'>router ospf 1
</span><span class='line'>   router-id 10.0.0.4
</span><span class='line'>   passive-interface default
</span><span class='line'>   no passive-interface Ethernet1
</span><span class='line'>   no passive-interface Ethernet2
</span><span class='line'>   network 0.0.0.0/0 area 0.0.0.0
</span><span class='line'>!
</span></code></pre></td></tr></table></div></figure>


<p>Interface VXLAN1 sets up VXLAN-VLAN bridging between VNI 1000 and VLAN 100. VLAN 100 is used to connect to VMware Workstation&rsquo;s host-only interface, the one that was <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">previously</a> connected directly to the L3 leaf switch. VXLAN interface does the multicast source replication by flooding unknown packets over the layer 3 fabric to the network node (10.0.3.10).</p>

<h3>OpenStack network node configuration</h3>

<p>Since we don&rsquo;t yet have the distributed routing feature enabled, the only OpenStack component that requires any changes is the network node. First, let&rsquo;s remove the physical interface from the external bridge, since it will no longer be used to connect to the external provider network.</p>

<figure class='code'><figcaption><span>Remove the physical interface from the external bridge</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-vsctl del-port br-ex eth1.300
</span></code></pre></td></tr></table></div></figure>


<p>Next let&rsquo;s add the VXLAN interface towards the Loopback IP address of the Arista border leaf switch. The key option sets the VNI which must be equal to the VNI defined on the border leaf.</p>

<figure class='code'><figcaption><span>add the VXLAN interface towards the Arista switch</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ovs-vsctl add-port br-ex vxlan1 <span class="se">\</span>
</span><span class='line'>-- <span class="nb">set </span>interface vxlan1 <span class="se">\</span>
</span><span class='line'><span class="nb">type</span><span class="o">=</span>vxlan <span class="se">\</span>
</span><span class='line'>options:remote_ip<span class="o">=</span>10.0.0.4 <span class="se">\</span>
</span><span class='line'>options:key<span class="o">=</span>1000
</span></code></pre></td></tr></table></div></figure>


<p>Without any physical interfaces attached to the external bridge, the OVS will use the Linux network stack to find the outgoing interface. When a packet hits the <strong>vxlan1</strong> interface of the br-ex, it will get encapsulated in a VXLAN header and passed on to the OS network stack where it will follow the <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">pre-configured</a> static route forwarding all 10/8 traffic towards the leaf-spine fabric. Check out <a href="http://blog.scottlowe.org/2013/05/15/examining-open-vswitch-traffic-patterns/">this article</a> if you want to learn more about different types of interfaces and traffic forwarding behaviours in OpenvSwitch.</p>

<h3>Cleanup</h3>

<p>In order to make changes persistent and prevent the static interface configuration from interfering with OVS, remove all OVS-related configuration and shutdown interface eth1.300.</p>

<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-eth1.300</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">ONBOOT</span><span class="o">=</span>no
</span><span class='line'><span class="nv">VLAN</span><span class="o">=</span>yes
</span></code></pre></td></tr></table></div></figure>


<h2>Change in the packet flow</h2>

<p>None of the packet flows have changed as the result of this modification. All VMs will still use NAT to break out of the private environment, the NAT&rsquo;d packets will reach the external bridge <strong>br-ex</strong> as described in my <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">earlier post</a>. However this time <strong>br-ex</strong> will forward the packets out the <strong>vxlan1</strong> port which will deliver them to the Arista switch over the same L3 fabric used for east-west communication.</p>

<p>If we did a capture on the fabric-facing interface <strong>eth1</strong> of the control node while running a ping from one of the VMs to the external IP address, we would see a VXLAN-encapsulated packet destined for the Loopback IP of L4 leaf switch.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-provider-vxlan.png"></p>

<h2>Coming Up</h2>

<p>In the next post we&rsquo;ll examine the L2 gateway feature that allows tenant networks to communicate with physical servers through yet another VXLAN-VLAN hardware gateway.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack SDN - L2 Population and ARP Proxy]]></title>
    <link href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/"/>
    <updated>2016-05-06T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/05/06/neutron-l2pop</id>
    <content type="html"><![CDATA[<p>In the <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">previous post</a> we&rsquo;ve had a look at how native OpenStack SDN works and what are some of its limitations. In this post we&rsquo;ll tackle the first one of them - overhead created by multicast source replication.</p>

<!--more-->


<h2>MAC learning in a controller-less VXLAN overlay</h2>

<p>VXLAN <a href="https://tools.ietf.org/html/rfc7348">standard</a> does not specify any control plane protocol to exchange MAC-IP bindings between VTEPs. Instead it relies on data plane flood-and-learn behaviour, just like a normal switch. To force this behaviour in an underlay, the standard stipulates that each VXLAN network should be mapped to its own multicast address and each VTEP participating in a network should join the corresponding multicast group. That multicast group would be used to flood the <abbr title="Broadcast Unknown unicast and Multicast">BUM</abbr> traffic in an underlay to all subscribed VTEPs thereby populating dynamic MAC address tables.</p>

<p>Default OpenvSwitch implementation <a href="https://github.com/openvswitch/ovs/blob/master/FAQ.md#q-how-much-of-the-vxlan-protocol-does-open-vswitch-currently-support">does not support</a> VXLAN multicast flooding and uses unicast source replication instead. This decision comes with a number of tradeoffs:</p>

<ul>
<li>Duplicate packets consume additional bandwidth. Extra 100 bytes exchanged every 3 minutes in a 100-nodes environment generate around 500 kbit/s of traffic on average. This can be considered negligible inside modern high-speed DC fabrics.</li>
<li>Hardware VTEP gateways rely on multicast for MAC learning and VTEP discovery. As we&rsquo;ll see later in the series, these gateways can now be controlled by Neutron just like a normal OVS inside a compute host.</li>
<li>Duplicate packets are processed by hosts that do not need them, e.g. ARP request is processed by tunnel and integration bridges of all hosts that have VMs in the same broadcast domain. This presents some serious scaling limitation and is addressed by the L2 population feature described in this post.</li>
</ul>


<p>Despite all the tradeoffs, OVS with unicast source replication has become a de-facto standard in most recent OpenStack implementations. The biggest advantage of such approach is the lack of requirement for multicast in the underlay network.</p>

<h2>VXLAN MAC learning with an SDN controller</h2>

<p>Neutron server is aware of all active MAC and IP addresses within the environment. This information can be used to prepopulate forwarding entries on all tunnel bridges. This is accomplished by a <a href="https://github.com/openstack/neutron/tree/master/neutron/plugins/ml2/drivers/l2pop">L2 population</a> driver. However that in itself isn&rsquo;t enough. Whenever a VM doesn&rsquo;t know the destination MAC address, it will send a broadcast ARP request which needs to be intercepted and responded by a local host to stop it from being flooded in the network. The latter is accomplished by a feature called <a href="https://assafmuller.com/2014/05/21/ovs-arp-responder-theory-and-practice/">ARP responder</a> which simulates the functionality commonly known as <strong>ARP proxy</strong> inside the tunnel bridge.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-l2-arp.png"></p>

<h3>Configuration</h3>

<p>Configuration of these two features is <a href="https://kimizhang.wordpress.com/2014/04/01/how-ml2vxlan-works/">fairly straight-forward</a>. First, we need to add L2 population to the list of supported mechanism drivers on our control node and restart the neutron server.</p>

<figure class='code'><figcaption><span>Update on control node</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sed -ri <span class="s1">&#39;s/(mechanism_drivers.*)/\1,l2population/&#39;</span> /etc/neutron/plugin.ini
</span><span class='line'><span class="nv">$ </span>service neutron-server restart
</span></code></pre></td></tr></table></div></figure>


<p>Next we need to enable L2 population and ARP responder features on all 3 compute nodes.</p>

<figure class='code'><figcaption><span>Updates on all 3 compute nodes</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>sed -ri <span class="s1">&#39;s/.*(arp_responder).*/\1 = true/&#39;</span> /etc/neutron/plugins/ml2/openvswitch_agent.ini
</span><span class='line'><span class="nv">$ </span>sed -ri <span class="s1">&#39;s/.*(l2_population).*/\1 = true/&#39;</span> /etc/neutron/plugins/ml2/openvswitch_agent.ini
</span><span class='line'><span class="nv">$ </span>service neutron-openvswitch-agent restart
</span></code></pre></td></tr></table></div></figure>


<p>Since L2 population is triggered by the <a href="https://assafmuller.com/2014/02/23/ml2-address-population/">port_up</a> messages, we might need to restart both our VMs for the change to take effect.</p>

<h3>BUM frame from VM-1 for MAC address of VM-2 (Revisited)</h3>

<p>Now let&rsquo;s once again examine what happens when VM-1 issues an ARP request for VM-2&rsquo;s MAC address (1a:bf).</p>

<p>First, the frame hits the flood-and-learn rule of the integration bridge and gets flooded down to the tunnel bridge as desribed in the <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">previous post</a>. Once in the br-tun, the frames gets matched by the incoming port and resubmitted to table 2. In addition to a default unicast/multicast bit match, table 2 now also matches all ARP requests and resubmitts them to the new table 21. Note how the ARP entry has a higher priority to always match before the default catch-all multicast rule.</p>

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>1,arp,dl_dst<span class="o">=</span>ff:ff:ff:ff:ff:ff <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,21<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>01:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,22<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Inside table 21 are the entries created by the ARP responder feature. The following is an example entry that matches all ARP requests where target IP address field equals the IP of VM-2(10.0.0.9).</p>

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> <span class="nv">table</span><span class="o">=</span>21, <span class="nv">priority</span><span class="o">=</span>1,arp,dl_vlan<span class="o">=</span>1,arp_tpa<span class="o">=</span>10.0.0.9
</span><span class='line'> <span class="nv">actions</span><span class="o">=</span>move:NXM_OF_ETH_SRC<span class="o">[]</span>-&gt;NXM_OF_ETH_DST<span class="o">[]</span>,
</span><span class='line'> mod_dl_src:fa:16:3e:ab:1a:bf,
</span><span class='line'> load:0x2-&gt;NXM_OF_ARP_OP<span class="o">[]</span>,
</span><span class='line'> move:NXM_NX_ARP_SHA<span class="o">[]</span>-&gt;NXM_NX_ARP_THA<span class="o">[]</span>,
</span><span class='line'> move:NXM_OF_ARP_SPA<span class="o">[]</span>-&gt;NXM_OF_ARP_TPA<span class="o">[]</span>,
</span><span class='line'> load:0xfa163eab1abf-&gt;NXM_NX_ARP_SHA<span class="o">[]</span>,
</span><span class='line'> load:0xa000009-&gt;NXM_OF_ARP_SPA<span class="o">[]</span>,
</span><span class='line'> IN_PORT
</span></code></pre></td></tr></table></div></figure>


<p>The resulting action builds an ARP response by modifying the fields and headers on the original ARP request message, specifically OVS:</p>

<ol>
<li>Copies the source MAC address (VM-1) to the destination MAC address header</li>
<li>Spoofs the source MAC address to make it look like it comes from VM-2</li>
<li>Modifies the operation code of ARP message to 0x2, meaning <strong>reply</strong></li>
<li>Overwrites the target IP and MAC address fields inside the ARP packet with VM-1&rsquo;s values</li>
<li>Overwrites the source hardware address with VM-2&rsquo;s MAC</li>
<li>Overwrites the source IP address with the address of VM-2(0xa000009)</li>
<li>Sends the packet out the port from which it was received</li>
</ol>


<h3>Unicast frame from VM-1 to VM-2 (Revisited)</h3>

<p>Now that VM-1 has learned the MAC address of VM-2 it can start sending the unicast frames. The first few steps will again be the same. The frame hits the tunnel bridge, gets classified as a unicast and resubmitted to table 20. Table 20 will still have an entry generated by a <strong>learn</strong> action triggered by a packet coming from VM-2, however now it also has and identical entry with a higher priority(priority=2), which was preconfigured by a L2 population feature.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>20, <span class="nv">priority</span><span class="o">=</span>2,dl_vlan<span class="o">=</span>1,dl_dst<span class="o">=</span>fa:16:3e:ab:1a:bf <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x54,output:2
</span><span class='line'><span class="nv">table</span><span class="o">=</span>20, <span class="nv">priority</span><span class="o">=</span>1,vlan_tci<span class="o">=</span>0x0001/0x0fff,dl_dst<span class="o">=</span>fa:16:3e:ab:1a:bf <span class="nv">actions</span><span class="o">=</span>load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:0x54-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:2
</span></code></pre></td></tr></table></div></figure>


<h2>Other BUM traffic</h2>

<p>The two features described in this post only affect the ARP traffic to VMs <strong>known</strong> to the Neutron server. All the other BUM traffic will still be flooded as described in the <a href="http://networkop.github.io/blog/2016/04/22/neutron-native/">previous post</a>.</p>

<h2>Results</h2>

<p>As the result of enabling L2 population and ARP responder features we were able to reduce the amount of BUM traffic in the overlay network and reduce the eliminate processing on compute hosts incurred by ARP request flooding.</p>

<p>However one downside of this approach is the increased number of flow entries in tunnel bridges of compute hosts. Specifically, for each known VM there now will be two entries in the tunnel bridge with different priorities. This may have negative impact on performance and is something to keep in mind when designing OpenStack solutions for scale.</p>

<h2>Coming Up</h2>

<p>In the next post I&rsquo;ll show how to overcome the requirement of a direct L2 adjacency between the network node and external subnet. Specifically, I&rsquo;ll use Arista switch to extend a L2 provider network over a L3 leaf-spine Cisco fabric.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network Engineering Analysis of OpenStack SDN]]></title>
    <link href="http://networkop.github.io/blog/2016/04/22/neutron-native/"/>
    <updated>2016-04-22T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/04/22/neutron-native</id>
    <content type="html"><![CDATA[<p>Now that we have our 3-node OpenStack lab <a href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/">up and running</a> we can start exploring how virtual networks are implemented under the hood.</p>

<!--more-->


<h2>Intro</h2>

<p>This is going to be quite a lengthy blogpost so I&rsquo;ll try to explain its structure first. I&rsquo;ll start with a high level overview of components used to build virtual networks by examining 3 types of traffic:</p>

<ul>
<li>Unicast traffic between VM1 and VM2</li>
<li>Unicast traffic between VM1 and the outside world (represented by an external subnet)</li>
<li>Broadcast, Unknown unicast and Multicast or BUM traffic from VM1</li>
</ul>


<p>Following that I&rsquo;ll give a brief overview of how to interpret the configuration and dynamic state of OpenvSwitch to manually trace the path of a packet. This will be required for the next section where I&rsquo;ll go over the same 3 types of traffic but this time corroborating every step with the actual outputs collected from the virtual switches. For the sake of brevity I&rsquo;ll abridge a lot of the output to only contain the relevant information.</p>

<h2>High Level Overview</h2>

<p><a href="http://www.innervoice.in/blogs/2015/03/31/openstack-neutron-plugins-and-agents/">Neutron</a> server, residing in a control node, is responsible for orchestrating and provisioning of all virtual networks within an OpenStack environment. Its goal is to enable end-to-end reachability among the VMs and between the VMs and external subnets. To do that, Neutron uses concepts that should be very familiar to every network engineer like subnet, router, firewall, DHCP and NAT. In the <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous post</a> we&rsquo;ve seen how to create a virtual router and attach it to public and private networks. We&rsquo;ve also attached both of our VMs to a newly created private network and verified connectivity by logging into those virtual machines. Now let&rsquo;s see how exactly these VMs communicate with each other and the outside world.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-high-level.png"></p>

<h3>Unicast frame between VM1 and VM2</h3>

<ol>
<li><p>As soon as the frame leaves the vNIC of VM1 it hits the firewall. The firewall is implemented on a <a href="http://www.innervoice.in/blogs/2013/12/08/tap-interfaces-linux-bridge/">tap interface</a> of the integration bridge. A set of <abbr title="Access Control List">ACL</abbr> rules, defined in a <strong>Security Group</strong> that VM belongs to, gets translated into Linux <a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TRAVERSINGOFTABLES">iptables</a> rules and attached to this tap interface. These simple reflexive access lists are what VMware and Cisco are calling microsegmentation and touting as one of the main use case of their SDN solutions.</p></li>
<li><p>Next our frame enters the integration bridge implemented using <a href="http://openvswitch.org/">OpenvSwitch</a>. Its primary function is to interconnect all virtual machines running on the host. Its secondary function is to provide isolation between different subnets and tenants by keeping them in different VLANs. VLAN IDs used for this are locally significant and don&rsquo;t propagate outside of the physical host.</p></li>
<li><p>A dot1q-tagged packet is forwarded down a layer 2 trunk to the tunnel bridge, also implemented using OpenvSwitch. It is programmed to strip the dot1q tags, replace them with VXLAN headers and forward an IP/UDP packet with VXLAN payload on to the physical network.</p></li>
<li><p>Our simple routed underlay delivers the packets to the destination host, where the tunnel bridge swaps the <abbr title=" VXLAN Network ID">VNI</abbr> with a dot1q tag and forwards the packet up to the integration bridge.</p></li>
<li><p>Integration bridge consults the local MAC table, finds the output interface, clears the dot1q tag and send the frame up to the VM.</p></li>
<li><p>The frame gets screened by incoming iptables rules and gets delivered to the VM2.</p></li>
</ol>


<h3>Unicast frame between VM1 and External host</h3>

<ol>
<li><p>The first 3 steps will still be the same. VM1 sends a frame with destination MAC address of a virtual router. This packet will get encapsulated in a VXLAN header and forwarded to the Network node.</p></li>
<li><p>The tunnel and integration bridges of the network node deliver the packet to the private interface of a virtual router. This virtual router lives in a <a href="http://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/">linux network namespaces</a> (similar to <abbr title="Virtual Routing and Forwarding">VRF</abbr>s) used to provide isolation between OpenStack tenants.</p></li>
<li><p>The router finds the outgoing interface (a port attached to the external bridge), and a next-hop IP which we have set when we configured a public subnet <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">earlier</a>.</p></li>
<li><p>The router then performs a source NAT on the packet before forwarding it out. This way the private IP of the VM stays completely hidden and hosts outside of OpenStack can talk back to the VM by sending packets to (publicly routable) external subnet.</p></li>
<li><p>External bridge (also an OpenvSwitch) receives the packet and forwards it out the attached physical interface (eth1.300).</p></li>
</ol>


<h3>BUM frame from VM1 for MAC address of VM2</h3>

<ol>
<li><p>VM1 sends a multicast frame, which gets examined by the iptables rules and enters the integration bridge.</p></li>
<li><p>The integration bridge follows the same process as for the unicast frame to assign the dot1q tag and floods the frame to the tunnel bridge.</p></li>
<li><p>The tunnel bridge sees the multicast bit in the destination MAC address and performs source replication by sending a duplicate copy of the frame to both compute host #2 and the network node.</p></li>
<li><p>Tunnel bridges of both receiving hosts strip the VXLAN header, add the dot1q tag and flood the frame to their respective integration bridges.</p></li>
<li><p>Integration bridges flood the frame within the VLAN identified by the dot1q header.</p></li>
<li><p>The response from VM2 follows the same process as the unicast frame.</p></li>
</ol>


<p>One thing worth noting is when an ARP packet enters the integration bridge, its source IP address (in case of IPv4) or source MAC address (in case of IPv6) gets examined to make sure it belong to that VM. This is how <strong>ARP spoofing protection</strong> is implemented in OpenStack.</p>

<h2>OpenvSwitch quick intro</h2>

<p>Before we dive deeper into the details of the packet flows inside OVS let me give a brief overview of how it works. There are two main protocols to configure OVS:</p>

<ul>
<li><p>OVSDB - a management protocol used to configure bridges, ports, VLANs, QoS, monitoring etc.</p></li>
<li><p>OpenFlow - used to install flow entries for traffic switching, similar to how you would configure a static route but allowing you to match on most of the L2-L4 protocol headers.</p></li>
</ul>


<p>Control node instructs all <a href="http://www.innervoice.in/blogs/2015/03/31/openstack-neutron-plugins-and-agents/">local OVS agents</a> about how to configure virtual networks. Each local OVS agent then uses these two protocols to configure OVS and install all the required forwarding entries. Each entry contains a set of matching fields (e.g. incoming port, MAC/IP addresses) and an action field which determines what to do with the packet. These forwarding entries are implemented as <a href="https://wiki.openstack.org/wiki/Ovs-flow-logic">tables</a>. This is how a packet traverses these tables:</p>

<ol>
<li><p>First packet always hits table 0. The entries are examined in order of their priority (highest first) to find the first match. Note that it&rsquo;s the first and not necessarily the more specific match. It&rsquo;s the responsibility of a controller to build tables so that more specific flows are matched first. Normally this is done by assigning a higher priority to a more specific flow. Exact matches (where all L2-L4 fields are specified) implicitly have the highest priority value of 65535.</p></li>
<li><p>When a flow is matched, the <strong>action</strong> field of that flow is examined. Here are some of the most commonly used actions:</p>

<table>
<thead>
<tr>
<th> Action </th>
<th></th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td> resubmit(X,) </td>
<td></td>
<td> Resubmit a packet to table X </td>
</tr>
<tr>
<td> output:Y </td>
<td></td>
<td> Send a packet out port Y </td>
</tr>
<tr>
<td> NORMAL </td>
<td></td>
<td> Use a standard flood-and-learn behaviour of a switch to populate a local dynamic MAC address table </td>
</tr>
<tr>
<td> learn(table=Z) </td>
<td></td>
<td> Create an exact-match entry for the matched flow in table Z (we&rsquo;ll see how its used later on) </td>
</tr>
</tbody>
</table>


<p> These actions can be combined in a sequence to create complex behaviours like sending the same packet to multiple ports for multicast source replication.</p></li>
<li><p>OVS also <a href="https://networkheresy.com/2014/11/13/accelerating-open-vswitch-to-ludicrous-speed/">implements</a> what Cisco calls <strong>Fast switching</strong>, where the first packet lookup triggers a cache entry to be installed in the kernel-space process to be used by all future packets from the same flow.</p></li>
</ol>


<h2>Detailed packet flow analysis</h2>

<p>Let&rsquo;s start by recapping what we know about our private virtual network. All these values can be obtained from Horizon GUI by examining the private network configuration under Project -> Network -> Networks -> private_network:</p>

<ul>
<li>VM1, IP=10.0.0.8, MAC=fa:16:3e:19:e4:91, port id = <strong>258336bc-4f</strong>38-4bec-9229-4bc76e27f568</li>
<li>VM2, IP=10.0.0.9, MAC=fa:16:3e:ab:1a:bf, port id = <strong>e5f7eaca-1a</strong>36-4b08-aa9b-14e9787f80b0</li>
<li>Router, IP=10.0.0.1, MAC=fa:16:3e:cf:89:47, port id = <strong>96dfc1d3-d2</strong>3f-4d28-a461-fa2404767df2</li>
</ul>


<p>The first 11 characters of port id will be used inside an integration bridge to build the port names, e.g.:</p>

<ul>
<li>tap258336bc-4f - interface connected to VM1</li>
<li>qr-96dfc1d3-d2 - interface connected to the router</li>
</ul>


<h3>Enumerating OVS ports</h3>

<p>In its forwarding entries OVS uses internal port numbers a lot, therefore it would make sense to collect all port number information before we start. This is how it can be done:</p>

<ul>
<li>Use <code>ovs-vsctl show</code> command to collect information about existing port names and their attributes (e.g. dot1q tag, VXLAN tunnel IPs, etc). This is the output collected on compute host #1:</li>
</ul>


<figure class='code'><figcaption><span>ovs-vsctl show | grep -E "Bridge|Port|tag|options"</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Bridge br-tun
</span><span class='line'>    Port br-tun
</span><span class='line'>    Port patch-int
</span><span class='line'>            options: <span class="o">{</span><span class="nv">peer</span><span class="o">=</span>patch-tun<span class="o">}</span>
</span><span class='line'>    Port <span class="s2">&quot;vxlan-0a00020a&quot;</span>
</span><span class='line'>            options: <span class="o">{</span><span class="nv">df_default</span><span class="o">=</span><span class="s2">&quot;true&quot;</span>, <span class="nv">in_key</span><span class="o">=</span>flow, <span class="nv">local_ip</span><span class="o">=</span><span class="s2">&quot;10.0.1.10&quot;</span>, <span class="nv">out_key</span><span class="o">=</span>flow, <span class="nv">remote_ip</span><span class="o">=</span><span class="s2">&quot;10.0.2.10&quot;</span><span class="o">}</span>
</span><span class='line'>    Port <span class="s2">&quot;vxlan-0a00030a&quot;</span>
</span><span class='line'>            options: <span class="o">{</span><span class="nv">df_default</span><span class="o">=</span><span class="s2">&quot;true&quot;</span>, <span class="nv">in_key</span><span class="o">=</span>flow, <span class="nv">local_ip</span><span class="o">=</span><span class="s2">&quot;10.0.1.10&quot;</span>, <span class="nv">out_key</span><span class="o">=</span>flow, <span class="nv">remote_ip</span><span class="o">=</span><span class="s2">&quot;10.0.3.10&quot;</span><span class="o">}</span>
</span><span class='line'>Bridge br-int
</span><span class='line'>    Port br-int
</span><span class='line'>    Port <span class="s2">&quot;tap258336bc-4f&quot;</span>
</span><span class='line'>        tag: 5
</span><span class='line'>    Port patch-tun
</span><span class='line'>            options: <span class="o">{</span><span class="nv">peer</span><span class="o">=</span>patch-int<span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Use <code>ovs-ofctl dump-ports-desc &lt;bridge_ID&gt;</code> command to correlate port names and numbers. Example below is for integration bridge of compute host #1:</li>
</ul>


<figure class='code'><figcaption><span>ovs-ofctl dump-ports-desc br-int | grep addr</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> 2<span class="o">(</span>patch-tun<span class="o">)</span>: addr:5a:c5:44:fc:ac:72
</span><span class='line'> 7<span class="o">(</span>tap258336bc-4f<span class="o">)</span>: addr:fe:16:3e:19:e4:91
</span><span class='line'> LOCAL<span class="o">(</span>br-int<span class="o">)</span>: addr:46:fe:10:de:1b:4f
</span></code></pre></td></tr></table></div></figure>


<p>I&rsquo;ve put together a diagram showing all the relevant integration bridge (<strong>br-int</strong>) and tunnel bridge (<strong>br-tun</strong>) ports on all 3 hosts.</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-port-details.png"></p>

<h3>Unicast frame between VM1 and VM2</h3>

<ol>
<li> Frame enters the br-int on port 7. Default iptables rules allow all outbound traffic from a VM.</li>

<li> Inside the br-int our frame is matched by the "catch-all" rule which triggers the flood-and-learn behaviour:

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>10,arp,in_port<span class="o">=</span><span class="m">7</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,24<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span><span class="m">0</span> <span class="nv">actions</span><span class="o">=</span>NORMAL
</span></code></pre></td></tr></table></div></figure></li>

<li> Since it's a unicast frame the MAC address table is already populated by ARP:

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">2</span>     <span class="m">5</span>  fa:16:3e:ab:1a:bf    1
</span></code></pre></td></tr></table></div></figure></li>

Target IP address is behind port 2 which is where the frame gets forwarded next.

<li> Inside the tunnel bridge the frame will match three different tables. The first table simply matches the incoming port and resubmits the frame to table 2. Table 2 will match the unicast bit of the MAC address (the least significant bit of the first byte) and resubmit the frame to unicast table 20:

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1, <span class="nv">in_port</span><span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0, <span class="nv">dl_dst</span><span class="o">=</span>00:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,20<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>20, <span class="nv">priority</span><span class="o">=</span>1, <span class="nv">vlan_tci</span><span class="o">=</span>0x0005/0x0fff,dl_dst<span class="o">=</span>fa:16:3e:ab:1a:bf <span class="nv">actions</span><span class="o">=</span>load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:0x54-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:2
</span></code></pre></td></tr></table></div></figure>

The final match is done on a VLAN tag and destination MAC address. Resulting action is a combination of three consecutive steps:
<ol>
  <li> Clear the dot1q tag - load:0->NXM_OF_VLAN_TCI[]</li>
  <li> Tag the frame with VNI 0x54 - load:0x54->NXM_NX_TUN_ID[]</li>
  <li> Send the frame to compute host 2 - output:2</li>
</ol>
This last match entry is quite interesting in a way that it contains the destination MAC address of VM2, which means this entry was created <b>after</b> the ARP process. In fact, as we'll see in the next step, this entry is populated by a <b>learn</b> action triggered by the ARP response coming from VM2.
</li>

<li>A VXLAN packet arrives at compute host 2 and enters the tunnel bridge through port 2. It's matched on the incoming port and resubmitted to a table where it is assigned with an internal VLAN ID 3 based on the matched tunnel id 0x54. 

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">2</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,4<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>4, <span class="nv">priority</span><span class="o">=</span>1,tun_id<span class="o">=</span>0x54 <span class="nv">actions</span><span class="o">=</span>mod_vlan_vid:3,resubmit<span class="o">(</span>,10<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>10, <span class="nv">priority</span><span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>learn<span class="o">(</span><span class="nv">table</span><span class="o">=</span>20,hard_timeout<span class="o">=</span>300,priority<span class="o">=</span>1,NXM_OF_VLAN_TCI<span class="o">[</span>0..11<span class="o">]</span>,NXM_OF_ETH_DST<span class="o">[]=</span>NXM_OF_ETH_SRC<span class="o">[]</span>,load:0-&gt;NXM_OF_VLAN_TCI<span class="o">[]</span>,load:NXM_NX_TUN_ID<span class="o">[]</span>-&gt;NXM_NX_TUN_ID<span class="o">[]</span>,output:NXM_OF_IN_PORT<span class="o">[])</span>,output:1
</span></code></pre></td></tr></table></div></figure>

The last match does two things:
<ol>
  <li> Creates a mirroring entry in table 20 for the reverse packet flow. This is the entry similar to the one we've just seen in step 4.  </li>
  <li> Sends the packet towards the integration bridge.</li>
</ol>
</li>  
<li>The integration bridge checks the local dynamic MAC address table to find the MAC address of VM2(1a:bf).

<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>port  VLAN  MAC                Age
</span><span class='line'>  <span class="m">5</span>     <span class="m">3</span>  fa:16:3e:ab:1a:bf    0
</span></code></pre></td></tr></table></div></figure>
</li>

<li>The frame is checked against the iptables rules configured on port 5 and gets sent up to VM2</li>
</ol>


<h3>Unicast frame to external host (192.168.247.1)</h3>

<ol>
  <li>
    The first 5 steps will be similar to the previous section. The only exception will be that the tunnel bridge of compute host 1 will send the VXLAN packet out port 3 towards the network node.
  </li>
  <li>
    The integration bridge of the network node consults the MAC address table to find the location of the virtual router (89:47) and forwards the packet out port 6.
<figure class='code'><figcaption><span>ovs-appctl fdb/show br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">6</span>     <span class="m">1</span>  fa:16:3e:cf:89:47    1
</span></code></pre></td></tr></table></div></figure>
  </li>
  <li> The virtual router does the route lookup to find the outgoing interface (qg-18bff97b-57)
<figure class='code'><figcaption><span>ip route get 192.168.247.1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>192.168.247.1 dev qg-18bff97b-57  src 192.168.247.90
</span></code></pre></td></tr></table></div></figure>
Remember that since our virtual router resides in a network namespace all commands must be prepended with <code>ip netns exec qrouter-uuid</code>
  
  </li>
  <li> The virtual router performs the source IP translation to hide the private IP address: 
<figure class='code'><figcaption><span>iptables -t nat -S | grep qg-18bff97b-57</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>-A neutron-l3-agent-POSTROUTING ! -i qg-18bff97b-57 ! -o qg-18bff97b-57 -m conntrack ! --ctstate DNAT -j ACCEPT
</span><span class='line'>-A neutron-l3-agent-snat -o qg-18bff97b-57 -j SNAT --to-source 192.168.247.90
</span></code></pre></td></tr></table></div></figure>
By default all packets will get translated to the external address of the router. For each assigned floating IP address there will be a pair of source/destination NAT entries created in the same table. 

  </li>
  <li> The router consults its local ARP table to find the MAC address of the next hop:
<figure class='code'><figcaption><span>ip neigh show 192.168.247.1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>192.168.247.1 dev qg-18bff97b-57 lladdr 00:50:56:c0:00:01 DELAY
</span></code></pre></td></tr></table></div></figure>
  </li>
  <li> External bridge receives the frame from the virtual router on port 4, consults its own MAC address table built by ARP and forwards the packet to the final destination.
<figure class='code'><figcaption><span>ovs-appctl fdb/show br-ex</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'> port  VLAN  MAC                Age
</span><span class='line'>    <span class="m">4</span>     <span class="m">0</span>  fa:16:3e:5c:90:e0    1
</span><span class='line'>    <span class="m">1</span>     <span class="m">0</span>  00:50:56:c0:00:01    1
</span></code></pre></td></tr></table></div></figure></li>
</ol>


<h3>BUM frame from VM1 for MAC address of VM2</h3>

<ol>
  <li>The integration bridge of the sending host will check the source IP of the ARP packet to make sure it hasn't been spoofed before flooding the packet within the local broadcast domain (VLAN 5).

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-int</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>10,arp,in_port<span class="o">=</span><span class="m">7</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,24<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>24, <span class="nv">priority</span><span class="o">=</span>2,arp,in_port<span class="o">=</span>7,arp_spa<span class="o">=</span>10.0.0.8 <span class="nv">actions</span><span class="o">=</span>NORMAL
</span></code></pre></td></tr></table></div></figure>
</li>
<li> The flooded packet reaches the tunnel bridge where it goes through 3 different tables. The first table matches the incoming interface, the second table matches the multicast bit of the MAC address.

<figure class='code'><figcaption><span>ovs-ofctl dump-flows br-tun</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">table</span><span class="o">=</span>0, <span class="nv">priority</span><span class="o">=</span>1,in_port<span class="o">=</span><span class="m">1</span> <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,2<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>2, <span class="nv">priority</span><span class="o">=</span>0,dl_dst<span class="o">=</span>01:00:00:00:00:00/01:00:00:00:00:00 <span class="nv">actions</span><span class="o">=</span>resubmit<span class="o">(</span>,22<span class="o">)</span>
</span><span class='line'><span class="nv">table</span><span class="o">=</span>22, <span class="nv">dl_vlan</span><span class="o">=</span><span class="m">5</span> <span class="nv">actions</span><span class="o">=</span>strip_vlan,set_tunnel:0x54,output:3,output:2
</span></code></pre></td></tr></table></div></figure>

The final table swaps the dot1q and VXLAN identifiers and does the source replication by forwarding the packet out ports 2 and 3.
</li>
<li> The following steps are similar to the unicast frame propagation with the exception that the local MAC table of the integration bridges will flood the packet to all interfaces in the same broadcast domain. That means that duplicate ARP requests will reach both the private interface of the virtual router and VM2. The latter, recognising its own IP, will send a unicast ARP response whose source IP will be verified by the ARP spoofing rule of the integration bridge. As the result of that process, both integration bridges on compute host 1 and 2 will populate their local MAC tables with addresses of VM1 and VM2.
</li>
</ol>


<h2>Native OpenStack SDN advantages and limitation</h2>

<p>Current implementation of OpenStack networking has several advantages compared to the traditional SDN solutions:</p>

<ul>
<li>Data-plane learning allows network to function even in the absence of the controller node</li>
<li>Multicast source replication does not rely on multicast support in the underlay network</li>
<li>ARP spoofing protection is the default security setting</li>
</ul>


<p>However at this point it should also be clear that there a number of limitations that can impact the overall network scalability and performance:</p>

<ul>
<li>Multicast source replication creates unnecessary overhead by flooding ARP packets to all hosts</li>
<li>All routed traffic has to go through the network node which becomes a bottleneck for the whole network</li>
<li>There is no ability to control physical devices, even the ones that support OVSDB/Openflow</li>
<li>Network node must be layer 2 adjacent with the external network segment</li>
</ul>


<h2>Things to explore next</h2>

<p>In the following posts I&rsquo;ll continue poking around Neutron and explore a number of features designed to address some of the limitations described above:</p>

<ul>
<li><a href="http://networkop.github.io/blog/2016/05/06/neutron-l2pop/">L2 population</a></li>
<li><a href="https://wiki.openstack.org/wiki/Neutron/DVR">Distributed Virtual Router</a></li>
<li><a href="https://wiki.openstack.org/wiki/Neutron/L2-GW">L2 hardware gateway</a></li>
<li><a href="https://wiki.openstack.org/wiki/Neutron/L3_High_Availability_VRRP">Network High Availability</a></li>
<li><a href="https://wiki.openstack.org/wiki/Neutron/LBaaS">Load-Balancing-as-a-Service</a></li>
<li><a href="https://github.com/openstack/networking-ovn">Open Virtual Network for OVS</a></li>
<li><a href="http://specs.openstack.org/openstack/neutron-specs/specs/mitaka/bgp-dynamic-routing.html">Neutron&rsquo;s dynamic BGP routing</a></li>
</ul>


<h2>C<sub>2</sub>O</h2>

<p>While writing this post I&rsquo;ve compiled a list of commands most useful to query the state of OpenvSwitch. So now, inspired by a similar  IOS to JUNOS (I2J) command <a href="http://www.net-gyver.com/?page_id=1166">conversion tables</a>, I&rsquo;ve put together my own Cisco to OVS conversion table, just for fun.</p>

<table>
<thead>
<tr>
<th> Action </th>
<th> Cisco </th>
<th> OpenvSwitch </th>
</tr>
</thead>
<tbody>
<tr>
<td> Show MAC address table </td>
<td> show mac address-table dynamic   </td>
<td> <code>ovs-appctl fdb/show &lt;bridge_id&gt;</code> </td>
</tr>
<tr>
<td> Clear MAC address table </td>
<td> clear mac address-table dynamic </td>
<td> <code>ovs-appctl fdb/flush &lt;bridge_id&gt;</code> </td>
</tr>
<tr>
<td> Show port numbers </td>
<td> show interface status </td>
<td> <code>ovs-ofctl dump-ports-desc &lt;bridge_ID&gt;</code> </td>
</tr>
<tr>
<td> Show OVS configuration </td>
<td> show run </td>
<td> <code>ovs-vsctl show</code> </td>
</tr>
<tr>
<td> Show packet forwarding rules </td>
<td> show ip route  </td>
<td> <code>ovs-ofctl dump-flows &lt;bridge_id&gt;</code> </td>
</tr>
<tr>
<td> Simulate packet flow </td>
<td> packet-tracer   </td>
<td> <code>ovs-appctl ofproto/trace &lt;bridge_id&gt; in_port=1</code> </td>
</tr>
<tr>
<td> View command history </td>
<td> show archive log config </td>
<td> <code>ovsdb-tool show-log -m</code> </td>
</tr>
</tbody>
</table>


<h2>References</h2>

<p>In this post I have glossed over some details like iptables and DHCP for the sake of brevity and readability. However this post wouldn&rsquo;t be complete if I didn&rsquo;t include references to other resources that contain a more complete, even if at times outdated, overview of OpenStack networking. This is also a way to pay tribute to blogs where I&rsquo;ve learned most of what I was writing about here:</p>

<ul>
<li><a href="https://www.rdoproject.org/networking/networking-in-too-much-detail/">Networking in too much detail</a></li>
<li><a href="http://www.opencloudblog.com/?p=300">Neutron using VXLAN</a></li>
<li><a href="http://docs.ocselected.org/openstack-manuals/kilo/networking-guide/content/under_the_hood_openvswitch.html">Under the hood of OVS</a></li>
<li><a href="https://kimizhang.wordpress.com/2014/04/01/how-ml2vxlan-works/">How ML2/VXLAN works</a></li>
<li><a href="http://docs.openstack.org/openstack-ops/content/network_troubleshooting.html">Official network troubleshooting guide</a></li>
<li><a href="http://therandomsecurityguy.com/openvswitch-cheat-sheet/">OVS commands cheat sheet</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Multi-node OpenStack Lab in UNetLab]]></title>
    <link href="http://networkop.github.io/blog/2016/04/18/os-unl-lab/"/>
    <updated>2016-04-18T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/04/18/os-unl-lab</id>
    <content type="html"><![CDATA[<p>In the <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous post</a> I&rsquo;ve demonstrated how to get a working instance of a single-node OpenStack inside <a href="http://www.unetlab.com/">UNetLab</a>. In this post we&rsquo;ll continue building on that by adding two new compute nodes and redesigning our network to resemble something you might actually see in a real life.</p>

<!--more-->


<h2>OpenStack network requirements</h2>

<p>Depending on the number of deployed <a href="https://www.openstack.org/software/project-navigator/">components</a>, OpenStack physical network requirements could be different. In our case we&rsquo;re not going to deploy any storage solution and simply use the <strong>ephemeral</strong> storage, i.e. hard disk that&rsquo;s a part of a virtual machine. However, even in minimal installations, there are a number of networks that should be considered individually due to different connectivity requirements:</p>

<ul>
<li><p>Server <abbr title=" Out-Of-Band">OOB</abbr> <strong>management</strong> network - this is usually a dedicated physical network used mainly for server bootstrapping and OS deployment. It is a Layer 3 network with DHCP relays configured at each edge L3 interface and access to Internet package repositories.</p></li>
<li><p><strong>API</strong> network - used for internal communication between various OpenStack services. This can be a routed network without Internet access. The only requirement is any-to-any reachability within a single OpenStack environment.</p></li>
<li><p><strong>External</strong> network - used for public access to internal OpenStack virtual machines. This is the <em>outside</em> of OpenStack, with a pool of IP addresses used to NAT the internal IPs of public-facing virtual machines. This network <strong>must</strong> be Layer 2 adjacent <strong>only</strong> with a network control node.</p></li>
<li><p><strong>Tenant</strong> network - used for communication between virtual machines within OpenStack environment. Thanks to the use of VXLAN overlay, this can be a simple routed network that has any-to-any reachability between all Compute and Network nodes.</p></li>
</ul>


<h2>Building a lab network</h2>

<p>For labbing purposes it&rsquo;s possible to relax some of the above network requirements without seriously affecting the outcomes of our simulation. For example, it&rsquo;s possible to combine some of the networks and still satisfy the requirements stated above. These are the networks that will be configured inside UNetLab:</p>

<ul>
<li><p><strong>Management</strong> - this network will combine the functions of OOB and API networks. To isolate it from our data centre underlay I&rsquo;ll be using separate interfaces on virtual machines and connect them directly to Workstation&rsquo;s NAT interface (192.168.91.0/24 in my case)  to give them direct access to Internet.</p></li>
<li><p><strong>External</strong> - this network will be connected to Workstation&rsquo;s host-only NIC (192.168.247.0/24) through Vlan300 configured on one of the leaf switches. Since it must be L2 adjacent with the network control node our leaf switch will not perform any routing for this subnet.</p></li>
<li><p><strong>Tenant</strong> - this will be a routed leaf/spine <a href="https://en.wikipedia.org/wiki/Clos_network">Clos</a> fabric comprised of 3 leaf and 2 spine switches running a single-area OSPF process on all their links. Each server will have its own unique tenant subnet (Vlan100) terminated on the leaf switch and subnet injected into OSPF. The subnet used for this Vlan is going to be <code>10.0.X.0/24</code>, where X is the number of the leaf switch terminating the vlan.</p>

<p>  The links between switches are all L3 point-to-point with addresses borrowed from 169.254.0.0/16 range specifically to emphasize the fact that the internal addressing does not need to be known or routed outside of the fabric. The <strong>sole function of the fabric</strong> is to provide multiple equal cost paths between any pair of leafs, thereby achieving maximum link utilisation. Here&rsquo;s an example of a traceroute between Vlan100&rsquo;s of Leaf #1 and Leaf #3.</p></li>
</ul>


<figure class='code'><figcaption><span>Traceroute inside an ECMP routed Clos fabric</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>L3#traceroute 10.0.1.1 source 10.0.3.1
</span><span class='line'>Type escape sequence to abort.
</span><span class='line'>Tracing the route to 10.0.1.1
</span><span class='line'>VRF info: (vrf in name/id, vrf out name/id)
</span><span class='line'>  1 169.254.31.111 1 msec
</span><span class='line'>    169.254.32.222 0 msec
</span><span class='line'>    169.254.31.111 0 msec
</span><span class='line'>  2 169.254.12.1 1 msec
</span><span class='line'>    169.254.11.1 1 msec *
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>Building lab servers</h2>

<p>Based on my experience a standard server would have at least 3 physical interfaces - one for OOB management and a pair of interfaces for application traffic. The two application interfaces will normally be combined in a single <abbr title=" Link Aggregation Group">LAG</abbr> and connected to a pair of MLAG-capable TOR switches. Multi-chassis LAG or <a href="http://blog.ipspace.net/2010/10/multi-chassis-link-aggregation-basics.html">MLAG</a> is a pretty old and well-understood technology so I&rsquo;m not going to try and simulate it in the lab. Instead I&rsquo;ll simply assume that a server will be connected to a TOR switch via a single physical link. That link will be setup as a dot1q trunk to allow for multiple subnets to share it.</p>

<h2>Physical lab topology</h2>

<p>All the above requirements and assumptions result in the following topology that we need to build inside UNetLab:</p>

<p><img class="center" src="http://networkop.github.io/images/neutron-native.png"></p>

<p>For servers I&rsquo;ll be using OpenStack node type that I&rsquo;ve described in my <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous post</a>. The two compute nodes do not need as much RAM as the control node, so I&rsquo;ll reduce it to just 2GB.</p>

<p>For switches I&rsquo;ll be using a Cisco&rsquo;s <a href="http://www.unetlab.com/2014/11/adding-cisco-iouiol-images/">L2 IOU</a> image for now, mainly due to the low resource requirements. In the future I&rsquo;ll try and swap it for something else. As you can see from the sample config below, fabric configuration is very basic and can be easily replaced by any other solution:</p>

<figure class='code'><figcaption><span>Leaf 1 configuration</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>interface Ethernet0/0
</span><span class='line'> no switchport
</span><span class='line'> ip address 169.254.11.1 255.255.255.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> duplex auto
</span><span class='line'>!
</span><span class='line'>interface Ethernet0/1
</span><span class='line'> no switchport
</span><span class='line'> ip address 169.254.12.1 255.255.255.0
</span><span class='line'> ip ospf network point-to-point
</span><span class='line'> duplex auto
</span><span class='line'>!
</span><span class='line'>interface Ethernet0/2
</span><span class='line'> switchport trunk allowed vlan 100
</span><span class='line'> switchport trunk encapsulation dot1q
</span><span class='line'> switchport mode trunk
</span><span class='line'>!
</span><span class='line'>interface Vlan100
</span><span class='line'> ip address 10.0.1.1 255.255.255.0
</span><span class='line'>!
</span><span class='line'>router ospf 1
</span><span class='line'> network 0.0.0.0 255.255.255.255 area 0
</span></code></pre></td></tr></table></div></figure>


<h2>Server configuration and OpenStack installation</h2>

<p>Refer to my <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous blogpost</a> for instructions on how to install OpenStack and follow the first 5 steps from &ldquo;Installing CentOS and Openstack&rdquo; section. Before doing the final step, we need to configure our VMs' new interfaces:</p>

<ul>
<li>Remove any IP configuration from <strong>eth1</strong> interface to make it look like this:</li>
</ul>


<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-eth1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="na">TYPE</span><span class="o">=</span><span class="s">Ethernet</span>
</span><span class='line'><span class="na">BOOTPROTO</span><span class="o">=</span><span class="s">none</span>
</span><span class='line'><span class="na">DEVICE</span><span class="o">=</span><span class="s">eth1</span>
</span><span class='line'><span class="na">ONBOOT</span><span class="o">=</span><span class="s">yes</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Configure <strong>Tenant network</strong>:</li>
</ul>


<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/ifcfg-eth1.100</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="na">VLAN</span><span class="o">=</span><span class="s">yes</span>
</span><span class='line'><span class="na">DEVICE</span><span class="o">=</span><span class="s">eth1.100</span>
</span><span class='line'><span class="na">BOOTPROTO</span><span class="o">=</span><span class="s">none</span>
</span><span class='line'><span class="na">IPADDR</span><span class="o">=</span><span class="s">10.0.X.10</span>
</span><span class='line'><span class="na">PREFIX</span><span class="o">=</span><span class="s">24</span>
</span><span class='line'><span class="na">ONBOOT</span><span class="o">=</span><span class="s">yes</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Setup a <strong>static route</strong> to all other leaf nodes:</li>
</ul>


<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/route-eth1.100</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="err">10.0.0.0/8</span> <span class="err">via</span> <span class="err">10.0.X.1</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>On Control node setup <strong>External network</strong> interface</li>
</ul>


<figure class='code'><figcaption><span>/etc/sysconfig/network-scripts/route-eth1.300</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="na">DEVICE</span><span class="o">=</span><span class="s">eth1.300</span>
</span><span class='line'><span class="na">IPADDR</span><span class="o">=</span><span class="s">192.168.247.100</span>
</span><span class='line'><span class="na">PREFIX</span><span class="o">=</span><span class="s">24</span>
</span><span class='line'><span class="na">ONBOOT</span><span class="o">=</span><span class="s">yes</span>
</span><span class='line'><span class="na">BOOTPROTO</span><span class="o">=</span><span class="s">none</span>
</span><span class='line'><span class="na">VLAN</span><span class="o">=</span><span class="s">yes</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now we&rsquo;re ready to kick off OpenStack installation. This can be done with a single command that needs to be executed on the Control node. Note that <code>eth1.100</code> interface is spelled as <code>eth1_100</code> in the last line.</p>

<figure class='code'><figcaption><span>Controller</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>packstack --allinone <span class="se">\</span>
</span><span class='line'>    --os-cinder-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-ceilometer-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-trove-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-ironic-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --nagios-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-swift-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-gnocchi-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-aodh-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-neutron-ovs-bridge-mappings<span class="o">=</span>extnet:br-ex <span class="se">\</span>
</span><span class='line'>    --os-neutron-ovs-bridge-interfaces<span class="o">=</span>br-ex:eth1.300 <span class="se">\</span>
</span><span class='line'>    --os-neutron-ml2-type-drivers<span class="o">=</span>vxlan,flat <span class="se">\</span>
</span><span class='line'>    --provision-demo<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    --os-compute-hosts<span class="o">=</span>192.168.91.10,192.168.91.11,192.168.91.12 <span class="se">\</span>
</span><span class='line'>    --os-neutron-ovs-tunnel-if<span class="o">=</span>eth1_100
</span></code></pre></td></tr></table></div></figure>


<h2>Creating a virtual network for a pair of VMs</h2>

<p>Once again, follow all steps from &ldquo;Configuring Openstack networking&rdquo; section of my <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous blogpost</a>. Only this time when setting up a public subnet, update the subnet details to match our current environment:</p>

<figure class='code'><figcaption><span>Step 3 - Creating a public subnet</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>  neutron subnet-create --name public_subnet <span class="se">\</span>
</span><span class='line'>    --enable_dhcp<span class="o">=</span>False <span class="se">\</span>
</span><span class='line'>    --allocation-pool<span class="o">=</span><span class="nv">start</span><span class="o">=</span>192.168.247.90,end<span class="o">=</span>192.168.247.126 <span class="se">\</span>
</span><span class='line'>    --gateway<span class="o">=</span>192.168.247.1 external_network 192.168.247.0/24
</span></code></pre></td></tr></table></div></figure>


<h2>Nova-scheduler and setting up host aggregates</h2>

<p>OpenStack&rsquo;s Nova project is responsible for managing virtual machines. Nova controller views all available compute nodes as a single pool of resources. When a new VM is to be instantiated, a special process called nova-scheduler examines all available compute nodes and selects the &ldquo;best&rdquo; one based on a special algorithm, which normally takes into account amount of RAM, CPU and other host capabilities.</p>

<p>To make our host selection a little bit more deterministic, we can define a group of compute servers via <strong>host aggregates</strong>, which will be used by nova-scheduler in its selection algorithm. Normally it could include all servers in a single rack or a row of racks. In our case we&rsquo;ll setup two host aggregates each with a single compute host. This way we&rsquo;ll be able to select exactly which compute host to use when instantiating a new virtual machine.</p>

<p>To setup it up, from Horizon&rsquo;s dashboard navigate to Admin -> System and create two host aggregates <strong>comp-1</strong> and <strong>comp-2</strong>, each including a single compute host.</p>

<h2>Creating workloads and final testing</h2>

<p>Using a process described in &ldquo;Spinning up a VM&rdquo; section of my <a href="http://networkop.github.io/blog/2016/04/04/openstack-unl/">previous blogpost</a>, create a couple of virtual machines assigning them to different host aggregates created earlier.</p>

<h2>Security and Remote access</h2>

<p>To access these virtual machines we need to give them a <a href="https://www.rdoproject.org/networking/floating-ip-range/">floating</a> ip address from the External subnet range. To do that navigate to Project -> Compute -> Instances and select <strong>Associate Floating IP</strong> from the Actions drop-down menu.</p>

<p>The final steps is to allow remote SSH access. Each new VM inherits ACLs from a default security group. So the easiest way to allow SSH is to go to Project -> Compute -> Access &amp; Security and add a rule to allow inbound SSH connections for the default security group.</p>

<h2>Verification</h2>

<p>At this stage you should be able to SSH into the floating IP addresses assigned to the two new VMs using the default credentials. Feel free to poke around and explore Horizon&rsquo;s interface a bit more. For example, try setting up an SSH key pair and re-build our two VMs to allow passwordless SSH access.</p>

<h2>What to expect next</h2>

<p>In the next post we&rsquo;ll explore some of the basic concepts of OpenStack&rsquo;s SDN. We&rsquo;ll peak inside the internal implementation of virtual networks and see what are some of their limitations and drawbacks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openstack on UNetlab]]></title>
    <link href="http://networkop.github.io/blog/2016/04/04/openstack-unl/"/>
    <updated>2016-04-04T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2016/04/04/openstack-unl</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;m going to show how to get a running instance of Openstack inside a UNetLab virtual machine.</p>

<!--more-->


<p><img class="center" src="http://networkop.github.io/images/unl-os.png"></p>

<h2>What the hell am I trying to do?</h2>

<p>I admit that running Openstack on anything other than baremetal is nonsense. So why would anyone want to run it with two layers of virtualisation underneath? My goal is to explore some of the new SDN/NFV technologies without leaving the confines on my home area network and/or racking up a triple-digit electricity bill. I also wanted to be able to swap underlay networks without spending hours trying to plumb together virtualized switches and servers from multiple vendors. That&rsquo;s why I&rsquo;ve decided to use UNetLab VM as a host for my Openstack lab. This would allow me to easily assemble any type of underlay, WAN or DCI network and with hardware virtualisation support I can afford to run Openstack double-nested inside Workstation and Qemu on my dual-core i7 without too much of a performance penalty. After all, <a href="https://www.ravellosystems.com/technology/hvx">some companies</a> even managed to turn similar things into a commercial product.</p>

<p>My interest in Openstack is strictly limited by networking, that&rsquo;s why a lot of the things you&rsquo;ll see in this and following posts will not be applicable to a real-life production environment. However, as far as networking is concerned, I&rsquo;ll try to stick as close to the official Openstack <a href="http://docs.openstack.org/openstack-ops/content/example_architecture.html">network design</a> as possible. I&rsquo;ll be using <a href="https://www.rdoproject.org">RDO</a> to deploy Openstack. The specific method will be Packstack which is a collection of Puppet modules used to deploy Openstack components.</p>

<p>Why have I not went the OpenDaylight/Mininet way if I wanted to play with SDN/NFV? Because I wanted something more realistic to play with, that wouldn&rsquo;t feel like vendor&rsquo;s powerpoint presentation. Plus there&rsquo;s plenty of resources on the &lsquo;net about it anyway.</p>

<p>So, without further ado, let&rsquo;s get cracking.</p>

<h2>Setting the scene</h2>

<p>On my Windows 8 laptop I&rsquo;ve got a UNL virtual machine running inside a VMWare Workstation.. I&rsquo;ve <a href="http://www.unetlab.com/download/">downloaded</a> and <a href="http://www.unetlab.com/2014/11/upgrade-unetlab-installation/">upgraded</a> a pre-built UNL VM image. I&rsquo;ve also downloaded a copy of the <a href="http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1511.iso">Centos 7 minimal ISO image</a> and copied it over to my UNL VM&rsquo;s home directory.</p>

<p>For network access I&rsquo;ll be using VMWware Workstation&rsquo;s NAT interface. It&rsquo;s currently configured with <code>192.168.91.0/24</code> subnet with DHCP range of <code>.128-.254</code>. Therefore I&rsquo;ll be using <code>.10-.126</code> to allocate IPs to my Openstack servers.</p>

<h2>Creating a custom node type in UNL</h2>

<p>Every node type inside UNL has its own unique settings. Some settings, like amount of RAM, CPU or number of network interfaces, can be changed during node instantiation, while some of them remain &ldquo;baked in&rdquo;. Say, for example, the default &ldquo;Linux&rdquo; template creates nodes with default <strong>Qemu Virtual CPU</strong> which doesn&rsquo;t support the hardware virtualisation (<strong>VT-X/AMD-V</strong>) <a href="http://docs.openstack.org/liberty/config-reference/content/kvm.html">required</a> by Openstack. In order to change that you can either edit the existing node template or follow these steps to create a new one:</p>

<ol>
<li><p>Add Openstack node definition to initialization file <code>/opt/unetlab/html/includes/init.php</code>.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'>    <span class="s1">&#39;linux&#39;</span>                 <span class="o">=&gt;</span>      <span class="s1">&#39;Linux&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s1">&#39;openstack&#39;</span>             <span class="o">=&gt;</span>      <span class="s1">&#39;Openstack&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s1">&#39;mikrotik&#39;</span>              <span class="o">=&gt;</span>      <span class="s1">&#39;MikroTik RouterOS&#39;</span><span class="p">,</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create a new Openstack node template based on existing linux node template.</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>cp /opt/unetlab/html/templates/linux.php /opt/unetlab/html/templates/openstack.php
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Edit the template file replacing all occurences of &lsquo;Linux&rsquo; with &lsquo;Openstack&rsquo;</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>sed -i <span class="s1">&#39;s/Linux/Openstack/g; s/linux/openstack/g&#39;</span> /opt/unetlab/html/templates/openstack.php
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Edit the template file to double the RAM and CPU and pass all host&rsquo;s CPU instructions to Openstack nodes</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>sed -i <span class="s1">&#39;s/2048/4096/; s/(cpu.*) = 1/\1 = 2/; s/(order=)dc/\1cd -cpu host/&#39;</span> /opt/unetlab/html/templates/openstack.php
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
</ol>


<p>At this point you should be able to navigate to UNL&rsquo;s web interface and find a new node of type Openstack. However you won&rsquo;t be able to create it until you have at least one image, which is what we&rsquo;re going to build next.</p>

<h2>Building a Linux VM inside UNetLab</h2>

<p>Now we need to create a CentOS image inside a UNL. One way to do it is build it inside a VMWare Workstation, copy it to UNL and convert the <strong>.vmdk</strong> to <strong>.qcow2</strong>. However, when I tried doing this I ran into a problem with CentOS not finding the correct disk partitions during bootup. The workaround was to boot into rescue mode and rebuild the initramfs. For those feeling adventurous, I would recommend checking out the following links [<a href="https://wiki.centos.org/TipsAndTricks/CreateNewInitrd">1</a>, <a href="http://advancelinux.blogspot.com.au/2013/06/how-to-rebuild-initrd-or-initramfs-in.html">2</a>, <a href="http://forums.fedoraforum.org/showthread.php?t=288020">3</a>] before trying this option.<br/>
The other option is to build CentOS inside UNL from scratch. This is how you can do it:</p>

<ol>
<li><p>Create a new directory for Openstack image</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>mkdir -p /opt/unetlab/addons/qemu/openstack-1
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create a link to CentOS ISO boot image from our new directory</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>ln -s ~/CentOS-7-x86_64-Minimal-1511.iso /opt/unetlab/addons/qemu/openstack-1/cdrom.iso
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create a blank 6Gb disk image</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>   <span class="nv">$ </span>/opt/qemu/bin/qemu-img create -f qcow2 -o <span class="nv">preallocation</span><span class="o">=</span>metadata /opt/unetlab/addons/qemu/openstack-1/virtioa.qcow2 6G
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p> If you want to create <strong>snapshots</strong> at any stage of the process you&rsquo;d need to use a copy of this file under /opt/unetlab/tmp/pod_id/lab_uuid/node_id/ directory</p></li>
</ol>


<p>Now you should be able to successfully create an Openstack node and connect it to Internet. Create a new network that would have Internet connectivity (in my case it&rsquo;s <strong>pnet0</strong>) and connect it to Openstack&rsquo;s <strong>eth0</strong>.  At this stage we have everything ready to start installing Openstack, but before we move on let me take a quick detour to tell you about my ordeals with VNC integration.</p>

<h2>Optional: Integrating TightVNC with UNL</h2>

<p>For some unknown reason UltraVNC does not work well on my laptop. My sessions would often crash or start minimised with the only option to close the window. That&rsquo;s not the only thing not working properly on my laptop thanks to the corporate policies with half of the sh*t locked down for <em>security</em> reasons.<br/>
So instead of mucking around with <strong>Ultra</strong> I decided to give me old pal <strong>Tight</strong>VNC a go. The setup process is very similar to the <a href="http://www.unetlab.com/2015/03/url-telnet-ssh-vnc-integration-on-windows/">official VNC integration guide</a> with the following exceptions:</p>

<ol>
<li><p>The wrapper file simply strips the leading &lsquo;vnc://&rsquo; and trailing &lsquo;/&rsquo; off the passed argument</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='winbatch'><span class='line'>   <span class="k">SET</span> <span class="nv">arg</span><span class="o">=</span><span class="nv">%1</span>
</span><span class='line'>   <span class="k">SET</span> <span class="nv">arg</span><span class="o">=</span><span class="nv">%arg:~6%</span>
</span><span class='line'>   <span class="k">SET</span> <span class="nv">arg</span><span class="o">=</span><span class="nv">%arg:~0</span><span class="p">,</span><span class="m">-1</span>%
</span><span class='line'>   start <span class="s2">&quot;&quot;</span> <span class="s2">&quot;c:\Program Files\TightVNC\tvnviewer.exe&quot;</span> <span class="nv">%arg%</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>The registry entry now points to the TightVNC wrapper</p>

<p><figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='registry'><span class='line'>   <span class="k">[</span><span class="nb">HKEY_CLASSES_ROOT</span><span class="k">\vnc\shell\open\command]</span>
</span><span class='line'>   <span class="na">@</span><span class="o">=</span><span class="s">&quot;\&quot;c:\Program Files\TightVNC\wrapper.bat\&quot; %1&quot;</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
</ol>


<h2>Installing CentOS and Openstack</h2>

<p>Finally, we&rsquo;ve got all our ducks lined up in a row and we&rsquo;re ready to shoot. Fire up the Openstack node inside UNL and click on it to open a vnc session. Proceed to install CentOS with default options. You need to confirm which <strong>hard disk</strong> to use and setup the <strong>hostname</strong> and the <strong>root password</strong> during installation process.
As I mentioned earlier, we&rsquo;ll be using RDO&rsquo;s Packstack to deploy all the necessary Openstack components. The whole installation process will be quite simple and can be found on the RDO&rsquo;s <a href="https://www.rdoproject.org/install/quickstart/">quickstart page</a>. Here is my slightly modified version of installation process:</p>

<ol>
<li><p>Disable Network Manager and SELinux.</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>service NetworkManager stop
</span><span class='line'>    <span class="nv">$ </span>systemctl disable NetworkManager.service
</span><span class='line'>    <span class="nv">$ </span>setenforce 0
</span><span class='line'>    <span class="nv">$ </span>sed -i <span class="s1">&#39;s/enforcing/permissive/&#39;</span> /etc/selinux/config
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Configure static IP address <code>192.168.91.10</code> on the network interface. <br/>
 Assuming your interface name is <code>eth0</code> make sure you /etc/sysconfig/network-scripts/ifcfg-eth0 looks something like this:</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">TYPE</span><span class="o">=</span><span class="s2">&quot;Ethernet&quot;</span>
</span><span class='line'>    <span class="nv">BOOTPROTO</span><span class="o">=</span><span class="s2">&quot;static&quot;</span>
</span><span class='line'>    <span class="nv">IPADDR</span><span class="o">=</span>192.168.91.10
</span><span class='line'>    <span class="nv">PREFIX</span><span class="o">=</span>24
</span><span class='line'>    <span class="nv">GATEWAY</span><span class="o">=</span>192.168.91.2
</span><span class='line'>    <span class="nv">DNS1</span><span class="o">=</span>192.168.91.2
</span><span class='line'>    <span class="nv">NAME</span><span class="o">=</span><span class="s2">&quot;eth0&quot;</span>
</span><span class='line'>    <span class="nv">DEVICE</span><span class="o">=</span><span class="s2">&quot;eth0&quot;</span>
</span><span class='line'>    <span class="nv">ONBOOT</span><span class="o">=</span><span class="s2">&quot;yes&quot;</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  Issue a <code>service network restart</code> and reconnect to the new static IP address. Make sure that you still have access to Internet after making this change.</p></li>
<li><p>Setup RDO repositories</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>sudo yum install -y <a href="https://rdoproject.org/repos/rdo-release.rpm">https://rdoproject.org/repos/rdo-release.rpm</a>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Update your current packages</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>sudo yum update -y
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Install Packstack</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>sudo yum install -y openstack-packstack
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  That&rsquo;s where it&rsquo;d make sense to take a snapshot with <code>qemu-img snapshot -c pre-install virtioa.qcow2</code> command</p></li>
<li><p>Deploy a single-node Openstack environment</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span>packstack <span class="se">-</span>-allinone <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-cinder-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-ceilometer-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-trove-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-ironic-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-nagios-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-swift-install<span class="o">=</span>n <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-neutron-ovs-bridge-mappings<span class="o">=</span>extnet:br-ex <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-neutron-ovs-bridge-interfaces<span class="o">=</span>br-ex:eth0 <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-os-neutron-ml2-type-drivers<span class="o">=</span>vxlan,flat <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-provision-demo<span class="o">=</span>n
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  Here we&rsquo;re overriding some of the default Packstack options. We&rsquo;re not installing some of the components we&rsquo;re not going to use and setting up a name (<strong>extnet</strong>) for our external physical segment, which we&rsquo;ll use in the next section.</p></li>
</ol>


<p>At the end of these 4 steps you should be able to navigate to Horizon (Openstack&rsquo;s dashboard) by typing <code>http://192.168.91.10</code> in your browser. You can find login credentials in the <code>~/keystonerc_admin</code> file.</p>

<h2>Configuring Openstack networking</h2>

<p>At this stage we need to setup virtual networking infrastructure inside Openstack. This will be almost the same as described in RDO&rsquo;s external network <a href="https://www.rdoproject.org/networking/neutron-with-existing-external-network/">setup guide</a>. The only exceptions will be the <a href="https://www.rdoproject.org/networking/difference-between-floating-ip-and-private-ip/">floating IP range</a>, which will match our existing environment, and the fact that we&rsquo;re no going to setup any additional tenants yet. This is how our topology will look like:</p>

<p><img class="center" src="http://networkop.github.io/images/os-net-1.png"></p>

<ol>
<li><p>Switch to Openstack&rsquo;s <code>admin</code> user
 <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    <span class="nv">$ </span><span class="nb">source</span> ~/keystonerc_admin
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create external network
 <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    neutron net-create external_network <span class="se">-</span>-provider:network_type flat <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-provider:physical_network extnet  <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-router:external <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-shared
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>Create a public subnet</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    neutron subnet-create <span class="se">-</span>-name public_subnet <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-enable_dhcp<span class="o">=</span>False <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-allocation-pool<span class="o">=</span><span class="nv">start</span><span class="o">=</span>192.168.91.90,end<span class="o">=</span>192.168.91.126 <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-gateway<span class="o">=</span>192.168.91.2 external_network 192.168.91.0/24
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>  Default gateway is VMware&rsquo;s NAT IP address</p></li>
<li><p>Create a private network and subnet</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    neutron net-create private_network
</span><span class='line'>    neutron subnet-create <span class="se">-</span>-name private_subnet private_network 10.0.0.0/24 <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-dns-nameserver 8.8.8.8
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p>

<p>   This network is not routable outside of Openstack and is used for inter-VM communication</p></li>
<li><p>Create a virtual router and attach it to both networks</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    neutron router-create router
</span><span class='line'>    neutron router-gateway-set router external_network
</span><span class='line'>    neutron router-interface-add router private_subnet
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
</ol>


<p>Make sure to check out the visualisation of our newly created network topology in Horizon, it&rsquo;s amazing.</p>

<h2>Spinning up a VM</h2>

<p>There&rsquo;s no point in installing Openstack just for the sake of it. Our final step would be to create a working virtual machine that would be able to connect to Internet.</p>

<ol>
<li><p>Download a test linux image</p>

<p> <figure class='code panel panel-default'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>    curl <a href="http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img">http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img</a> <span class="p">|</span> glance <span class="se">\</span>
</span><span class='line'>    image-create <span class="se">-</span>-name<span class="o">=</span><span class="s1">&#39;cirros image&#39;</span> <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-visibility<span class="o">=</span>public <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-container-format<span class="o">=</span>bare <span class="se">\</span>
</span><span class='line'>    <span class="se">-</span>-disk-format<span class="o">=</span>qcow2
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>From Horizon&rsquo;s home page navigate to Project -> Compute -> Images.</p></li>
<li><p>Click on <code>Launch Instance</code> and give the new VM a name.</p></li>
<li><p>Make sure it&rsquo;s attached to <code>private_network</code> under the Networking tab.</p></li>
<li><p>Less then a minute later the status should change to <code>Active</code> and you can navigate to VM&rsquo;s console by clicking on its name and going to <code>Console</code> tab.</p></li>
<li><p>Login using the default credentials (<strong>cirros/cubswin:)</strong>) and verify Internet access by pinging google.com.</p></li>
</ol>


<p>Congratulations, we have successfully created a VM running inside a KVM inside a KVM inside a VMWare Workstation inside Windows!</p>

<h2>What to expect next</h2>

<p>Unlike my other post series, I don&rsquo;t have a clear goal at this stage so I guess I&rsquo;ll continue playing around with different underlays for multi-node Openstack and then move on to various SDN solutions available like OpenDayLight and OpenContrail. Unless I lose interest half way through, which happened in the past. But until that happens, stay tuned for more.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network-CI Part 3 - OSPF to BGP Migration in Active/Standby DC]]></title>
    <link href="http://networkop.github.io/blog/2016/03/23/network-ci-demo-large/"/>
    <updated>2016-03-23T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2016/03/23/network-ci-demo-large</id>
    <content type="html"><![CDATA[<p>The final post in a series demonstrates how to use the <strong>network-ci</strong> tools to safely replace a core routing protocol inside a small Active/Standby Data Centre.</p>

<!--more-->


<h2>Current network overview</h2>

<p>Let&rsquo;s start by taking a high-level look at our DC network routing topology. The core routing protocol is OSPF, it is responsible for distributing routing information between the Core and WAN layers of the network. WAN layer consists of two MPLS L3VPN services running BGP as PE-CE protocol and two DMVPN Hubs running EIGRP. All WAN layer devices perform mutual redistribution between the respective WAN protocol and OSPF.</p>

<p><img class="center" src="http://networkop.github.io/images/network-ci-dc-before.png" title="Current network topology" ></p>

<h2>Target network overview</h2>

<p>The task is to replace OSPF with BGP as the core routing protocol inside the Data Centre. There are many advantages to using BGP inside a DC, in our case they are:</p>

<ul>
<li>Enhanced traffic routing and filtering policies</li>
<li>Reduced number of redistribution points</li>
<li>Because Ivan Pepelnjak <a href="http://blog.ipspace.net/2016/02/using-bgp-in-data-center-fabrics.html">said so</a></li>
</ul>


<p>We&rsquo;re not going getting rid of OSPF completely, but rather reduce its function to a simple distribution of <em>internal</em> DC prefixes. BGP will be running on top of OSPF and distribute all the DC and WAN <em>summary</em> prefixes.</p>

<p><img class="center" src="http://networkop.github.io/images/network-ci-dc-after.png" title="Target network topology" ></p>

<h2>Physical topology overview</h2>

<p>Now let&rsquo;s take a closer look at the network that we&rsquo;re going to emulate. All green devices on the left-hand side constitute the <strong>Active</strong> Data Centre, that is where all the traffic will flow under normal conditions. All green devices have red <strong>Standby</strong> counterparts. These devices will pick up the function of traffic forwarding in case their green peer becomes unavailable.</p>

<p><img class="center" src="http://networkop.github.io/images/network-ci-dc-full.png" title="Full demo topology" ></p>

<p>When simulating a real-life network it&rsquo;s often impossible to fit an exact replica inside a network emulator. That&rsquo;s why using <strong>mock</strong> devices is a crucial part in every simulation. The function of a mock is to approximate a set of network devices. There&rsquo;s a number of mock devices on our diagram colour-coded in purple. These devices simulate the remaining parts of the network. For example, <strong>Cloud</strong> devices may represent <abbr title=" Top-Of-the-Rack">TOR</abbr> switches, while <strong>MPLS/DMVPN</strong> devices represent remote WAN sites. Normally these devices will have some made-up configuration that best reflects real life, but not necessarily a copy-paste from an existing network device.</p>

<p>It&rsquo;s also important to pick the right amount of mock devices to strike the balance between accuracy and complexity. For example, for WAN sites it may suffice to create one site per unique combination of WAN links to make sure WAN failover works as expected.</p>

<h2>Traffic flow definition</h2>

<p>Let&rsquo;s define how we would expect the traffic to flow through our network. Let&rsquo;s assume that we should always try to use MPLS links when possible and only use DMVPN when both MPLS links are down. This translates to the following order of WAN links' precedence:</p>

<ol>
<li>Primary MPLS link</li>
<li>Standby MPLS link</li>
<li>Primary DMVPN link</li>
<li>Standby DMVPN link</li>
</ol>


<p>Based on that we can create the following traffic flows definition for network working under normal conditions.</p>

<figure class='code'><figcaption><span>/network/tests/traffic_flows.txt</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>1 Failed None
</span><span class='line'>  From FW to MPLS-DMVPN via Primary-WAN, Primary-MPLS
</span><span class='line'>  From FW to DMVPN-ONLY via Primary-CORE-SW, Primary-DMVPN
</span><span class='line'>  From FW to MPLS-ONLY via Primary-WAN, Primary-MPLS
</span><span class='line'>  From Cloud-1 to FW Loopback0 via Primary-CORE-SW
</span><span class='line'>  From Cloud-2 to MPLS-DMVPN via Primary-WAN, Primary-MPLS
</span></code></pre></td></tr></table></div></figure>


<p>We expect all traffic to flow through active devices even when the path may be suboptimal, like it&rsquo;s the case with traffic from Cloud-2. Similarly, we can create traffic flows definitions for different failure conditions. The complete <a href="https://github.com/networkop/network-ci/blob/master/acme-large/network/tests/traffic_flows.txt">traffic flows definition file</a> contains 2 additional failure scenarios covering the outage of the primary MPLS link and a complete outage of the primary core switch.</p>

<h2>Workflow example</h2>

<p>This is how you would approach a project like this.</p>

<ol>
<li>Get a copy of network-ci <a href="http://networkop.github.io/blog/2016/02/25/network-ci-dev-setup/">VM</a></li>
<li>Get a local copy of network-ci <a href="https://github.com/networkop/network-ci/tree/master/acme-large">tools</a></li>
<li>Copy configuration from real-life devices into the <a href="https://github.com/networkop/network-ci/tree/master/acme-large/config">config directory</a></li>
<li>Add configuration files for mock devices to the same directory</li>
<li>Review the <a href="https://github.com/networkop/network-ci/blob/master/acme-large/network/topology.py">topology definition file</a> to make sure it reflects our physical diagram</li>
<li>Review the UNL <a href="https://github.com/networkop/network-ci/blob/master/acme-large/network/unetlab.yml">configuration file</a> to make sure it points to the correct IP address assigned to your network-ci VM</li>
<li>Kick-off topology build inside UNL by running <code>./0_built_topo.py</code> script</li>
<li>Verify that traffic flows as expected with <code>2_test.py</code> script</li>
<li>Start the real-time monitoring with <code>1_monitor.py</code> script</li>
<li>Implement required changes on individual devices (all required changes can be found in <a href="https://github.com/networkop/network-ci/blob/master/acme-large/network/ospf-bgp.txt">ospf-bgp.txt</a> file)</li>
<li>Make sure that the network still behaves as before by running <code>2_test.py</code> script</li>
<li>Destroy the topology in UNL by running <code>3_destroy_topo.py</code></li>
</ol>


<h2>Continuous Integration</h2>

<p>In the <a href="http://networkop.github.io/blog/2016/03/03/network-ci-demo-small/">previous post</a> I&rsquo;ve showed how to use Jenkins to setup the CI environment for a small demo network. The same method can be applied to setup the job for our small Data Centre. It is simply a matter of changing the directory name from <strong>acme-small</strong> to <strong>acme-large</strong> in the first build step.</p>

<h2>Source code</h2>

<p>All code from this and previous posts is available on <a href="https://github.com/networkop/network-ci/tree/master/acme-large">Github</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network-CI Part 2 - Small Network Demo]]></title>
    <link href="http://networkop.github.io/blog/2016/03/03/network-ci-demo-small/"/>
    <updated>2016-03-03T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2016/03/03/network-ci-demo-small</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;ll demonstrate how to use the network-ci tools to automate the build, test and upgrade of a small 4-node network topology.</p>

<!--more-->


<h2>Demo network overview</h2>

<p>The network consists of 4 nodes interconnected via point-to-point links and running EIGRP as a routing protocol.</p>

<p><img class="center" src="http://networkop.github.io/images/ci-acme-small.jpg" title="Small demo topology" ></p>

<p>To create a local development environment you can clone my <a href="https://github.com/networkop/network-ci/tree/master/acme-small">repository</a> and reset it to work with your own Github account using <code>git remote set-url origin https://github.com/USERNAME/OTHERREPOSITORY.git</code> command.<br/>
Local development environment contains the following files describing the modelled topology:</p>

<ol>
<li>Configuration files for each node under the <code>./config</code> directory</li>
<li>Network topology in <code>./network/topology.py</code> modelled as a list of pairs of interconnected devices</li>
<li>UNetLab configuration file containing the IP address and username/passwords to access the server</li>
<li>Traffic flow test definitions under <code>./network/test</code> directory</li>
</ol>


<h2>Test definitions</h2>

<p>Traffic flow test file contains an ordered set of test scenarios that will be performed automatically. The following is an example that illustrates main capabilities of our test tools:</p>

<figure class='code'><figcaption><span>./network/tests/traffic_flows.txt</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>## Normal operations
</span><span class='line'>1 Failed None
</span><span class='line'>  From R1 to R3 via R2 or R4, R3
</span><span class='line'>  From R2 to R3 via R3
</span><span class='line'>  From R2 to R4 via R1 or R3
</span><span class='line'>
</span><span class='line'># Failed link between R1 and R2
</span><span class='line'>2 Failed R1 Gig1/1, R2 Gig0/0
</span><span class='line'>  From R1 to R2 via not R2, R3
</span><span class='line'>  From R2 to R4 via not R1, R4
</span></code></pre></td></tr></table></div></figure>


<p>Each scenario starts with a <strong>failure definition</strong>. It could be either <em>None</em>, which represents normal network conditions, or it could contain a list of interfaces that need to be failed. Following the failure definition are the actual tests. On each line we define source, destination and the path we expect the traffic to take. Path definition (everything following the &lsquo;via&rsquo; keyword) contains an ordered set of nodes and can use simple boolean operators like <strong>or</strong> or <strong>not</strong>.</p>

<p>Ping flow definition file is a lot shorter and simply contains a list of source/destination pairs to run a ping test between. All ping tests will execute concurrently and issue only 2 pings, therefore we&rsquo;ll only be able to detect connectivity loss if it lasts for more than 4 seconds.</p>

<h2>Jenkins setup</h2>

<p>In the previous post we&rsquo;ve automatically built a VM with Jenkins and UNetLab pre-installed. Before we can start using Jenkins we need to install a Github plugin, which can be done very easily from Jenkins GUI. Power up your <strong>vm-network-ci</strong> and open Jenkins home page at <code>http://VM_IP:8080</code>. From there navigate to <strong>Manage Jenkins -> Manage Plugins -> Available</strong>, search for and install the <strong>GitHub plugin</strong>.</p>

<h2>A quick Jenkins intro</h2>

<p>Inside Jenkins, <strong>a job</strong> represents a set of tasks that need to be automated for a particular project. Each job first waits for a trigger, which can be either a manual or an automatic event. When triggered, it connects to Github repository, downloads all the code to a local machine and executes a set of build steps defined in this job. A very simple workflow would looks like this:</p>

<ol>
<li>Developer commits and pushes a change to a Github repository</li>
<li>Github notifies Jenkins server by sending an HTTP POST request</li>
<li>Jenkins identifies the job that needs to be run and clones Github repo into a local directory</li>
<li>It then goes through and executes a set of build steps defined for this job</li>
<li>At the end you can optionally configure Jenkins to update the status of the build as described <a href="http://stackoverflow.com/questions/14274293/show-current-state-of-jenkins-build-on-github-repo">here</a></li>
</ol>


<h2>Using Jenkins for network testing</h2>

<ol>
<li>From Jenkins home page click on <strong>create new jobs</strong> and create a <em>Freestyle project</em> called <strong>acme-small</strong>.</li>
<li>Select the <strong>Github project</strong> option and enter a url of your Github repository (in my case its <a href="https://github.com/networkop/network-ci">https://github.com/networkop/network-ci</a>).</li>
<li>Under <strong>Source Code Management</strong> select <em>Git</em> and enter the same repository URL.</li>
<li>Under <strong>Additional Behaviours</strong> add a <em>Polling ignores commits in certain paths</em>. <br/>
Since I&rsquo;m keeping multiple subprojects in the same Github repo, I need to make sure that this job is only triggered if commit affected a particular directory.</li>
<li>Under <strong>Included Regions</strong> add <code>acme-small/.*</code> to only trigger builds for changes made to <strong>acme-small</strong> directory.</li>
<li>Optionally you can specify the build triggers to either build periodically or wait for changes to be pushed to Github.</li>
<li><p>Under <strong>Build</strong> add a new build step with the following shell commands:</p>

<pre><code class="`bash"> export UNL_IP="unl_ip_address"
 export PYTHONUNBUFFERED=1
 cd acme-small
 chmod +x 0_built_topo.py
 chmod +x 2_test.py
 chmod +x 3_destroy_topo.py
 ./0_built_topo.py
 ./2_test.py
 ./3_destroy_topo.py
</code></pre>

<p>The first two env variables setup the UNL&rsquo;s IP address of and disable IO buffering so that we can see the output produced by our scripts in real time. The remaining steps simply execute the build, test and destroy scripts in order.</p></li>
<li><p>Save the job and click on the <strong>Build Now</strong> to trigger the build manually.</p></li>
<li>In the <strong>Build History</strong> pane click on the latest build number (should be #1) and go to <em>Console Output</em>.</li>
<li>Observe how Jenkins builds, tests and destroys our demo topology</li>
</ol>


<h2>Network upgrade workflow</h2>

<p>Now imagine that a new requirements has come in to make sure that traffic from R1 to R3&rsquo;s Gig0/1 does not traverse R4 and goes via R2 instead, only falling back to R4 when R1-R2 link is down. In the following video I&rsquo;ll show how to use network-ci tools locally to implement and test this traffic engineering requirement.</p>

<div class="embed-video-container"><iframe src="//www.youtube.com/embed/GLOG9KZzP90" allowfullscreen></iframe></div>


<h2>Coming up</h2>

<p>In the next post I&rsquo;ll show how to apply the same workflow to automate the build, test and ugprade of a large 14-node topology.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network-CI Part 1 - Automatically Building a VM With UNetLab and Jenkins]]></title>
    <link href="http://networkop.github.io/blog/2016/02/25/network-ci-dev-setup/"/>
    <updated>2016-02-25T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2016/02/25/network-ci-dev-setup</id>
    <content type="html"><![CDATA[<p>Traditionally, the first post in the series describes how to setup a development environment. This time I&rsquo;ll do it DevOps-style. I&rsquo;ll show how to use Packer to automatically create and configure a VM with UNetLab and Jenkins pre-installed.</p>

<!--more-->


<p><img class="center" src="http://networkop.github.io/images/packer-unl-jenkins.png" title="Packer-UNL-Jenkins" ></p>

<h2>Packer intro</h2>

<p><a href="https://www.packer.io/">Packer</a> is a tool that can automatically create virtual machines for different hypervisors and cloud platforms. The goal is to produce identically configured VMs for either VirtualBox, VMWare, Amazon or Google clouds based on a single template file. If you&rsquo;re familiar with <a href="https://www.vagrantup.com/docs/">Vagrant</a>, then you can also use Packer to create custom Vagrant boxes. In our case, however, we&rsquo;re only concerned about VMWare since it&rsquo;s the only <a href="https://en.wikipedia.org/wiki/Hypervisor">type-2 hypervisor</a> that supports nested hardware virtualisation (e.g. Intel VT-x), a feature required by UNetLab to run some of the emulated images.</p>

<p>Packer builds VMs using a special template file. At the very least, this file describes how to:</p>

<ul>
<li><p>Build a VM</p></li>
<li><p>Provision and configure apps on a VM</p></li>
</ul>


<p>These two actions correspond to the <code>builders</code> and <code>provisioners</code> sections of the template file.</p>

<p>The <code>builders</code> section contains a set of instructions for a particular hypervisor or platform on how to build a VM. For example, it might contain the amount of  RAM, CPU and disk sizes, number and type of interfaces, OS boot instructions and so on.</p>

<p>The <code>provisioners</code> section contains a set of instructions to configure a VM. This section may be as simple as a list of shell scripts or may include a reference to Ansible playbook which will be executed after the VM is built.</p>

<p>You can find my Packer templates along with Ubuntu preseed and provisioner scripts in my <a href="https://github.com/networkop/packer-unl-jenkins">Gihub repository</a>. For those looking for deeper insights about how to build a packer template I can recommend an official Packer <a href="https://www.packer.io/intro/index.html">introduction docs</a>.</p>

<h2>Building a VM with Packer</h2>

<p>As I&rsquo;ve mentioned previously, I&rsquo;m using Windows as my primary development environment and VMWare Workstation as my hypervisor. Before you begin you also need to have <a href="https://www.packer.io/intro/getting-started/setup.html">Packer</a> and <a href="https://git-scm.com/download/win">git</a> installed.</p>

<figure class='code'><figcaption><span>1. Clone git repository</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='winbatch'><span class='line'>git clone https:<span class="n">//github.com/networkop/packer-unl-jenkins</span>
</span><span class='line'><span class="k">cd</span> packer-unl-jenkins
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>2. Start the build</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='winbatch'><span class='line'>packer build vmware.json
</span></code></pre></td></tr></table></div></figure>


<p>With a bit of luck, approximately 30 minutes later you should have a fully configured VM inside your VMWare Workstation waiting to be powered on. These are some of the features of this new VM:</p>

<ul>
<li>4 GB of RAM, 20GB of disk space, 2 dual-core vCPUs</li>
<li>1 Host-only and 1 NAT ethernet interfaces both using DHCP</li>
<li>Jenkins and UNetLab installed</li>
<li>Git and Python PIP packages installed</li>
<li>Username/password are <code>unl/admin</code></li>
</ul>


<p>Once powered on, you should be able to navigate to UNetLab&rsquo;s home page at <code>http://vm_ip:80</code> and Jenkins' home page and <code>http://vm_ip:8080</code>, where <code>vm_ip</code> is the IP of your new VM.</p>

<h2>IOU images</h2>

<p>Unfortunately IOU images are not publicly available so you&rsquo;re gonna have to find them yourself, which shouldn&rsquo;t be too hard. You&rsquo;ll also need to generate a license file for these images which, again, I&rsquo;m not going to discuss in this blog, but I can guarantee that you won&rsquo;t have to look farther than the 1st page of Google search to find all your answers. These are the remaining steps that you need to do:</p>

<ol>
<li>Obtain L2 and L3 IOU images</li>
<li>Generate a license file</li>
<li>Follow <a href="http://www.unetlab.com/2014/11/adding-cisco-iouiol-images/">these instructions</a> to install those images on the UNetLab server</li>
</ol>


<h2>non-DevOps way</h2>

<p>In case you&rsquo;re struggling with Packer here are the list of steps to setup a similar VM manually:</p>

<ol>
<li><a href="http://www.ubuntu.com/download/server">Download</a> your favourite Ubuntu Server image. Recommended release at the time of writing is 14.04.4.</li>
<li>Create a VM with at least 4GB of RAM, VT-x support and boot it off the Ubuntu ISO image.</li>
<li>Following instructions <a href="http://www.unetlab.com/2015/08/installing-unetlab-on-a-physical-server/">install Ubuntu and UNetLab</a>.</li>
<li>Install Jenkins as described on <a href="https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+on+Ubuntu">their wiki website</a></li>
<li>Install additional packages like git and pip. Refer to my Packer <a href="https://github.com/networkop/packer-unl-jenkins/blob/master/scripts/packages.sh">packages script</a> for commands.</li>
</ol>


<h2>Coming up</h2>

<p>In the next post I&rsquo;ll show how to setup Jenkins to do automatic network testing and verification.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Network Continuous Integration and Delivery]]></title>
    <link href="http://networkop.github.io/blog/2016/02/19/network-ci-intro/"/>
    <updated>2016-02-19T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2016/02/19/network-ci-intro</id>
    <content type="html"><![CDATA[<p>In this series of posts I&rsquo;ll introduce the tools I&rsquo;ve been using for continuous network development and how they can be used with automation servers like Jenkins for network continuous integration and delivery.</p>

<!--more-->


<h2>CI/CD vs ITIL</h2>

<p>How do you implement changes in your network? In today&rsquo;s world there&rsquo;s 95% chance that you have to write up an <abbr title=" Request For Change">RFC</abbr>, submit it at least a week before the planned implementation date, go through at least one <abbr title=" Change Admission Board">CAB</abbr> meeting and only then, assuming it got approved, can you implement it. But the most important question is &lsquo;how do you test&rsquo;? Do you simply content yourself with a few pings or do you make sure all main routes are in place? And how often do you get a call the next morning from a very nervous client asking you to &lsquo;please have a look at the network performance issues&rsquo;?</p>

<p>Software developers have solved most of these problems for themselves. DevOps movement has brought forth ideas of Continuous Integration and Delivery (CI/CD) to streamline the change process and &lsquo;embrace&rsquo; the change rather than protect against it. But how applicable are those ideas to the networks of today? Can we simply rip and replace our CAB meetings with a Jenkins server and live happily ever after?  As always, things are getting difficult as you move down from Layer 7.</p>

<h2>Problem #1 - How to test</h2>

<p>Ever since the dawn of networking, the only tools that engineers could use for testing were traceroutes and pings. It&rsquo;s not necessarily bad since, after all, networks are supposed to be a simple packet transports and shouldn&rsquo;t be endowed with application-layer knowledge. Note that I&rsquo;m talking about traditional or, in SDN-era terms, &lsquo;underlay&rsquo; networks. The biggest problem with network testability is not the lack of test tools but rather lack of automation. For every ping and every traceroute we had to login a device, carefully craft the command including source interface names, VRFs and other various options and then interpret the output.<br/>
I have already explored the idea of automated network testing in my previous blog posts - <a href="http://networkop.github.io/blog/2015/06/15/simple-tdd-framework/">Building Network TDD framework</a> and <a href="http://networkop.github.io/blog/2015/07/17/tdd-quickstart/">Network TDD quickstart</a>. I even got lucky enough to get invited to one of the <a href="http://blog.ipspace.net/2015/11/test-driven-network-development-with.html">greatest networking podcasts</a> hosted by Ivan Pepelnjak.</p>

<h2>Problem #2 - Where to test</h2>

<p>Another big problem is the lack of testable network software. We&rsquo;ve only had IOU, vSRX and vEOS for the past 3-4 years and even now a lot of the real-world functionality remains unvirtualizable. However having those images is a lot better than not, even though some of them tend to crash and behave unreliably from time to time.</p>

<h2>Network CI</h2>

<p>Here I&rsquo;ve come to the actual gist of my post. I want to demonstrate the tools that I&rsquo;ve built and how I use them to automate a lot of the repetitive tasks to prepare for network deployments and upgrades. This is what these tools can do:</p>

<ul>
<li>Create a replica of almost any real-world network topology inside a network emulation environment</li>
<li>Apply configuration to all built devices</li>
<li>Verify real-time connectivity between nodes</li>
<li>Verify traffic flows under various failure conditions against pre-defined set rules</li>
<li>Shutdown and delete the network topology</li>
</ul>


<p>All these steps can be done automatically without making a single click in a GUI or entering a single command in a CLI. This is a sneak peak of what to expect later in the series:</p>

<div class="embed-video-container"><iframe src="//www.youtube.com/embed/jiZs0969RWI" allowfullscreen></iframe></div>


<p>Please don&rsquo;t judge me too harshly, this is my first experience with screencasts.</p>

<h2>Coming up</h2>

<p>In the following posts I&rsquo;ll show how to:</p>

<ul>
<li><a href="http://networkop.github.io/blog/2016/02/25/network-ci-dev-setup/">Setup continuous delivery environment with Jenkins and UNetLab</a></li>
<li><a href="http://networkop.github.io/blog/2016/03/03/network-ci-demo-small/">Create test cases to enable automatic testing by Jenkins server</a></li>
<li><a href="http://networkop.github.io/blog/2016/03/03/network-ci-demo-large/">Safely replace a core routing protocol inside an Active/Standby DC</a></li>
</ul>


<p>If that sounds interesting to you - stay tuned.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[REST for Network Engineers Part 3 - Advanced Operations With UnetLab]]></title>
    <link href="http://networkop.github.io/blog/2016/01/17/rest-unl-advanced/"/>
    <updated>2016-01-17T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2016/01/17/rest-unl-advanced</id>
    <content type="html"><![CDATA[<p>In this post we&rsquo;ll look at how to create arbitrary topologies and push configuration to Nodes in UNetlab via REST SDK. We&rsquo;ll conclude by extending our sample application to create and configure a 3-node topology and enable full connectivity between all nodes.</p>

<!--more-->


<h2>Extracting Node&rsquo;s UUID</h2>

<p>In the <a href="http://networkop.github.io/blog/2016/01/06/rest-basic-operations/">previous post</a> we have learned how to create a Node. To perform further actions on it we need to know it&rsquo;s UUID. According to HTTP specification <code>201 - Created</code> response SHOULD return a <code>Location</code> header with resource URI, which would contain resource UUID. However, UNetLab&rsquo;s implementation does not return a Location header so we need to extract that information ourselves. To do that we&rsquo;ll use the previously defined <code>.get_nodes()</code> method which returns all attributes of all configured Nodes in the following format:</p>

<p><img class="centre" src="http://networkop.github.io/images/rest-unl-get-nodes.png" title="REST SDK GET ALL NODES" ></p>

<p>The best place to extract UUID would be when Node is being created. After the <code>Create</code> request has been sent to a server we&rsquo;ll send another <code>Read</code> request and extract all attributes of a Node based on its name.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">UnlNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lab</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
</span><span class='line'>      <span class="o">...</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="s">&#39;url&#39;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">_get_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s">&#39;data&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">get_obj_by_name</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p> To extract data from the payload we need to call <code>.json()</code> on the returned HTTP response and look for the <code>data</code> key inside that JSON object. The returned value will contain all attributes including the UUID and access URL which we&rsquo;ll use later. To help us find a Node object matching a name we&rsquo;ll use a helper function defined below:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/helper.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">get_obj_by_name</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">obj_id</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">objects</span><span class="p">[</span><span class="n">obj_id</span><span class="p">][</span><span class="s">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">objects</span><span class="p">[</span><span class="n">obj_id</span><span class="p">]</span>
</span><span class='line'>    <span class="k">return</span> <span class="bp">None</span>
</span></code></pre></td></tr></table></div></figure>


<p>Needless to say that we MUST have unique names for all nodes otherwise it won&rsquo;t be possible to do the matching. It&rsquo;s quite a safe assumption to make in most cases however no built-in error checking will be performed by the REST SDK to prevent you from doing it.</p>

<h2>UnlNet implementation</h2>

<p>Before we start connecting Nodes together we need to create a Network. As per the <a href="http://networkop.github.io/blog/2016/01/06/rest-basic-operations/">design</a>, UnlNet will be a class holding a pointer to the UnlLab object which created it. The structure of the class will be very similar to UnlNode.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">REST_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>              <span class="o">...</span> <span class="p">,</span>
</span><span class='line'>              <span class="s">&#39;create_net&#39;</span><span class="p">:</span> <span class="s">&#39;/labs/{lab_name}/networks&#39;</span><span class="p">,</span>
</span><span class='line'>              <span class="s">&#39;get_nets&#39;</span><span class="p">:</span> <span class="s">&#39;/labs/{lab_name}/networks&#39;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlLab</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">create_net</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UnlNet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">get_nets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;get_nets&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">api_url</span> <span class="o">=</span> <span class="n">api_call</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">api_call</span><span class="p">,</span> <span class="n">lab_name</span><span class="o">=</span><span class="n">append_unl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">api_url</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlNet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lab</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;create_net&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">unl</span><span class="p">,</span> <span class="n">lab</span><span class="p">,</span> <span class="n">name</span>
</span><span class='line'>        <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;type&#39;</span><span class="p">:</span> <span class="s">&#39;bridge&#39;</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>
</span><span class='line'>        <span class="n">api_url</span> <span class="o">=</span> <span class="n">api_call</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">api_call</span><span class="p">,</span> <span class="n">lab_name</span><span class="o">=</span><span class="n">append_unl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="n">api_url</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_net</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net</span><span class="p">[</span><span class="s">&#39;id&#39;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">_get_net</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">nets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">get_nets</span><span class="p">()</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s">&#39;data&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">get_obj_by_name</span><span class="p">(</span><span class="n">nets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Connecting Nodes to a network</h2>

<p>Official <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/">Unetlab API guide</a> is still under development and doesn&rsquo;t specify how to connect a Node to a network. If you want to find out the syntax for this or any other unspecified API call you can always try that in a Web GUI while capturing traffic with Wireshark. That is how I&rsquo;ve discovered that to connect a Node to a network we need to send an Update request with payload containing mapping between Node&rsquo;s interface ID and Network ID.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">REST_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>                <span class="o">...</span> <span class="p">,</span>
</span><span class='line'>                <span class="s">&#39;connect_interface&#39;</span><span class="p">:</span> <span class="s">&#39;/labs/{lab_name}/nodes/{node_id}/interfaces&#39;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">connect_interface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intf_name</span><span class="p">,</span> <span class="n">net</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;connect_interface&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">api_url</span> <span class="o">=</span> <span class="n">api_call</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">api_call</span><span class="p">,</span> <span class="n">lab_name</span><span class="o">=</span><span class="n">append_unl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">node_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</span><span class='line'>        <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="n">get_intf_id</span><span class="p">(</span><span class="n">intf_name</span><span class="p">):</span> <span class="n">net</span><span class="o">.</span><span class="n">id</span><span class="p">}</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">update_object</span><span class="p">(</span><span class="n">api_url</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span></code></pre></td></tr></table></div></figure>


<p>The ID of an interface &ldquo;Ethernet x/y” of an IOU device can be easily calculated based on the formula <code>id = x + (y * 16)</code> as described <a href="http://evilrouters.net/2011/01/09/creating-a-netmap-file-for-iou/">here</a>. This will be accomplished with yet another helper function:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/helper.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">get_intf_id</span><span class="p">(</span><span class="n">intf_name</span><span class="p">):</span>
</span><span class='line'>    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">&#39;\d+&#39;</span><span class="p">,</span> <span class="n">intf_name</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Connecting Nodes to each other</h2>

<p>To create multi-access topologies we would need to maintain an internal mapping between Node&rsquo;s interface and the network it&rsquo;s attached to. However, if we assume that all links are point-to-point, we can not only simplify our implementation but also enable REST client to ignore the notion of a network all together.  We&rsquo;ll simply assume that when device A connects to B our implementation will create a network called <code>A_B</code> in the background and connect both devices to it. This method will perform two separate REST calls and thus will return both responses in a tuple:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">UnlNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">connect_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">local_intf</span><span class="p">,</span> <span class="n">other_node</span><span class="p">,</span> <span class="n">other_intf</span><span class="p">):</span>
</span><span class='line'>    <span class="n">net</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">create_net</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">other_node</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">name</span><span class="p">]))</span>
</span><span class='line'>    <span class="n">resp1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_interface</span><span class="p">(</span><span class="n">local_intf</span><span class="p">,</span> <span class="n">net</span><span class="p">)</span>
</span><span class='line'>    <span class="n">resp2</span> <span class="o">=</span> <span class="n">other_node</span><span class="o">.</span><span class="n">connect_interface</span><span class="p">(</span><span class="n">other_intf</span><span class="p">,</span> <span class="n">net</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">resp1</span><span class="p">,</span> <span class="n">resp2</span>
</span></code></pre></td></tr></table></div></figure>


<p>Assuming all links are point-to-point certainly decreases visibility of created networks and we would not be able to perform selective changes on them in the future. However it is a safe assumption to make for 99% of the networks that I&rsquo;m dealing with.</p>

<h2>Node Start, Stop and Delete</h2>

<p>These simple actions can easily be coded using TDD. I will omit the actual implementation and simply provide unit tests for readers to exercise their TDD skills again.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/tests/test_unl.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">AdvancedUnlNodeTest</span><span class="p">(</span><span class="n">UnlTests</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">(</span><span class="n">AdvancedUnlNodeTest</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">setUp</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">device_one</span> <span class="o">=</span> <span class="n">Router</span><span class="p">(</span><span class="s">&#39;R1&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">device_two</span> <span class="o">=</span> <span class="n">Router</span><span class="p">(</span><span class="s">&#39;R2&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">lab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">create_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">node_one</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device_one</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">node_two</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device_two</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">delete_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">(</span><span class="n">AdvancedUnlNodeTest</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">tearDown</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_start_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">stop_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">start_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_stop_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">start_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">stop_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_delete_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">delete_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_one</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_del_all_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">del_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">resp_2</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s">&#39;data&#39;</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_lab_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">resp_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">stop_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">del_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="n">resp_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp_1</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">resp_2</span><span class="o">.</span><span class="n">json</span><span class="p">()[</span><span class="s">&#39;data&#39;</span><span class="p">]))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The final, <code>lab_cleanup()</code> method is simply a shortcut to <code>stop_nodes()</code> followed by <code>del_all_nodes()</code>.<br/>
As always, link to full code is available at the end of this post.</p>

<h2>Pushing configuration to Nodes</h2>

<p>At this point of time UnetLab does not support configuration import so we&rsquo;re stuck with the only access method available - telnet. To push configuration into the Node we&rsquo;re gonna have to establish a telnet session to Node&rsquo;s URI (which we&rsquo;ve extracted earlier) and write all configuration into that session.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">UnlNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">send_config</span><span class="p">(</span><span class="n">wrap_conf</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Another helper function <code>wrap_conf()</code> prepends <code>enable</code> and appends <code>end</code> to make configuration suitable for pasting into the new IOU device.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/device.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">Router</span><span class="p">(</span><span class="n">Device</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">send_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
</span><span class='line'>        <span class="n">session</span> <span class="o">=</span> <span class="n">telnetlib</span><span class="o">.</span><span class="n">Telnet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url_ip</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">url_port</span><span class="p">)</span>
</span><span class='line'>        <span class="n">send_and_wait</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">result</span> <span class="o">=</span> <span class="n">send_and_wait</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span>
</span><span class='line'>        <span class="n">session</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span>
</span></code></pre></td></tr></table></div></figure>


<p>The biggest problem is that Nodes, when started, take some time to boot before we can access the CLI prompt. To overcome that I had to implement a dirty hack in a form of <code>send_and_wait()</code> helper function that simulates pressing the <code>Enter</code> button every 0.1 second until it sees a CLI prompt (either <code>&gt;</code> or <code>#</code>).</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/helper.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">send_and_wait</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
</span><span class='line'>        <span class="n">session</span><span class="o">.</span><span class="n">read_very_eager</span><span class="p">()</span>
</span><span class='line'>        <span class="n">result</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
</span><span class='line'>        <span class="n">session</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</span><span class='line'>        <span class="k">while</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">stop_char</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="k">for</span> <span class="n">stop_char</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;#&#39;</span><span class="p">]):</span>
</span><span class='line'>            <span class="n">session</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">result</span> <span class="o">+=</span> <span class="n">session</span><span class="o">.</span><span class="n">read_very_eager</span><span class="p">()</span>
</span><span class='line'>            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let&rsquo;s hope that UNL team will implement config import soon so that we can get rid of this kludgy workaround.</p>

<h2>Extending our sample app</h2>

<p>At this stage we&rsquo;ve got all the code to finish our sample app. The goal is to create and configure the following 3-node topology:</p>

<p><img class="centre" src="http://networkop.github.io/images/rest-sample-app.png" title="REST SDK SAMPLE TOPO" ></p>

<p>We&rsquo;ll assume that all configs will be stored as text files under the <code>./config</code> directory and will have device names as their filename. A helper function <code>read_file</code> will read the contents of a configuration text file into a Python string.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">TOPOLOGY</span> <span class="o">=</span> <span class="p">{(</span><span class="s">&#39;R1&#39;</span><span class="p">,</span> <span class="s">&#39;Ethernet0/0&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s">&#39;R2&#39;</span><span class="p">,</span> <span class="s">&#39;Ethernet0/0&#39;</span><span class="p">),</span>
</span><span class='line'>            <span class="p">(</span><span class="s">&#39;R2&#39;</span><span class="p">,</span> <span class="s">&#39;Ethernet0/1&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s">&#39;R3&#39;</span><span class="p">,</span> <span class="s">&#39;Ethernet0/0&#39;</span><span class="p">),</span>
</span><span class='line'>            <span class="p">(</span><span class="s">&#39;R1&#39;</span><span class="p">,</span> <span class="s">&#39;Ethernet0/1&#39;</span><span class="p">):</span> <span class="p">(</span><span class="s">&#39;R3&#39;</span><span class="p">,</span> <span class="s">&#39;Ethernet0/1&#39;</span><span class="p">)}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">app_1</span><span class="p">():</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="k">try</span><span class="p">:</span>
</span><span class='line'>        <span class="c"># Creating topology in UnetLab</span>
</span><span class='line'>        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">a_name</span><span class="p">,</span> <span class="n">a_intf</span><span class="p">),</span> <span class="p">(</span><span class="n">b_name</span><span class="p">,</span> <span class="n">b_intf</span><span class="p">)</span> <span class="ow">in</span> <span class="n">TOPOLOGY</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
</span><span class='line'>            <span class="c"># Create a mapping between a Node&#39;s name and an object</span>
</span><span class='line'>            <span class="k">if</span> <span class="ow">not</span> <span class="n">a_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
</span><span class='line'>                <span class="n">nodes</span><span class="p">[</span><span class="n">a_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="n">Router</span><span class="p">(</span><span class="n">a_name</span><span class="p">))</span>
</span><span class='line'>                <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** NODE {} CREATED&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a_name</span><span class="p">))</span>
</span><span class='line'>            <span class="k">if</span> <span class="ow">not</span> <span class="n">b_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
</span><span class='line'>                <span class="n">nodes</span><span class="p">[</span><span class="n">b_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="n">Router</span><span class="p">(</span><span class="n">b_name</span><span class="p">))</span>
</span><span class='line'>                <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** NODE {} CREATED&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b_name</span><span class="p">))</span>
</span><span class='line'>            <span class="c"># Extract Node objects using their names and connect them</span>
</span><span class='line'>            <span class="n">node_a</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">a_name</span><span class="p">]</span>
</span><span class='line'>            <span class="n">node_b</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">b_name</span><span class="p">]</span>
</span><span class='line'>            <span class="n">node_a</span><span class="o">.</span><span class="n">connect_node</span><span class="p">(</span><span class="n">a_intf</span><span class="p">,</span> <span class="n">node_b</span><span class="p">,</span> <span class="n">b_intf</span><span class="p">)</span>
</span><span class='line'>            <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** NODES {0} and {1} ARE CONNECTED&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a_name</span><span class="p">,</span> <span class="n">b_name</span><span class="p">))</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** TOPOLOGY IS BUILT&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">lab</span><span class="o">.</span><span class="n">start_all_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** NODES STARTED&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="c"># Reading and pushing configuration</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
</span><span class='line'>            <span class="n">conf</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="s">&#39;..</span><span class="se">\\</span><span class="s">config</span><span class="se">\\</span><span class="s">{}.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_name</span><span class="p">))</span>
</span><span class='line'>            <span class="n">nodes</span><span class="p">[</span><span class="n">node_name</span><span class="p">]</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>
</span><span class='line'>            <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** NODE {} CONFIGURED&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_name</span><span class="p">))</span>
</span><span class='line'>        <span class="nb">raw_input</span><span class="p">(</span><span class="s">&#39;PRESS ANY KEY TO STOP THE LAB&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** APP FAILED : {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
</span><span class='line'>    <span class="k">finally</span><span class="p">:</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;*** CLEANING UP THE LAB&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">lab</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
</span><span class='line'>        <span class="n">unl</span><span class="o">.</span><span class="n">delete_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>When you run this app for the first time, the lab with 3 nodes will be spun up and configured. When you get to the <code>PRESS ANY KEY</code> prompt you can login into Web GUI and navigate to lab <code>test_1</code> and validate that all configs have been pushed and devices can ping each other&rsquo;s loopbacks.</p>

<h2>Source code</h2>

<p>All code from this post can be found in my <a href="https://github.com/networkop/rest-blog-unl-client/tree/2e847b8a809a1c9c4c0962b61c1c72325a405090">public repository on Github</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[REST for Network Engineers Part 2 - Basic Operations With UnetLab]]></title>
    <link href="http://networkop.github.io/blog/2016/01/06/rest-basic-operations/"/>
    <updated>2016-01-06T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2016/01/06/rest-basic-operations</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;ll show how to build REST SDK to authenticate, create labs and nodes in <a href="http://www.unetlab.com/">UnetLab</a>. I&rsquo;ll briefly cover the difference between composition and inheritance design patterns and demonstrate how to use test-driven development.</p>

<!--more-->


<h2>REST SDK Design</h2>

<p>As it is with networks, design is a very crucial part of programming. I won&rsquo;t pretend to be an expert in that field and merely present the way I&rsquo;ve built REST SDK. Fortunately, a lot of design will mimic the objects and their relationship on the server side. I&rsquo;ll slightly enhance it to improve code re-use and portability. Here are the basic objects:</p>

<ol>
<li>RestServer - implements basic application-agnostic HTTP CRUD logic</li>
<li>UnlServer - an extension of a RestServer with specific authentication method (cookie-based) and several additional methods</li>
<li>Device - an instance of a network device with specific attributes like type, image name, number of CPUs</li>
<li>UnlLab - a lab instance existing inside a UnlServer</li>
<li>UnlNode - a node instance existing inside a UnlLab</li>
<li>UnlNet - a network instance also existing inside a UnlLab object</li>
</ol>


<p>All these objects and their relationships are depicted on the following simplified <abbr title="Unified Modeling Language">UML</abbr> diagram. If you&rsquo;re interested in what different connections mean you can read <a href="http://www.codeproject.com/Articles/618/OOP-and-UML">this guide</a>.</p>

<p><img class="centre" src="http://networkop.github.io/images/rest-oop-design.png" title="REST SDK UML Diagram" ></p>

<p>Here I&rsquo;ve used inheritance to <em>extend</em> RestServer functionality to make a UnlServer. This makes sense because UnlServer object will re-use a lot of the methods from the RestServer. I could have combined them in a single object but I&rsquo;ve decided to split the application-agnostic bit into a separate component to allow it to be re-used by other RESTful clients in the future.</p>

<p>The other objects are aggregated and interact through code composition, where Lab holds a pointer to the UnlServer where it was created, Nodes and Nets point to the Lab in which they live. Composition creates loose coupling between objects, while still allowing method delegation and code re-use.</p>

<p>For additional information about Composition vs Inheritance you can go <a href="http://learnpythonthehardway.org/book/ex44.html">here</a>, <a href="http://lgiordani.com/blog/2014/08/20/python-3-oop-part-3-delegation-composition-and-inheritance/">here</a> or <a href="http://python-textbok.readthedocs.org/en/latest/Object_Oriented_Programming.html#avoiding-inheritance">here</a>.</p>

<h2>REST SDK Implementation</h2>

<blockquote><p>Throughout this post I&rsquo;ll be omitting a lot of the non-important code. For full working code refer to the link at the end of this post.</p></blockquote>

<h3>RestServer implementation</h3>

<p>When RestServer object is created, <code>__init__()</code> function takes the server IP address and constructs a <code>base_url</code>, a common prefix for all API calls. The 4 CRUD actions are encoded into names of the methods implementing them, for example to send an Update one would need to call <code>.update_object()</code>. This convention will make the implementation of UnlServer a lot more readable. Each of the 4 CRUD methods call <code>_send_request()</code> with correct HTTP verb preset (the leading underscore means that this method is private and should only be called from within the RestServer class).</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/server.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">RestServer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">cookies</span> <span class="o">=</span> <span class="bp">None</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">base_url</span> <span class="o">=</span> <span class="s">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;http:/&#39;</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="s">&#39;api&#39;</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">_send_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</span><span class='line'>        <span class="n">response</span> <span class="o">=</span> <span class="bp">None</span>
</span><span class='line'>        <span class="n">url</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_url</span> <span class="o">+</span> <span class="n">path</span>
</span><span class='line'>        <span class="k">try</span><span class="p">:</span>
</span><span class='line'>            <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span>  <span class="n">json</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">cookies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cookies</span><span class="p">)</span>
</span><span class='line'>        <span class="k">except</span> <span class="n">requests</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span class='line'>            <span class="k">print</span><span class="p">(</span><span class="s">&#39;*** Error calling </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">response</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">get_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_request</span><span class="p">(</span><span class="s">&#39;GET&#39;</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">add_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_request</span><span class="p">(</span><span class="s">&#39;POST&#39;</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">update_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_request</span><span class="p">(</span><span class="s">&#39;PUT&#39;</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">del_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_request</span><span class="p">(</span><span class="s">&#39;DELETE&#39;</span><span class="p">,</span> <span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">set_cookies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cookie</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">cookies</span> <span class="o">=</span> <span class="n">cookie</span>
</span></code></pre></td></tr></table></div></figure>


<p>At this stage RestServer does very simple exception and no HTTP response error handling. I&rsquo;ll show how to extend it to do authentication error handling in the future posts.</p>

<h3>UnlServer implementation</h3>

<p>At the very top of the <code>unetlab.py</code> file we have a <code>REST_SCHEMA</code> global variable providing mapping between actions and their respective <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/">API calls</a>. This improves code readability (at least to me) and makes future upgrades to API easier to implement.<br/>
UnlServer class is extending the functionality of a RestServer by implementing UNetLab-specific methods. For example, <code>login()</code> sends username and password using the <code>add_object()</code> method of the parent class and sets the cookies extracted from the response to allow all subsequent methods to be authenticated.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">REST_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="s">&#39;login&#39;</span><span class="p">:</span> <span class="s">&#39;/auth/login&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&#39;logout&#39;</span><span class="p">:</span> <span class="s">&#39;/auth/logout&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&#39;status&#39;</span><span class="p">:</span> <span class="s">&#39;/status&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&#39;list_templates&#39;</span><span class="p">:</span> <span class="s">&#39;/list/templates/&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlServer</span><span class="p">(</span><span class="n">RestServer</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">(</span><span class="n">UnlServer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">login</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">pwd</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;login&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>            <span class="s">&quot;username&quot;</span><span class="p">:</span> <span class="n">user</span><span class="p">,</span>
</span><span class='line'>            <span class="s">&quot;password&quot;</span><span class="p">:</span> <span class="n">pwd</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">set_cookies</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">cookies</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">logout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;logout&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">api_call</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;status&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">api_call</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">get_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;list_templates&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">api_call</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span></code></pre></td></tr></table></div></figure>


<p>As you can see all methods follow the same pattern:</p>

<ol>
<li>Extract an API url from <code>REST_SCHEMA</code> global variable</li>
<li>Send a request using one of the 4 CRUD methods of the parent RestServer class</li>
<li>Return the response</li>
</ol>


<p>Now let&rsquo;s see how we can use TDD approach to build out the rest of the code.</p>

<h2>Test-driven development</h2>

<p>The easiest way to test RESTful application is by observing the status code of the returned HTTP response. If it is 200 or 201 then it can be considered successful. The biggest challenge is to make sure each test case is independent from one another. One option is to include all the code required by a test case inside the function that implements it. This, however, may lead to long and unwieldy spaghetti-code and breaks the <abbr title="Do Not Repeat Yourself">DRY</abbr> principle.<br/>
To help avoid that, TDD frameworks often have <code>fixtures</code> - functions that are run before and after every test case, designed to setup and cleanup the test environment. In our case we can use fixtures to login before each test case is run and logoff after it&rsquo;s finished. Let&rsquo;s see how we can use Python&rsquo;s built-in <a href="https://docs.python.org/2/library/unittest.html">unittest</a> framework to drive the REST SDK development process.<br/>
First let&rsquo;s define our base class <code>UnlTests</code> who&rsquo;s sole purpose will be to implement authentication fixtures. All the test cases will go into child classes that can either reuse and extend these fixtures. This is how test cases for the already existing code look like:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/tests/test_unl.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">UnlTests</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span> <span class="o">=</span> <span class="n">UnlServer</span><span class="p">(</span><span class="n">UNETLAB_ADDRESS</span><span class="p">)</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="n">USERNAME</span><span class="p">,</span> <span class="n">PASSWORD</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">logout</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">BasicUnlTests</span><span class="p">(</span><span class="n">UnlTests</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">get_status</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">get_templates</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>At this point if you add all the necessary import statements and populate global variables with correct IP addresses and credentials all tests should pass. Now let&rsquo;s add another test case to retrieve <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/#toc2">user information</a> from UNL:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/tests/test_unl.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">BasicUnlTests</span><span class="p">(</span><span class="n">UnlTests</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_user_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">get_user_info</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Rerun the tests and watch the last one fail saying <code>'UnlServer' object has no attribute 'get_user_info'</code>. Now let&rsquo;s go back to our UNL SDK code and add that attribute:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">REST_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">...</span> <span class="p">,</span>
</span><span class='line'>    <span class="s">&#39;get_user_info&#39;</span><span class="p">:</span> <span class="s">&#39;/auth&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnetLab</span><span class="p">(</span><span class="n">RestServer</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">get_user_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;get_user_info&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">api_call</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resp</span>
</span></code></pre></td></tr></table></div></figure>


<p>Rerun the <code>test_unl.py</code> now and watch all tests succeed again. The same iterative approach can be used to add any number of new methods at the same time making sure none of the existing functionality is affected.<br/>
Note that these are very simple tests and they only verify the response code and not its contents. The better approach would be to look inside the payload and verify, for example, that username is <code>admin</code>.</p>

<h3>UnlLab and UnlNode implementation</h3>

<p>Now let&rsquo;s revert back to normal coding style for a second and create classes for Labs and Nodes. As per the design, these should be separate objects but they should contain a pointer to the context in which they exist. Therefore, it makes sense to instantiate a Lab inside a UnlServer, a Node inside a Lab and pass in the <code>self</code> (UnlServer or Lab) as an argument. For example, here is how a lab will be created:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">REST_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">...</span> <span class="p">,</span>
</span><span class='line'>    <span class="s">&#39;create_lab&#39;</span><span class="p">:</span> <span class="s">&#39;/labs&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlServer</span><span class="p">(</span><span class="n">RestServer</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">create_lab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UnlLab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlLab</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unl</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;create_lab&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>           <span class="s">&quot;path&quot;</span><span class="p">:</span> <span class="s">&quot;/&quot;</span><span class="p">,</span>
</span><span class='line'>           <span class="s">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
</span><span class='line'>           <span class="s">&quot;version&quot;</span><span class="p">:</span> <span class="s">&quot;1&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span> <span class="o">=</span> <span class="n">unl</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="n">api_call</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>So to create a Lab we need to issue a <code>.create_lab()</code> call on UnlServer object and give it a labname. That function will return a new Lab object with the following attributes preset:</p>

<ul>
<li>Lab name - <code>self.name</code></li>
<li>UnlServer that created it - <code>self.unl</code></li>
<li>HTTP response returned by the server after the Create CRUD action - <code>self.resp</code></li>
</ul>


<p>The latter can be used to check if the creation was successful (and potentially throw an error if it wasn&rsquo;t). The structure of the payload can be found in <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/#toc30">API docs</a>.</p>

<p>Nodes will be created in a similar way with a little exception. Apart from the name, Node also needs to know about the particulars of the device it will represent (like device type, image name etc.). That&rsquo;s where Device class comes in. The implementation details are very easy and can be found on <a href="https://github.com/networkop/rest-blog-unl-client/blob/c72f7bdc11427ac5efe9ec18401f0d63c57221ba/restunl/device.py">Github</a> so I won&rsquo;t provide them here. The only function of a Device at this stage is to create a dictionary that can be used as a payload in <code>create_node</code> <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/#toc34">API request</a>.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/restunl/unetlab.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">REST_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="o">...</span> <span class="p">,</span>
</span><span class='line'>    <span class="s">&#39;create_node&#39;</span><span class="p">:</span> <span class="s">&#39;/labs/{lab_name}/nodes&#39;</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlLab</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">create_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UnlNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">UnlNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lab</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">unl</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">lab</span> <span class="o">=</span> <span class="n">lab</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
</span><span class='line'>        <span class="n">api_call</span> <span class="o">=</span> <span class="n">REST_SCHEMA</span><span class="p">[</span><span class="s">&#39;create_node&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="n">api_url</span> <span class="o">=</span> <span class="n">api_call</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">api_call</span><span class="p">,</span> <span class="n">lab_name</span><span class="o">=</span><span class="n">append_unl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lab</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
</span><span class='line'>        <span class="n">payload</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="n">api_url</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">payload</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Take a quick look at how the <code>api_url</code> is created. We&rsquo;re using <code>.format()</code> method (built-into <code>string</code> module) to substitute a named variable <code>{format}</code> with the actual name of the lab (<code>self.lab.name</code>). That labname gets appended with an extension by a helper function <code>append_unl</code>. That helper function, along with the others we&rsquo;ll define in the future, can also be found on <a href="https://github.com/networkop/rest-blog-unl-client/blob/c72f7bdc11427ac5efe9ec18401f0d63c57221ba/restunl/helper.py">Github</a>.</p>

<h2>Back to TDD</h2>

<p>Let&rsquo;s use TDD again to add the last two actions we&rsquo;ll cover in this post.</p>

<ul>
<li>Get list of all Nodes</li>
<li>Delete a lab</li>
</ul>


<figure class='code'><figcaption><span>/rest-blog-unl-client/tests/test_unl.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">class</span> <span class="nc">BasicUnlLabTest</span><span class="p">(</span><span class="n">UnlTests</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_create_lab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">delete_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">create_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span><span class="o">.</span><span class="n">resp</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">delete_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_delete_lab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">create_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">delete_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">test_get_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="n">lab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">create_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="n">resp</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">get_nodes</span><span class="p">()</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">unl</span><span class="o">.</span><span class="n">delete_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>As a challenge, try implementing the SDK logic for the last two failing methods yourself using <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/">UNL API</a> as a reference. You can always refer the the link at the end of the post if you run into any problems.</p>

<h2>Simple App</h2>

<p>So far we&rsquo;ve created and deleted objects with REST API but haven&rsquo;t seen the actual result. Let&rsquo;s start writing an app that we&rsquo;ll continue to expand in the next post. In this post we&rsquo;ll simply login and create a lab containing a single node.</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/samples/app-1.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">restunl.unetlab</span> <span class="kn">import</span> <span class="n">UnlServer</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">restunl.device</span> <span class="kn">import</span> <span class="n">Router</span>
</span><span class='line'>
</span><span class='line'><span class="n">LAB_NAME</span> <span class="o">=</span> <span class="s">&#39;test_1&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">app_1</span><span class="p">():</span>
</span><span class='line'>    <span class="n">unl</span> <span class="o">=</span> <span class="n">UnlServer</span><span class="p">(</span><span class="s">&#39;192.168.247.20&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">unl</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="s">&#39;admin&#39;</span><span class="p">,</span> <span class="s">&#39;unl&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;*** CONNECTED TO UNL&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">lab</span> <span class="o">=</span> <span class="n">unl</span><span class="o">.</span><span class="n">create_lab</span><span class="p">(</span><span class="n">LAB_NAME</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;*** CREATED LAB&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">node_1</span> <span class="o">=</span> <span class="n">lab</span><span class="o">.</span><span class="n">create_node</span><span class="p">(</span><span class="n">Router</span><span class="p">(</span><span class="s">&#39;R1&#39;</span><span class="p">))</span>
</span><span class='line'>    <span class="k">print</span> <span class="p">(</span><span class="s">&quot;*** CREATED NODE&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">app_1</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>Run this once, then login the UNL web GUI and navigate to <code>test_1</code> lab. Examine how node <strong>R1</strong> is configured and compare it to the defaults set in a <a href="https://github.com/networkop/rest-blog-unl-client/blob/c72f7bdc11427ac5efe9ec18401f0d63c57221ba/restunl/device.py">Device module</a>.</p>

<h2>Source code</h2>

<p>All code from this post can be found in my <a href="https://github.com/networkop/rest-blog-unl-client/tree/c72f7bdc11427ac5efe9ec18401f0d63c57221ba">public repository on Github</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[REST for Network Engineers Part 1 - Development Environment Setup]]></title>
    <link href="http://networkop.github.io/blog/2016/01/03/dev-env-setup-rest/"/>
    <updated>2016-01-03T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2016/01/03/dev-env-setup-rest</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;ll show how to setup environment for <a href="http://www.unetlab.com/">UnetLab</a> REST SDK development on Windows. I&rsquo;ll be running UNL inside a VM and using PyCharm as Python IDE on the host OS.</p>

<!--more-->


<h2>UnetLab Installation</h2>

<p>Since UNL is a separate project with its own evolving documentation I won&rsquo;t try to reproduce it in my blog and I&rsquo;ll simply refer all my readers to <a href="http://www.unetlab.com/download/index.html">UNL download page</a>, <a href="http://www.unetlab.com/documentation/index.html">UNL installation instructions</a> and <a href="http://www.unetlab.com/2014/11/first-unetlab-boot-configuration/">UNL first boot configuration</a>.<br/>
At the time of writing UNL is distributed as an image packaged in Open Virtualization Format. I&rsquo;m using VMWare Workstation as a type-2 hypervisor to import and run this image. Check with the <a href="http://www.unetlab.com/documentation/index.html">UNL how-to page</a> for the list of currently supported hypervisors.<br/>
I&rsquo;ll be using Cisco IOU as a network device emulator in my topologies. Similarly, you can find IOU installation instructions on <a href="http://www.unetlab.com/2014/11/adding-cisco-iouiol-images/">UNL website</a>. The rest of this post assumes you&rsquo;ve got UNL up and running and you can successfully create, start and connect to an IOU device by navigating through native GUI interface.</p>

<h2>Installing Python and Dependencies</h2>

<p>For development purposes I&rsquo;ll be using <a href="https://www.python.org/downloads/release/python-2711/">Python 2.7</a>. You&rsquo;ll need to install a package management system <a href="https://pip.pypa.io/en/latest/installing/">pip</a> to gain access to <a href="http://docs.python-requests.org/en/latest/user/install/">requests</a> library that we&rsquo;ll be using to talk HTTP to our REST server. To install <strong>requests</strong> or any other package using <strong>pip</strong> on a Windows machine, you can use the following command:</p>

<figure class='code'><figcaption><span>Installing Python HTTP library</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='powershell'><span class='line'><span class="n">python</span> <span class="n">-m</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">requests</span>
</span></code></pre></td></tr></table></div></figure>


<h2>PyCharm and Github integration</h2>

<p>There&rsquo;s a plethora of <abbr title="Intergrated Development Environment">IDE</abbr>s <a href="https://wiki.python.org/moin/IntegratedDevelopmentEnvironments">available for Python</a>. My personal choice is <a href="https://www.jetbrains.com/pycharm/">PyCharm</a> - an open-source IDE with built-in debugger, syntax checker, code completion and GIT integration. Here is how you setup PyCharm to work with Github:</p>

<ol>
<li><strong>Create</strong> a new repository on <a href="https://github.com">Github</a>.</li>
<li>In PyCharm navigate to <code>VCS -&gt; Checkout from Version Control -&gt; Github</code>, paste in the link to a newly created repository and click <code>Clone</code>. This will <strong>create a clone</strong> of an empty code repository on your local machine. From now on you&rsquo;ll see two VCS buttons in PyCharm toolbar to pull and push code to Github.</li>
<li><strong>Add</strong> newly created files and directories to git by right-clicking on them and selecting <code>Git -&gt; Add</code></li>
<li>At the end of your work <strong>push</strong> the code to Github by clicking the green VCS button, write your comment in <code>Commit message</code> window, enter your Github username in <code>Author</code> field and select <code>Commit and Push</code>.</li>
<li>To get the latest version of code from Github click the blue VCS button to <strong>pull</strong> changes to local directory.</li>
</ol>


<p>Just remember that your Github repository is your source of truth and you need to push changes to it every time you finish work and pull code from it every time you restart it. It makes sense even if you work alone since it creates a good habit which may come very useful in the future.  <br/>
For additional information about git workflow and working with Github you can check out (no pun intended) <a href="https://help.github.com/categories/bootcamp/">Github help</a> and <a href="https://guides.github.com/">Github guides</a>.</p>

<h2>Project Skeleton</h2>

<p>Now that we&rsquo;ve fully integrated with Github we can setup our basic directory structure. In project Navigation Bar under the project&rsquo;s main directory create 3 subdirectories:</p>

<ul>
<li><code>restunl</code> - to store all code implementing REST SDK logic</li>
<li><code>samples</code> - to store sample applications</li>
<li><code>tests</code> - to store test cases for REST SDK</li>
</ul>


<p>Next we need to tell git which files we DON&rsquo;T want to track. To do that add filename patterns to <code>.gitignore</code> file and put this file into every directory. Rule of thumb is to only track your code and not your auxiliary files like compiled python code (.pyc), PyCharm settings (.idea) or local git files (.git).</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/.gitignore</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>.idea
</span><span class='line'>.git
</span><span class='line'>*.pyc
</span></code></pre></td></tr></table></div></figure>


<p>Finally, in order to be able to import code between different directories within the project, we need to add an empty <code>__init__.py</code> file to each non-root directory which tells Python to treat that directory as <a href="https://docs.python.org/2/tutorial/modules.html#packages">a package</a>. The final version of skeleton will look like this:</p>

<p><img class="centre" src="http://networkop.github.io/images/restunl-skeleton.png" title="Project Skeleton" ></p>

<h2>Before you REST</h2>

<p>Here are a few things you need to know about the REST server before you start working with it:</p>

<ol>
<li>IP address and Port - the same IP address you use to access UNL from your web browser (in my case it&rsquo;s 192.168.247.20:80)</li>
<li>Username and password for authentication - default UNL credentials (admin/unl)</li>
<li>REST API documentation - in our case it&rsquo;ll be <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/">UnetLab API documentation</a></li>
</ol>


<h2>Using REST for the first time</h2>

<p>Let&rsquo;s try to query the status of our UnetLab server. According <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/">UNL documentation</a> the correct request should look like this:</p>

<figure class='code'><figcaption><span>UNL status API call</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>curl -s -c /tmp/cookie -b /tmp/cookie -X GET -H <span class="s1">&#39;Content-type: application/json&#39;</span> http://127.0.0.1/api/status
</span></code></pre></td></tr></table></div></figure>


<p>Take note of the HTTP method (GET) and URL (<a href="http://ip_address/api/status">http://ip_address/api/status</a>), we&rsquo;ll use these values in our test program. Disregard the cookies and Content-type headers for now, we&rsquo;ll get back to them in the future posts. In our project&rsquo;s root directory create a <code>test.py</code> file with the following code:</p>

<figure class='code'><figcaption><span>/rest-blog-unl-client/test.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">requests</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">json</span>
</span><span class='line'>
</span><span class='line'><span class="n">url</span> <span class="o">=</span> <span class="s">&#39;http://192.168.247.20/api/status&#39;</span>
</span><span class='line'><span class="n">method</span> <span class="o">=</span> <span class="s">&#39;GET&#39;</span>
</span><span class='line'><span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
</span><span class='line'><span class="n">payload</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">payload</span><span class="p">[</span><span class="s">&#39;code&#39;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This code calls <code>.request</code> method of requests library and passes in an HTTP method type and the URL. The value returned by this call would be an HTTP response. Since payload is encoded as JSON we need to parse the content of the HTTP response (<code>response.content</code>) by calling a <code>.loads</code> method of json library. Once parsed, we can work with any part of JSON payload same way we would with a Python dictionary. If you&rsquo;ve done everything right, the result of the last print statement should be <code>200</code>. Feel free to experiment and print, for example, the current version of UNL. Refer to <a href="http://www.unetlab.com/2015/09/using-unetlab-apis/">API documentation</a> for the exact structure of the payload.</p>

<h2>Conclusion</h2>

<p>Now that we&rsquo;ve setup our development environment we&rsquo;ll move on to the actual REST SDK development in the next post. Don&rsquo;t forget to add all your newly created files and directories to git and push them to Github.</p>

<p>All code from this post can be found in my <a href="https://github.com/networkop/rest-blog-unl-client/tree/63d8d13e48e61e896185eb7afee3759c1f2cd5a9">public repository on Github</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[REST API for Network Engineers]]></title>
    <link href="http://networkop.github.io/blog/2016/01/01/rest-for-neteng/"/>
    <updated>2016-01-01T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2016/01/01/rest-for-neteng</id>
    <content type="html"><![CDATA[<p>This is the first, introductory, post in a series dedicated to REST APIs for Network Engineers. In this post we&rsquo;ll learn what REST API is, what are the most common tools and ways to consume it. Later in the series I&rsquo;ll show how to build a REST client to control <a href="http://www.unetlab.com/">UnetLab</a>, a very popular network emulation environment.</p>

<!--more-->


<h2>Management interface evolution</h2>

<p>Since the early dawn of networking, devices have been configured through <abbr title="Virtual Terminal User Interface">VTY</abbr>s. The transport has evolved from telnet to ssh but the underlying rule still maintained that network is configured manually, device-by-device by a human administrator. It&rsquo;s obvious that this approach does not scale and is prone to human error, however it still remains the most prevalent method of network device configuration. <br/>
The first attempt to tackle these issues has been made in 1988 with the introduction of SNMP. The basic idea was to monitor and manage network devices using a strictly-defined data structures called <abbr title="Management Information Base">MIB</abbr>s. Unfortunately, due to several architectural issues and poor vendor implementation, SNMP has ended up being used mainly for basic monitoring tasks.<br/>
The idea of programmatic management of network devices later resulted in the creation of NETCONF protocol. Despite being almost 10 years old, this protocol is still not widely used due to limited vendor support, however things may improve as the <abbr title="Yet Another Next Generation">YANG</abbr>-based network configuration gains greater adoption.<br/>
Finally, with the advent of SDN, REST has become a new de-facto standard for network provisioning. It is supported by most of the latest products of all the major vendors. Let&rsquo;s take a closer look at what REST is and how it works.</p>

<h2>REpresentational State Transfer overview</h2>

<p>Technically speaking, REST is not a protocol but a <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">software architectural pattern</a>. To put it in simple words, it describes <strong>a way</strong> to exchange information rather than the structure of that information. Think of it as another transport (like telnet or ssh for VTY) for payloads of any format. Most commonly payload will get encoded as <abbr title="JavaScript Object Notation">JSON</abbr>, however the structure of JSON is not defined and is different for each application. This rather <em>weak</em> definition opens up huge opportunities for potential use cases:</p>

<ol>
<li><p>The most basic use case is a Web application with client retrieving and updating information on a server. A good example in networking world would be the native interfaces of Cisco ACI or VMWare NSX. Each time you create an object (a network or a tenant) in a Web GUI, your client sends a request to server&rsquo;s REST interface.</p></li>
<li><p>The more advanced use case is for communication between distributed software components over a network environment. This is how all management and control plane communications are designed inside OpenStack. For example, every time a new VM is created, <abbr title="Compute controller">Nova</abbr> sends a request to <abbr title="Network controller">Neutron</abbr>&rsquo;s REST API interface to allocate an IP address and a port for that VM.</p></li>
</ol>


<h2>REST under the hood</h2>

<p>REST is an API that allows clients to perform read/write operations on data stored on the server. REST uses HTTP to perform a set of actions commonly known as <strong>CRUD</strong>:</p>

<ul>
<li>Create</li>
<li>Read</li>
<li>Update</li>
<li>Delete</li>
</ul>


<p>Assuming we want to manipulate a &lsquo;device&rsquo; object on a server we can send an <code>HTTP GET</code> request to <code>/api/devices</code> and get a response with a payload containing a full list of known devices.<br/>
If we want to add a new device, we need to construct a payload with device attributes (e.g. IP address, Hostname) and send it attached to an <code>HTTP POST</code> request.<br/>
To update a device we need to send the full updated payload with <code>HTTP PUT</code> method.</p>

<p><img class="centre" src="http://networkop.github.io/images/rest-crud.png" title="Basic REST actions" ></p>

<p>Note that both Update and Delete API calls refer to a specific number in url <code>/api/devices/{ID}</code>. That is a <abbr title="Universally Unique IDentifier">UUID</abbr> that server assigns to every new object and is returned in <code>Location</code> header of <code>201 Created</code> message sent in response to Create request.</p>

<h2>REST API Constraints</h2>

<p>For API to be considered <strong>RESTful</strong> it needs comply with a number of <a href="http://www.restapitutorial.com/lessons/whatisrest.html">formal constraints</a>. One of the most important constraint of all is the stateless nature of the interface. That means that no cookie or session information should be stored on the server, and every request is treated independently from every other request. The implication here is that all state needs to be maintained on the client and information needs to be cacheable in order to improve interface responsiveness.</p>

<p>It&rsquo;s worth noting that an API can still be considered RESTful even if a server <em>does</em> store a session cookie, however all requests must still be treated independently. The last point means there&rsquo;s no <em>configuration modes</em> like we&rsquo;ve seen in traditional CLIs where all commands issued in &ldquo;interface configuration mode&rdquo; will be applied to that specific interface. With RESTful API each request from a client must reference a full path to an object including its UUID within the system.</p>

<h2>Using REST</h2>

<h3>cURL</h3>

<p>cURL is a light-weight Linux command-line tool for transferring data. It&rsquo;s very simple to get started and very frequently used to make HTTP requests. For example, this is how you would issue a Read request to get a list of devices configured on an imaginary SDN controller:</p>

<figure class='code'><figcaption><span>Get all devices using cURL</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>curl -X GET http://sdn-controller.org:8181/api/devices
</span></code></pre></td></tr></table></div></figure>


<p>Obviously this tool is very good for fast prototyping and troubleshooting but becomes too cumbersome for anything involving more than a few commands.</p>

<h3>Browser plugins</h3>

<p>There&rsquo;s plenty of GUI-based clients that can be added-on to most popular browsers. <a href="https://www.getpostman.com/">Postman</a> and <a href="https://addons.mozilla.org/en-us/firefox/addon/restclient/">RESTClient</a> are amongst the most popular ones. In addition to basic functionality, these plugins allow you to store and issue sequence of requests which can be very handy for live demonstrations. Unfortunately that&rsquo;s where most of the people stop learning about REST API and assume this is the intended way to interact with a server.</p>

<h3><abbr title="Software Development Kit">SDK</abbr></h3>

<p>SDK is a collection of tools and libraries that allow users to build a full-blown applications with complex internal logic. Instead of caring about the exact syntax of API calls, SDK libraries provide a simple programming interface. For example, this is how you would run the same command we did earlier with cURL:</p>

<figure class='code'><figcaption><span>Get all devices using SDK</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">controller</span> <span class="o">=</span> <span class="n">sdk</span><span class="o">.</span><span class="n">Controller</span><span class="p">(</span><span class="s">&#39;sdn-controller.org&#39;</span><span class="p">,</span> <span class="mi">8181</span><span class="p">)</span>
</span><span class='line'><span class="n">response</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">get_devices</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>We first create an instance of a controller with specific hostname and port number and then issue a <code>.get_devices()</code> call on it to obtain the list of all known devices. SDK library will do all the dirty work constructing HTTP request in the background and return the parsed information from HTTP response. We can then use that information to perform some complex logic, like start only Router devices (but not switches and firewalls):</p>

<figure class='code'><figcaption><span>Start all Routers using SDK</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">routers_started</span> <span class="o">=</span> <span class="p">[</span><span class="n">device</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">get_payload</span><span class="p">()</span> <span class="k">if</span> <span class="n">device</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&#39;Router&#39;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>As you can see, we can use all capabilities of a programming language to write a succinct and powerful code, something that would be extremely difficult to do with cURL or Postman. That&rsquo;s why the focus of this series of posts will be on the SDK, how to build one from scratch and how to use it.</p>

<h2>UNetLab REST SDK</h2>

<p>In the upcoming posts I&rsquo;ll show how to develop a REST SDK to control UnetLab. My final goal would be to be able to create and fully configure an arbitrary network topology. The whole series will be broken up into several posts going over:</p>

<ol>
<li><a href="http://networkop.github.io/blog/2016/01/03/dev-env-setup-rest/">UnetLab SDK development environment setup</a>.
I&rsquo;ll show how to setup PyCharm to work with UNL running in a hypervisor on a Windows machine.</li>
<li><a href="http://networkop.github.io/blog/2016/01/06/rest-basic-operations/">First steps with REST API for UNetLab</a>.
In this post I&rsquo;ll show how to work with HTTP and perform basic operations like login/logoff and object creation in UNL.</li>
<li><a href="http://networkop.github.io/blog/2016/01/17/rest-unl-advanced/">Advanced actions with UNetLab SDK</a>.
The final post will demonstrate how to push configuration to devices inside UNL. To wrap up I&rsquo;ll write a sample app to spin up and provision a three-node topology without making a single GUI click.</li>
</ol>

]]></content>
  </entry>
  
</feed>
