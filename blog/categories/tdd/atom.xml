<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tdd | Network-oriented programming]]></title>
  <link href="http://networkop.github.io/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://networkop.github.io/"/>
  <updated>2016-04-26T00:42:48-07:00</updated>
  <id>http://networkop.github.io/</id>
  <author>
    <name><![CDATA[Michael Kashin]]></name>
    <email><![CDATA[mmkashin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Network TDD Quickstart Guide]]></title>
    <link href="http://networkop.github.io/blog/2015/07/17/tdd-quickstart/"/>
    <updated>2015-07-17T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2015/07/17/tdd-quickstart</id>
    <content type="html"><![CDATA[<p>This post gives a quick overview of how to use network Test Driven Development framework. As an example I&rsquo;ll use a simplified version of a typical enterprise network with a Data Centre/HQ and a Branch office. A new branch is being added and the task is to configure routing for that branch using a TDD approach. First we&rsquo;ll devise a set of TDD scenarios to be tested and then, going through each one of them, modify routing to make sure those scenarios don&rsquo;t fail (a so-called red-green-refactor approach)</p>

<!--more-->


<h2>Network overview</h2>

<p>Let&rsquo;s assume you&rsquo;re working in a proverbial Acme Inc. It has a Data Centre hosting all centralised services and a single office branch (Branch #1). Sites are interconnected using active/backup WAN links. The company decides to expand and adds a new office in a city nearby. In additional to standard dual WAN links it&rsquo;s possible to buy a cheap and high throughput backdoor link between the two branches.</p>

<p>{% img centre /images/tdd-big-topo.png Acme Inc. Topology%}</p>

<h2>Network configuration</h2>

<p>Acme Inc. uses OSPF for intra-site routing and BGP for WAN routing. A standard configuration assumes that the core router at each site is the route reflector for the two WAN routers.</p>

<pre><code class="text CORE ROUTER CONFIG">interface Loopback0
 ip address 10.0.X.1 255.255.255.255
!
router ospf 100
 network 0.0.0.0 255.255.255.255 area 0
!
router bgp X
 bgp log-neighbor-changes
 timers bgp 1 5
 neighbor RR-CLIENTS peer-group
 neighbor RR-CLIENTS remote-as 1
 neighbor RR-CLIENTS update-source Loopback0
 neighbor RR-CLIENTS route-reflector-client
 neighbor 10.0.X.2 peer-group RR-CLIENTS
 neighbor 10.0.X.3 peer-group RR-CLIENTS
</code></pre>

<p>WAN routers originate site summary by first injecting their own Loopback IP address into BGP RIB and then aggregating it to site summary boundary (/24).</p>

<pre><code class="text WAN ROUTER 1 CONFIG">router ospf 100
 network 0.0.0.0 255.255.255.255 area 0
!
router bgp X
 bgp log-neighbor-changes
 network 10.0.X.2 mask 255.255.255.255
 aggregate-address 10.0.X.0 255.255.255.0
 neighbor &lt;PRIMARY_PE_IP&gt; remote-as &lt;PRIMARY_WAN_AS&gt;
 neighbor 10.0.X.1 remote-as 1
 neighbor 10.0.X.1 update-source Loopback0
</code></pre>

<p>No special path manipulation is done on either WAN routers by default.</p>

<pre><code class="text WAN ROUTER 2 CONFIG">router ospf 100
 network 0.0.0.0 255.255.255.255 area 0
!
router bgp X
 bgp log-neighbor-changes
 network 10.0.X.2 mask 255.255.255.255
 aggregate-address 10.0.X.0 255.255.255.0
 neighbor &lt;BACKUP_PE_IP&gt; remote-as &lt;BACKUP_WAN_AS&gt;
 neighbor 10.0.X.1 remote-as 1
 neighbor 10.0.X.1 update-source Loopback0
</code></pre>

<p>The same pattern is repeated on all sites with the exception of an additional backdoor link between the branch sites over which the two cores run eBGP. Inter-device transit subnets can be anything within the site-allocated range.</p>

<h2>Devising TDD scenarios</h2>

<p>After careful consideration of all links' bandwidths you devise a set of TDD scenarios and along with the high-level network topology present them to your management for endorsement. The idea is to always try to use the primary WAN link if possible. However for the inter-branch communication, backdoor link should be the preferred option. When the primary link fails at the new branch, all traffic to and from the DC should traverse the backdoor link only falling back to the secondary WAN link in case both primary and backdoor link fail. This corresponds to the 4 TDD scenarios (shown with coloured arrows on the above diagram):</p>

<p>{% codeblock lang:text ./scenarios/all.txt %}
1. Testing of Primary Link (default scenario)</p>

<p>1.1 From DC-CORE to BR2-CORE via DC-WAN1,BR2-WAN1
1.2 From BR2-CORE to DC-CORE via BR2-WAN1, DC-WAN1
1.3 From BR2-WAN1 to BR1-WAN1 via BR2-CORE,BR1-CORE
1.4 From BR1-WAN1 to BR2-WAN1 via BR1-CORE, BR2-CORE</p>

<ol>
<li>Primary WAN failed at Branch #2</li>
</ol>


<p>2.1 From DC-CORE to BR2-CORE via DC-WAN1,BR1-WAN1,BR1-CORE
2.2 From BR2-CORE to DC-CORE via BR1-CORE, BR1-WAN1, DC-WAN1
2.3 From BR2-WAN2 to BR1-WAN2 via BR2-CORE, BR1-CORE
2.4 From BR1-WAN2 to BR2-WAN2 via BR1-CORE, BR2-CORE</p>

<ol>
<li>Backdoor link failed</li>
</ol>


<p>3.1 From BR2-WAN2 to BR1-WAN2 via BR2-WAN1, BR1-WAN1
3.2 FROM BR1-WAN2 to BR2-WAN2 via BR1-WAN1, BR2-WAN1</p>

<ol>
<li>Both Primary and Backdoor links failed at Branch #2</li>
</ol>


<p>4.1 From DC-CORE to BR2-CORE via DC-WAN2, BR2-WAN2
4.2 From BR2-CORE to DC-CORE via BR2-WAN2, DC-WAN2
4.3 From BR2-CORE to BR1-CORE via BR2-WAN2, BR1-WAN2
4.4 From BR1-CORE to BR2-CORE via BR1-WAN2, BR2-WAN2
{% endcodeblock  %}</p>

<h2>Preparing the test environment</h2>

<p>First, you need to get a Linux machine connected to internet and to your network. A simply VM inside a VirtualBox would do. Now clone the git repository:
<code>bash Cloning git repository
git clone https://github.com/networkop/simple-cisco-tdd.git tdd-acme-inc
cd tdd-acme-int
</code>
Populate Ansible hosts inventory. In this case hosts are assigned to the group corresponding to their site and all the site groups are assigned to a parent group.
``` text ./myhosts
[dc-devices]
DC-CORE ansible_ssh_host=10.0.1.1
DC-WAN1 ansible_ssh_host=10.0.1.2
DC-WAN2 ansible_ssh_host=10.0.1.3</p>

<p>[br1-devices]
BR1-CORE ansible_ssh_host=10.0.2.1
BR1-WAN1 ansible_ssh_host=10.0.2.2
BR1-WAN2 ansible_ssh_host=10.0.2.3</p>

<p>[br2-devices]
BR2-CORE ansible_ssh_host=10.0.3.1
BR2-WAN1 ansible_ssh_host=10.0.3.2
BR2-WAN2 ansible_ssh_host=10.0.3.3</p>

<p>[cisco-devices:children]
dc-devices
br1-devices
br2-devices
```</p>

<p>Optionally, you can define your username/password credentials.</p>

<pre><code class="yaml ./group_vars/cisco-devices.yml">---
ansible_ssh_user: cisco
ansible_ssh_pass: cisco
</code></pre>

<p>Do the IP address information gathering and scenario processing first.
<code>bash Run the fact gathering
./ansible-playbook cisco-ip-collect.yml
</code></p>

<p>Verify that IP addresses and scenarios are now recorded in a global group variable file.
<code>bash Verify the content of all.yml file
cat ./group_vars/all.yml
</code></p>

<h2>Test the default scenario</h2>

<p>Now it&rsquo;s time to test. First, the default scenario:
<code>bash Testing scenario #1
ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 1
...
skipping: [DC-WAN1]
skipping: [BR1-CORE]
skipping: [DC-WAN2]
skipping: [BR1-WAN2]
skipping: [BR2-WAN2]
ok: [BR2-CORE] =&gt; (item={'key': 'DC-CORE', 'value': ['BR2-WAN1', 'DC-WAN1']})
ok: [BR2-WAN1] =&gt; (item={'key': 'BR1-WAN1', 'value': ['BR2-CORE', 'BR1-CORE']})
ok: [BR1-WAN1] =&gt; (item={'key': 'BR2-WAN1', 'value': ['BR1-CORE', 'BR2-CORE']})
ok: [DC-CORE] =&gt; (item={'key': 'BR2-CORE', 'value': ['DC-WAN1', 'BR2-WAN1']})
</code></p>

<p>All tests succeeded.</p>

<h2>Testing the primary link failure</h2>

<p>Now, let&rsquo;s simulate the failure of a primary WAN link by shutting down the uplink on the WAN router:
<code>text BR2-WAN1
BR2-WAN1#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
BR2-WAN1(config)#int eth 0/0
BR2-WAN1(config-if)#shut
</code></p>

<p>And now run the second scenario:
<code>bash Testing scenario #2 - failed
ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 2
...
failed: [DC-CORE] =&gt; (item={'key': 'BR2-CORE', 'value': ['DC-WAN1', 'BR1-WAN1']}) =&gt; {"failed": true, "item": {"key": "BR2-CORE", "value": ["DC-WAN1", "BR1-WAN1"]}}
msg: Failed scenario Primary WAN failed at Branch #2.
Traceroute from DC-CORE to BR2-CORE has not traversed ['DC-WAN1', 'BR1-WAN1']
 Actual path taken: DC-CORE -&gt; DC-WAN2 -&gt; 2.2.2.2 -&gt; BR2-WAN2 -&gt; BR2-CORE
ok: [BR1-WAN2] =&gt; (item={'key': 'BR2-WAN2', 'value': ['BR1-CORE', 'BR2-CORE']})
failed: [BR2-CORE] =&gt; (item={'key': 'DC-CORE', 'value': ['BR1-CORE', 'BR1-WAN1']}) =&gt; {"failed": true, "item": {"key": "DC-CORE", "value": ["BR1-CORE", "BR1-WAN1"]}}
msg: Failed scenario Primary WAN failed at Branch #2.
Traceroute from BR2-CORE to DC-CORE has not traversed ['BR1-CORE', 'BR1-WAN1']
 Actual path taken: BR2-CORE -&gt; BR2-WAN2 -&gt; 2.2.3.2 -&gt; DC-WAN2 -&gt; DC-CORE
ok: [BR2-WAN2] =&gt; (item={'key': 'BR1-WAN2', 'value': ['BR2-CORE', 'BR1-CORE']})
</code></p>

<p>Right, here is where it gets interesting. You see that the two scenarios have failed. Specifically traffic between the new branch and the DC has not traversed the backdoor link preferring the backup WAN instead. So we need to make the backup WAN less preferred. The easiest way is to use <code>as-path prepend</code> feature. Let&rsquo;s modify the configuration of our backup WAN router:</p>

<pre><code class="text BR2-WAN1">route-map RM-BGP-PREPEND-IN permit 10
 set as-path prepend last-as 4
route-map RM-BGP-PREPEND-OUT permit 10
 set as-path prepend 3 3 3 3
!
router bgp 3
neighbor 2.2.3.2 route-map RM-BGP-PREPEND-IN in
neighbor 2.2.3.2 route-map RM-BGP-PREPEND-OUT out
</code></pre>

<p>Now let&rsquo;s run the same test again:</p>

<pre><code class="bash Testing scenario #2 - success">ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 2
ok: [DC-CORE] =&gt; (item={'key': 'BR2-CORE', 'value': ['DC-WAN1', 'BR1-WAN1']})
ok: [BR1-WAN2] =&gt; (item={'key': 'BR2-WAN2', 'value': ['BR1-CORE', 'BR2-CORE']})
ok: [BR2-CORE] =&gt; (item={'key': 'DC-CORE', 'value': ['BR1-CORE', 'BR1-WAN1']})
ok: [BR2-WAN2] =&gt; (item={'key': 'BR1-WAN2', 'value': ['BR2-CORE', 'BR1-CORE']})
</code></pre>

<p>Looks better now. Let&rsquo;s move on.</p>

<h2>Testing the Backdoor link failure</h2>

<p>Next in order, backdoor link failure. First let&rsquo;s restore our primary WAN link first:
<code>text BR2-WAN1
BR2-WAN1#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
BR2-WAN1(config)#int eth 0/0
BR2-WAN1(config-if)#no shut
</code></p>

<p>And bring down the link between the two branches:
<code>text BR2-CORE
BR2-CORE#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
BR2-CORE(config)#int eth 0/2
BR2-CORE(config-if)#shut
</code></p>

<p>Run the third scenario:
<code>bash Testing scenario #3
root@netops:~/quickstart# ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 3
ok: [BR1-WAN2] =&gt; (item={'key': 'BR2-WAN2', 'value': ['BR1-WAN1', 'BR2-WAN1']})
ok: [BR2-WAN2] =&gt; (item={'key': 'BR1-WAN2', 'value': ['BR2-WAN1', 'BR1-WAN1']})
</code></p>

<p>Looking good. Now even the backup WAN routers traverse the primary WAN to talk to each other. Just as we expected.</p>

<h2>Testing of backup WAN</h2>

<p>Finally, let&rsquo;s see what would happen when both primary WAN and backdoor links go down. First, bring down the primary WAN link again:</p>

<pre><code class="text BR2-WAN1">BR2-WAN1#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
BR2-WAN1(config)#int eth 0/0
BR2-WAN1(config-if)#shut
</code></pre>

<p>Run the last scenario:
<code>bash
ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 4
ok: [DC-CORE] =&gt; (item={'key': 'BR2-CORE', 'value': ['DC-WAN2', 'BR2-WAN2']})
ok: [BR1-CORE] =&gt; (item={'key': 'BR2-CORE', 'value': ['BR1-WAN2', 'BR2-WAN2']})
ok: [BR2-CORE] =&gt; (item={'key': 'DC-CORE', 'value': ['BR2-WAN2', 'DC-WAN2']})
ok: [BR2-CORE] =&gt; (item={'key': 'BR1-CORE', 'value': ['BR2-WAN2', 'BR1-WAN2']})
</code></p>

<p>All tests passed. Now the network at the new branch is behaving exactly as we expect it to.</p>

<h2>Conclusion</h2>

<p>The above scenario, of course, is a gross simplification of a real life, however the demonstrated approach can be applied to varied network topologies. The desired state may be achieved through not one but several red-green-refactor cycles. The benefit of using this approach is not only confidence that you haven&rsquo;t broken anything by fixing one particular failure condition scenario, but also for future growth and development, when new devices are added or traffic flows are modified, these same tests can be re-run to ensure that the agreed assumptions still hold.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Verifying TDD Scenarios]]></title>
    <link href="http://networkop.github.io/blog/2015/07/10/test-verification/"/>
    <updated>2015-07-10T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2015/07/10/test-verification</id>
    <content type="html"><![CDATA[<p>Now that Ansible has done all the information gathering for us it&rsquo;s time to finally make use of it. In this post I will show how to use Ansible to run traceroutes from and to the hosts defined in a test scenario and perform verification of the results of those tests. Should any of those tests fail, Ansible will provide a meaningful description of what exactly failed and why. While doing all this I&rsquo;ll introduce a couple of new Ansible features like conditional looping and interactive prompts.</p>

<!--more-->


<h2>TDD Playbook</h2>

<p>In order to run and verify tests I will create a separate playbook. It makes sense to separate it from the <a href="http://networkop.github.io/blog/2015/07/03/parser-modules/">previous playbook</a> simply because this time it will be used multiple times, while the information gathering playbook can only be run once. The new playbook will have to accomplish the following tasks:</p>

<ol>
<li>Select which scenario to test</li>
<li>Run tests as specified in that scenario</li>
<li>Parse test results</li>
<li>Verify that test results conform to the specification</li>
</ol>


<h2>Selecting test scenario</h2>

<p>Our <code>scenarios/all.txt</code> file contains multiple test scenarios each defined by a name. Each test scenario represent a certain state in the network, e.g. scenario #1 tests how the network behaves in a normal state with no outages or link failures, scenario #2 tests how traffic should be rerouted in the event of primary link failure. Inside each scenario there are one or more test steps each testing a behaviour of a particular traffic flow, e.g. traffic from router R1 to router R4 should traverse R2 followed by R3. Each steps contains keywords <code>From</code>, <code>To</code> and <code>Via</code> which identify  source, destination and transit routers. This is how a typical scenario file looks like.</p>

<p>{% codeblock lang:text ~/tdd_ansible/scenarios/all.txt %}
1. Testing of Primary Link
1.1 From R1 to R3 via R2
1.2 From R1 to R4 via R2, R3
1.3 From R2 to R4 via R3
1.4 From R1 to R2 via R2
2. Testing of Backup Link
2.1 From R1 to R3 via R4
2.2 From R1 to R2 via R4,R3
{% endcodeblock  %}</p>

<p>In the <a href="http://networkop.github.io/blog/2015/07/03/parser-modules/">previous post</a> I showed how to parse and store these scenarios in YAML dictionary in <code>group_vars/all.yml</code> file, which makes this information automatically available to any future playbooks. So in the new playbook all we need to do is let the user decide which scenario to test:</p>

<p>{% raw %}</p>

<h2>``` yaml ~/tdd_ansible/cisco_tdd.yml</h2>

<ul>
<li><p>name: Run traceroute commands
hosts: cisco-devices
gather_facts: false
remote_user: cisco</p>

<p>vars_prompt:</p>

<ul>
<li>name: scenario_num
prompt: &ldquo;Enter scenario number&rdquo;
default: &ldquo;1&rdquo;
private: no</li>
</ul>


<p>tasks:</p>

<ul>
<li>name: extracting scenario name and steps
set_fact:
  scenario_steps: &ldquo;{{ scenarios[scenario_num][1] }}&rdquo;
  scenario_name: &ldquo;{{ scenarios[scenario_num][0] }}&rdquo;
```
{% endraw  %}</li>
</ul>
</li>
</ul>


<p>This playbook contains a standard header followed by a <code>vars_prompt</code> section which prompts user to select a particular scenario number and stores the selection in <code>scenario_num</code> variable. The first task in the playbook extracts scenario name and steps from <code>scenarios</code> dictionary stored in <code>group_vars/all.yml</code> file and stores them in respective variables. Of course this task is optional and it&rsquo;s possible to reference the same data using full notation, however I prefer things to be more readable even if it leads to some inefficient memory use.</p>

<h2>Run test specified in scenario steps</h2>

<p>Now it&rsquo;s time to run traceroutes to see how the packets flow in the network. As we did in one of the <a href="http://networkop.github.io/blog/2015/06/24/ansible-intro/">previous posts</a> we&rsquo;ll use the <code>raw</code> module to run traceroutes. However this time, instead of running a full-mesh any-to-any traceroutes we&rsquo;ll only run them if they were defined in one of the test steps. Indeed, why would we run a traceroute between devices if we&rsquo;re not going to verify it? Ansible&rsquo;s conditionals will help us with that. For each of the hosts in <code>cisco-devices</code> group we&rsquo;ll look into scenario_steps dictionary and see if there were any tests defined and if there were, we&rsquo;ll run a traceroute to each of the destination hosts.</p>

<p>{% raw %}
<code>yaml ~/tdd_ansible/cisco_tdd.yml
    - name: run traceroutes as per the defined scenario steps
      raw: traceroute {{ hostvars[item.key]['ansible_ssh_host'] }} source Loopback0 probe 1 numeric
      when: scenario_steps[inventory_hostname] is defined
      with_dict: scenario_steps[inventory_hostname]|default({})
      register: trace_result
</code>
{% endraw  %}</p>

<p>When both a loop (<code>with_dict</code>) and a conditional (<code>when</code>) are defined in a task, Ansible does the looping first. That&rsquo;s why if a test scenario is not defined for a particular host (e.g. <code>R3</code>) the conditional check will fail and stop execution of the playbook. To overcome that we can use Ansible (Jinja) templates inside the <code>with_dict</code> loop. Appending <code>|default({})</code> will instruct Ansible create an empty dictionary in case <code>scenario_steps[inventory_hostname]</code> does not exist which will make conditional return <code>False</code> and skip this host altogether.</p>

<h2>Parse test results</h2>

<p>There&rsquo;s no silver bullet when it comes to parsing of the outcome of traceroute command. We&rsquo;ll have to use Python to traverse the textual output line by line looking for <code>msec</code> and storing all found IPs in a list.</p>

<p>{% codeblock lang:python ~/tdd_ansible/library/cisco_trace_parse.py %}
class TraceParse(object):</p>

<pre><code>def __init__(self, module):
    self.std_out = module.params['std_out']
    self.dest_host = module.params['dest_host']

def parse(self):
    result = dict()
    path = list()
    for line in self.std_out.split("\n"):
        if 'msec' in line:
            path.append(line.split()[1])
    result[self.dest_host] = path
    return result
</code></pre>

<p>def main():
    module = AnsibleModule(
        argument_spec=dict(
            std_out=dict(required=True, type=&lsquo;str&rsquo;),
            dest_host=dict(required=True, type=&lsquo;str&rsquo;)
        )
    )
    traceParser = TraceParse(module)
    result = traceParser.parse()
    module.exit_json(changed=False, ansible_facts=result)</p>

<h1>import module snippets</h1>

<p>from ansible.module_utils.basic import *
main()
{% endcodeblock  %}</p>

<p>The playbook task will run through each hosts' trace_results variable and pass it to the trace parse module.</p>

<p>{% raw %}
<code>yaml ~/tdd_ansible/cisco_tdd.yml
    - name: parse traceroute ouput
      cisco_trace_parse:
        dest_host: "{{ item.item.key }}"
        std_out: "{{ item.stdout }}"
      connection: local
      when: item.stdout is defined
      with_items: trace_result.results
</code>
{% endraw  %}</p>

<h2>Test verification</h2>

<p>Finally we need to compare the captured output with the scenario steps. This time all the information collected by Ansible in the previous tasks needs to be passed to a module.</p>

<p>{% raw %}
<code>yaml ~/tdd_ansible/cisco_tdd.yml
    - name: verify traceroutes against pre-defined scenarios
      cisco_tdd_verify:
        dest_host: "{{ item.key }}"
        src_host: "{{ inventory_hostname }}"
        scenario: "{{ scenario_steps }}"
        ip2host: "{{ ip2host }}"
        path: "{{ hostvars[inventory_hostname][item.key] }}"
        scenario_name: "{{ scenario_name }}"
      when: scenario_steps[inventory_hostname] is defined
      with_dict: scenario_steps[inventory_hostname]|default({})
      connection: local
</code>
{% endraw  %}</p>

<p>Ansible module contains a class with a single public method <code>compare</code>. The first thing it does is converts the list of IP addresses of transit devices into a list of hostnames. That&rsquo;s where the IP-to-Hostname dictionary created in the <a href="http://networkop.github.io/blog/2015/07/03/parser-modules/">previous playbook</a> is first used. IP address is used as a lookup key and the Hostname is extracted from the first element of the returned list (second element, the interface name, is currently unused). The private method <code>__validatepath</code> is used to confirm that devices listed after <code>Via</code> in a test scenario are present in the traceroute path in the specified order. If this verification fails, the whole module fails and the error message is passed back to Ansible playbook.</p>

<p>{% codeblock lang:python ~/tdd_ansible/library/cisco_tdd_verify.py %}
class ResultCompare(object):</p>

<pre><code>def __init__(self, module):
    self.dest_host = module.params['dest_host']
    self.src_host = module.params['src_host']
    self.trace_path = module.params['path']
    self.ref_scenario = module.params['scenario']
    self.ip2host = module.params['ip2host']
    self.scenario_name = module.params['scenario_name']

def compare(self):
    trace_path_new = list()
    for dev in self.trace_path:
        if dev in self.ip2host:
            trace_path_new.append(self.ip2host[dev][0])
        else:
            trace_path_new.append(dev)
    if self.src_host in self.ref_scenario:
        if self.dest_host in self.ref_scenario[self.src_host]:
            ref_path = self.ref_scenario[self.src_host][self.dest_host]
            if not self. __validatepath(trace_path_new):
                msg = "Failed scenario " + self.scenario_name +  ".\r\nTraceroute from " + self.src_host + " to " + self.dest_host + " has not traversed " + str(ref_path)
                msg += "\r\n Actual path taken: " + ' -&gt; '.join([self.src_host] + trace_path_new) + "\r\n"
                return 1, msg
    return 0, 'no error'

def __validatepath(self, path):
    index = 0
    for device in path:
        if device == self.ref_scenario[self.src_host][self.dest_host][index]:
            index += 1
            if index == len(self.ref_scenario[self.src_host][self.dest_host]):
                return True
    return False
</code></pre>

<p>def main():
    module = AnsibleModule(
        argument_spec=dict(
            dest_host=dict(required=True, type=&lsquo;str&rsquo;),
            src_host=dict(required=True, type=&lsquo;str&rsquo;),
            scenario=dict(required=True, type=&lsquo;dict&rsquo;),
            ip2host=dict(required=True, type=&lsquo;dict&rsquo;),
            path=dict(required=True, type=&lsquo;list&rsquo;),
            scenario_name=dict(required=True, type=&lsquo;str&rsquo;)
        )
    )
    comparator = ResultCompare(module)
    rc, error = comparator.compare()
    if rc != 0:
        module.fail_json(msg=error)
    else:
        module.exit_json(changed=False)</p>

<p>from ansible.module_utils.basic import *
main()
{% endcodeblock  %}</p>

<h2>TDD in action</h2>

<p>So let&rsquo;s finally see the whole thing action. First let&rsquo;s modify a <a href="http://networkop.github.io/blog/2015/06/17/dev-env-setup/">4-router topology</a> so that traffic from R1 to R4 is routed via R2 and R3 (a simple <code>delay 9999</code> on Ethernet0/1 will do). Now let&rsquo;s run the first scenario and verify that no errors are displayed.</p>

<p>{% codeblock lang:bash Scenario 1 successful %}
~/tdd_ansible# ansible-playbook cisco_tdd.yml
Enter scenario number [1]:</p>

<p>PLAY [Run traceroute commands] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>
&hellip;
PLAY RECAP </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>********************
R1                         : ok=4    changed=0    unreachable=0    failed=0
R2                         : ok=4    changed=0    unreachable=0    failed=0
R3                         : ok=2    changed=0    unreachable=0    failed=0
R4                         : ok=2    changed=0    unreachable=0    failed=0
{% endcodeblock  %}</p>

<p>Nothing much really, which is good, that means all scenarios were verified successfully. Now let&rsquo;s see how it fails. The easiest way is to run the tests from a second scenario, the one that assumes that the link between R1 and R2 failed and all the traffic is routed via R4.</p>

<p>{% codeblock lang:bash Scenario 2 failed %}
~/tdd_ansible# ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 2</p>

<p>PLAY [Run traceroute commands] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**************************
&hellip;
TASK: [verify traceroutes against pre-defined scenarios] </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
skipping: [R2]
skipping: [R4]
failed: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R2&rsquo;, &lsquo;value&rsquo;: [&lsquo;R4&rsquo;, &lsquo;R3&rsquo;]}) => {&ldquo;failed&rdquo;: true, &ldquo;item&rdquo;: {&ldquo;key&rdquo;: &ldquo;R2&rdquo;, &ldquo;value&rdquo;: [&ldquo;R4&rdquo;, &ldquo;R3&rdquo;]}}
msg: Failed scenario Testing of Backup Link.
Traceroute from R1 to R2 has not traversed [&lsquo;R4&rsquo;, &lsquo;R3&rsquo;]
 Actual path taken: R1 -> R2</p>

<p>failed: [R3] => (item={&lsquo;key&rsquo;: &lsquo;R1&rsquo;, &lsquo;value&rsquo;: [&lsquo;R4&rsquo;]}) => {&ldquo;failed&rdquo;: true, &ldquo;item&rdquo;: {&ldquo;key&rdquo;: &ldquo;R1&rdquo;, &ldquo;value&rdquo;: [&ldquo;R4&rdquo;]}}
msg: Failed scenario Testing of Backup Link.
Traceroute from R3 to R1 has not traversed [&lsquo;R4&rsquo;]
 Actual path taken: R3 -> R2 -> R1</p>

<p>failed: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R3&rsquo;, &lsquo;value&rsquo;: [&lsquo;R4&rsquo;]}) => {&ldquo;failed&rdquo;: true, &ldquo;item&rdquo;: {&ldquo;key&rdquo;: &ldquo;R3&rdquo;, &ldquo;value&rdquo;: [&ldquo;R4&rdquo;]}}
msg: Failed scenario Testing of Backup Link.
Traceroute from R1 to R3 has not traversed [&lsquo;R4&rsquo;]
 Actual path taken: R1 -> R2 -> R3</p>

<p>PLAY RECAP ********************************************************************
           to retry, use: &ndash;limit @/root/cisco_tdd.retry</p>

<p>R1                         : ok=3    changed=0    unreachable=0    failed=1
R2                         : ok=2    changed=0    unreachable=0    failed=0
R3                         : ok=3    changed=0    unreachable=0    failed=1
R4                         : ok=2    changed=0    unreachable=0    failed=0
{% endcodeblock  %}</p>

<p>Here all 3 test steps within a scenario failed. Ansible displayed error messages passed down by our module, specifying the expected and the actual path.<br/>
Now if we simply shutdown Ethernet0/0 of R1 to simulate a link failure and re-run the same scenario all tests will succeed again.</p>

<p>{% codeblock lang:bash Scenario 2 successful %}
~/tdd_ansible# ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 2</p>

<p>PLAY [Run traceroute commands] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>
&hellip;
PLAY RECAP </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>********************
R1                         : ok=4    changed=0    unreachable=0    failed=0
R2                         : ok=2    changed=0    unreachable=0    failed=0
R3                         : ok=4    changed=0    unreachable=0    failed=0
R4                         : ok=2    changed=0    unreachable=0    failed=0
{% endcodeblock  %}</p>

<p>So there it is, a working network TDD framework in action. I still haven&rsquo;t covered a lot of corner cases (e.g. when traceroute times out) and deployment scenarios (device with VRFs) but it should still work for a lot of scenarios and can be easily extended to cover those corner cases.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a Simple Network TDD Framework]]></title>
    <link href="http://networkop.github.io/blog/2015/06/15/simple-tdd-framework/"/>
    <updated>2015-06-15T00:00:00-07:00</updated>
    <id>http://networkop.github.io/blog/2015/06/15/simple-tdd-framework</id>
    <content type="html"><![CDATA[<p>In the following series of posts I will show how to build a simple Test-Driven Development framework
for Cisco devices. This framework will allow a network engineer to define traffic patterns in a human-readable format and automatically check if those assumption hold. It will be built as a series of <a href="http://docs.ansible.com/list_of_files_modules.html">Ansible</a> <em>modules</em> and <em>playbooks</em>. The idea is to show an example of how programming can be used by network engineers even now, before all devices acquire their own APIs as well as introduce some well-known programming paradigms and best practices to network engineers thereby making a small step towards networking nirvana a.k.a. <abbr title="Software-Defined Network">SDN</abbr>. The reader is assumed to have only a basic networking, linux and python programming skills.</p>

<!--more-->


<h2>Before we begin (optional section)</h2>

<p>Before we go on, I&rsquo;d like to put a little disclaimer about terms being used in this post. <abbr title="Test-Driven Development">TDD</abbr>, and its counterpart <abbr title="Behaviour-Driven Development">BDD</abbr>,
are well-known and accepted practices in development world. Both rely on the assumption that tests will be written
before the code and will <em>drive</em> code development. This seemingly unnatural approach became extremely popular with the advent of <a href="http://agilemanifesto.org/">Agile</a> and is still being widely used, specifically in web development. What I will be developing will look more like a BDD rather than TDD, since it will be testing overall system behaviour rather than small self-contained portions of configuration. However, I still prefer to use the term TDD, firstly, because it&rsquo;s easier to understand for people from a non-dev background, secondly, because it&rsquo;s very hard/impossible to test small portions of network configuration (like routing protocol configuration), and lastly, since my tests will rely heavily on traceroutes, TDD may as well stand for Traceroute-Driven Development.</p>

<h2>How will it work?</h2>

<p>Traffic flow patterns, a.k.a. traffic paths is one bit of information that even higher-level management is able to comprehend. With a nice network diagram it is easy to show how low-latency traffic from Network_A will flow to Network_B through private VPN link on Router_X, while an internet-bound traffic will traverse a low-cost, high-latency Internet link on Router_Y. The TDD framework will use the same idea but in a text format</p>

<pre><code class="text TDD scenario file example">1. Testing of Primary Link
  1. From Router1 to Router2 via Router4, Router5
  2. From Router2 to Router1 via Router5, Router4
2. Testing of Backup Link
  1. From Router4 to Router1 via Router3
  2. From Router4 to Router2 via Router7
</code></pre>

<p>This format can be understood by both network engineers and their clients and can be used as a basis for network acceptance and verification testing. At the same time it follows a strictly defined format which can be parsed, processed and actioned by a program. I&rsquo;ll show how to write an Ansible module that parses this text, runs a traceroute and checks if the test was successful.<br/>
These tests can also be used during regression testing of the network each time network configuration changes. This kind of verification offers a much more reliable result compared to visual examination of traceroute results and routing tables.</p>

<h2>Step-by-step procedure</h2>

<p>This is how I see the whole development process now (before I started). Some section may get added/removed in the process. I&rsquo;ll try to write at least one post a week aiming to complete the series in under one month.</p>

<ol>
<li><a href="http://networkop.github.io/blog/2015/06/17/dev-env-setup/">Development environment setup</a></li>
<li><a href="http://networkop.github.io/blog/2015/06/24/ansible-intro/">Getting started with Ansible for Cisco IOS</a></li>
<li><a href="http://networkop.github.io/blog/2015/07/03/parser-modules/">Developing Ansible library to gather facts from Cisco devices</a></li>
<li><a href="http://networkop.github.io/blog/2015/07/10/test-verification/">Developing Ansible library to verify test scenarios</a></li>
</ol>


<p>A <a href="http://networkop.github.io/blog/2015/07/17/tdd-quickstart/">quickstart guide</a> for those interested to see the final product in action.</p>
]]></content>
  </entry>
  
</feed>
