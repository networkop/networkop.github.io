<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Restconf | Network-oriented programming]]></title>
  <link href="http://networkop.github.io/blog/categories/restconf/atom.xml" rel="self"/>
  <link href="http://networkop.github.io/"/>
  <updated>2017-09-19T16:17:42+01:00</updated>
  <id>http://networkop.github.io/</id>
  <author>
    <name><![CDATA[Michael Kashin]]></name>
    <email><![CDATA[mmkashin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Configuring Cisco IOS XE With YDK and OpenDaylight]]></title>
    <link href="http://networkop.github.io/blog/2017/02/22/odl-ydk/"/>
    <updated>2017-02-22T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2017/02/22/odl-ydk</id>
    <content type="html"><![CDATA[<p>Now it&rsquo;s time to turn our gaze to the godfather of YANG models and one of the most famous open-source SDN controllers, OpenDaylight. In this post I&rsquo;ll show how to connect Cisco IOS XE device to ODL and use Yang Development Kit to push a simple BGP configuration through ODL&rsquo;s RESTCONF interface.</p>

<!--more-->


<hr />

<p>In the previous posts about <a href="/blog/2017/01/25/netconf-intro/">NETCONF</a> and <a href="/blog/2017/02/15/restconf-yang/">RESTCONF</a> I&rsquo;ve demonstrated how to interact with Cisco IOS XE device directly from the Linux shell of my development VM. This approach works fine in some cases, e.g. whenever I setup a new DC fabric, I would make calls directly to the devices I&rsquo;m configuring. However, it becomes impractical in the Ops world where change is constant and involves a large number of devices. This is where centralised service orchestrators come to the fore. The prime examples of such platforms are Network Services Orchestrator from Tail-f/Cisco and open-source project OpenDaylight. In this post we&rsquo;ll concentrate on ODL and how to make it work with Cisco IOS XE. Additionally, I&rsquo;ll show how to use an open-source tool <a href="https://developer.cisco.com/site/ydk/">YDK</a> to generate Python bindings for native YANG models and how it compares with <strong>pyangbind</strong>.</p>

<h2>OpenDaylight primer</h2>

<p>OpenDaylight is a swiss army knife of SDN controllers. At the moment it is comprised of dozens of projects implementing all possible sorts of SDN functionality starting from Openflow controller all the way up to L3VPN orchestrator. ODL speaks most of the modern Southbound protocols like Openflow, SNMP, NETCONF and BGP. The brain of the controller is in the Service Abstraction Layer, a framework to model all network-related characteristics and properties. All logic inside SAL is modelled in YANG which is why I called it the godfather of YANG models. Towards the end users ODL exposes Java function calls for applications running on the same host and REST API for application running remotely.</p>

<p>{% img center /images/odl-sal.jpg %}</p>

<p>OpenDaylight has several commercial offerings from companies involved in its development. Most notable ones are from Brocade and Cisco. Here I will allow myself a bit of a rant, feel free to skip it to go straight to the technical stuff.</p>

<p>One thing I find interesting is that Cisco are being so secretive about their Open SDN Controller, perhaps due to the earlier market pressure to come up with a single SDN story, but still have a very large number of contributors to this open-source project. It could be the case of having an egg in each basket, but the number of Cisco&rsquo;s employees involved in ODL development is substantial. I wonder if, now that the use cases for ACI and ODL have finally formed and ACI still not showing the uptake originally expected, Cisco will change their strategy and start promoting ODL more aggressively, or at least stop hiding it deep in the bowels of <a href="cisco.com">cisco.com</a>. Or, perhaps, it will always stay in the shade of Tail-f&rsquo;s NSC and Insieme&rsquo;s ACI and will be used only for customer with unique requirements, e.g. to have both OpenStack and network devices managed through the same controller.</p>

<h2>Environment setup</h2>

<p>We&rsquo;ll use the same environment we&rsquo;ve setup in the <a href="/blog/2017/01/25/netconf-intro/">previous posts</a>, consisting of a CSR1K and a Linux VM connected to the same network inside my hypervisor. IOS XE device needs to have <code>netconf-yang</code> configured in order to enable the northbound NETCONF interface.</p>

<p>On the same Linux VM, I&rsquo;ve downloaded and launched the latest version of ODL (Boron-SR2), and enabled NETCONF and RESTCONF plugins.</p>

<p>{% codeblock lang:bash %}
unzip distribution-karaf-0.5.2-Boron-SR2.zip
mv distribution-karaf-0.5.2-Boron-SR2 odl-0.5.2
cd odl-0.5.2/
./bin/karaf
opendaylight-user@root>feature:install odl-netconf-connector-all
opendaylight-user@root>feature:install odl-restconf-all
{% endcodeblock  %}</p>

<p>We&rsquo;ll use NETCONF to connect to Cisco IOS XE device and RESTCONF to interact with ODL from a Linux shell.</p>

<p>{% img center /images/odl-ydk.png %}</p>

<p>It might be useful to turn on logging in karaf console to catch any errors we might encounter later:</p>

<p>{% codeblock lang:bash %}
opendaylight-user@root>log:tail
{% endcodeblock  %}</p>

<h2>Connecting IOS XE to ODL</h2>

<p>According to ODL <a href="http://docs.opendaylight.org/en/stable-boron/user-guide/netconf-user-guide.html">NETCONF</a> user guide, in order to connect a new device to the controller, we need to create an XML document which will include the IP, port and user credentials of the IOS XE device. Here&rsquo;s the excerpt from the <a href="https://github.com/networkop/yang/blob/master/odl-101/new_device.xml.1">full XML document</a>:</p>

<p>{% codeblock lang:xml %}
<module xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
  <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf">prefix:sal-netconf-connector</type>
  <name>CSR1K</name>
  <address xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf">192.168.145.51</address>
  <port xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf">830</port>
  <username xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf">admin</username>
  <password xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf">admin</password>
{% endcodeblock  %}</p>

<p>Assuming this XML is saved in a file called <a href="https://github.com/networkop/yang/blob/master/odl-101/new_device.xml.1">new_device.xml.1</a>, we can use <code>curl</code> to send it to ODL&rsquo;s netconf-connector plugin:</p>

<p>{% codeblock lang:bash %}
curl -v -k -u admin:admin -H &ldquo;Content-Type: application/xml&rdquo; -X POST \
 <a href="http://localhost:8181/restconf/config/network-topology:network-topology%0A">http://localhost:8181/restconf/config/network-topology:network-topology
</a> /topology/topology-netconf/node/controller-config/yang-ext:mount/config:modules\
  -d @new_device.xml.1
{% endcodeblock  %}</p>

<p>When the controller gets this information it will try to connect to the device via NETCONF and do the following three things:</p>

<ul>
<li>Discover device capabilities advertised in the Hello message</li>
<li>Download all YANG models advertised by the device into the <code>./cache/schema</code> directory</li>
<li>Go through all of the imports in each model and verify that they can be satisfied</li>
</ul>


<p>After ODL downloads all of the 260 available models (can take up to 20 minutes) we will see the following errors in the karaf console:</p>

<p>{% codeblock lang:bash %}
Netconf device does not provide all yang models reported in hello message capabilities
Unable to build schema context, unsatisfied imports
Initialization in sal failed, disconnecting from device
No more sources for schema context
{% endcodeblock  %}</p>

<p>Due to inconsistencies between the advertised and the available models, ODL fails to build the full device YANG schema context, which ultimately results in inability to connect the device to the controller. However, we won&rsquo;t need all of the 260 models advertised by the device. In fact, most of the configuration can be done through a single Cisco native YANG model, <code>ned</code>. With ODL it is possible to override the default capabilities advertised in the Hello message and &ldquo;pin&rdquo; only the ones that are going to be used. Assuming that ODL has downloaded most of the models at the previous step, we can simply tell it use the selected few with the following additions to the <a href="https://github.com/networkop/yang/blob/master/odl-101/new_device.xml.2">XML document</a>:</p>

<p>{% codeblock lang:xml %}
<yang-module-capabilities xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf">
    <override>true</override>
    <capability xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf">
      urn:ietf:params:xml:ns:yang:ietf-inet-types?module=ietf-inet-types&amp;revision=2013-07-15
    </capability>
    <capability xmlns="urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf">
      <a href="http://cisco.com/ns/yang/ned/ios?module=ned&amp;amp;revision=2016-10-24">http://cisco.com/ns/yang/ned/ios?module=ned&amp;amp;revision=2016-10-24</a>
    </capability>
{% endcodeblock  %}</p>

<p>Assuming the updated XML is saved in <a href="https://github.com/networkop/yang/blob/master/odl-101/new_device.xml.2">new_device.xml.2</a> file, the following command will update the current configuration of <strong>CSR1K</strong> device:</p>

<p>{% codeblock lang:bash %}
curl -v -k -u admin:admin -H &ldquo;Content-Type: application/xml&rdquo; -X PUT \
<a href="http://localhost:8181/restconf/config/network-topology:network-topology%0A/topology/topology-netconf/node/controller-config%0A/yang-ext:mount/config:modules/module%0A/odl-sal-netconf-connector-cfg:sal-netconf-connector%0A/CSR1K">http://localhost:8181/restconf/config/network-topology:network-topology
/topology/topology-netconf/node/controller-config
/yang-ext:mount/config:modules/module
/odl-sal-netconf-connector-cfg:sal-netconf-connector
/CSR1K</a> -d @new_device.xml.2
{% endcodeblock  %}</p>

<p>We can then verify that the device has been successfully mounted to the controller:</p>

<p>{% codeblock lang:bash %}
curl -v -k -u admin:admin <a href="http://localhost:8181/restconf/operational%0A/network-topology:network-topology/">http://localhost:8181/restconf/operational
/network-topology:network-topology/</a> | python -m json.tool
{% endcodeblock  %}</p>

<p>The output should look similar to the following with the connection-status set to <code>connected</code> and no detected <code>unavailable-capabilities</code>:</p>

<p>{% codeblock lang:json %}
&ldquo;netconf-node-topology:connection-status&rdquo;: &ldquo;connected&rdquo;,
&ldquo;netconf-node-topology:host&rdquo;: &ldquo;192.168.145.51&rdquo;,
&ldquo;netconf-node-topology:port&rdquo;: 830,
&ldquo;netconf-node-topology:unavailable-capabilities&rdquo;: {},
&ldquo;node-id&rdquo;: &ldquo;CSR1K&rdquo;
{% endcodeblock  %}</p>

<p>At this point we should be able to interact with IOS XE&rsquo;s native YANG model through ODL&rsquo;s RESTCONF interface using the following URL</p>

<p>{% codeblock lang:bash %}
 <a href="http://localhost:8181/restconf/config/network-topology:network-topology%0A">http://localhost:8181/restconf/config/network-topology:network-topology
</a> /topology/topology-netconf/node/CSR1K/yang-ext:mount/ned:native
{% endcodeblock  %}</p>

<p>The only thing that&rsquo;s missing is the actual configuration data. To generate it, I&rsquo;ll use a new open-source tool called YDK.</p>

<h2>YDK primer</h2>

<p>Yang Development Kit is a suite of tools to work with NETCONF/RESTCONF interfaces of a network device. The way I see it, YDK accomplishes two things:</p>

<ul>
<li>Generates API bindings for programming languages (Python and C++) from YANG models</li>
<li>Creates an abstraction layer to interact with southbound protocols (NETCONF or RESTCONF) in a uniform way</li>
</ul>


<p>There&rsquo;s a lot of overlap between the tools that we&rsquo;ve used <a href="/blog/2017/02/15/restconf-yang/">before</a> and YDK. Effectively YDK combines in itself the functions of a NETCONF client, a REST client, pyangbind and pyang(the latter is used internally for model verification). Since one of the main functions of YDK is API generation I thought it&rsquo;d be interesting to know how it compares to Rob Shakir&rsquo;s <strong>pyangbind</strong> plugin. The following information is what I&rsquo;ve managed to find on the Internet and from the comment of Santiago Alvarez below:</p>

<table>
<thead>
<tr>
<th> Feature </th>
<th> Pyangbind </th>
<th> YDK </th>
</tr>
</thead>
<tbody>
<tr>
<td> PL support </td>
<td> Python </td>
<td> Python, C++ with Ruby and Go in the pipeline </td>
</tr>
<tr>
<td> Serialization </td>
<td> JSON, XML </td>
<td> only XML <a href="https://github.com/CiscoDevNet/ydk-gen/blob/master/sdk/python/core/ydk/providers/codec_provider.py#L53">at this stage</a> with JSON coming up in a few weeks </td>
</tr>
<tr>
<td> Southbound interfaces   </td>
<td> N/A </td>
<td> NETCONF, RESTCONF with ODL coming up in a few weeks </td>
</tr>
<tr>
<td> Support </td>
<td> Cisco&rsquo;s devnet team </td>
<td> Rob Shakir </td>
</tr>
</tbody>
</table>


<p>So it looks like YDK is a very promising alternative to <strong>pyangbind</strong>, however I, personally, would still prefer to use <strong>pyangbind</strong> due to familiarity, simplicity and the fact that I don&rsquo;t need the above extra features offered by YDK right now. However, given that YDK has been able to achieve so much in just under one year of its existence, I don&rsquo;t discount the possibility that I may switch to YDK as it becomes more mature and feature-rich.</p>

<h2>Python binding generation with YDK-GEN</h2>

<p>One of the first things we need to do is install YDK-GEN, the tools responsible for API bindings generation, and it&rsquo;s core Python packages on the local machine. The following few commands are my version of the official <a href="https://github.com/CiscoDevNet/ydk-gen">installation procedure</a>:</p>

<p>{% codeblock lang:bash %}
git clone <a href="https://github.com/CiscoDevNet/ydk-gen.git">https://github.com/CiscoDevNet/ydk-gen.git</a> ~/ydk-gen
pip install -r ~/ydk-gen/requirements.txt
export YDKGEN_HOME=~/ydk-gen/
~/ydk-gen/generate.py &ndash;python &ndash;core
pip install ~/ydk-gen/gen-api/python/ydk/dist/ydk*.tar.gz
{% endcodeblock  %}</p>

<p>YDK-GEN generates Python bindings based on the so-called <strong>bundle profile</strong>. This is a simple JSON document which lists all YANG models to include in the output package. In our case we&rsquo;d need to include a <code>ned</code> model along with all its imports. The sample below shows only the model specification. Refer to my <a href="https://github.com/networkop/yang/blob/master/odl-101/cisco-ios-xe_0_1_0.json">Github repo</a> for a complete bundle profile for Cisco IOS XE native YANG model.</p>

<p>{% codeblock lang:json %}
{&ldquo;models&rdquo;:{&ldquo;git&rdquo;:[{&ldquo;url&rdquo;:&ldquo;<a href="https://github.com/YangModels/yang.git">https://github.com/YangModels/yang.git</a>&rdquo;,
  &ldquo;commits&rdquo;:[{&ldquo;commitid&rdquo;:&ldquo;6f4a025431103f8cbbf3405ce01bdc61d0811b1d&rdquo;,
    &ldquo;file&rdquo;:[&ldquo;vendor/cisco/xe/1641/ned.yang&rdquo;,
      &ldquo;vendor/cisco/xe/1641/tailf-common.yang&rdquo;,
      &ldquo;vendor/cisco/xe/1641/tailf-meta-extensions.yang&rdquo;,
      &ldquo;vendor/cisco/xe/1641/tailf-cli-extensions.yang&rdquo;,
      &ldquo;standard/ietf/RFC/ietf-inet-types.yang&rdquo;,
      &ldquo;standard/ietf/RFC/ietf-yang-types.yang&rdquo;]
      }]}]}}
{% endcodeblock  %}</p>

<p>Assuming that the IOS XE bundle profile is saved in a file called <a href="https://github.com/networkop/yang/blob/master/odl-101/cisco-ios-xe_0_1_0.json">cisco-ios-xe_0_1_0.json</a>, we can use YDK to generate and install the Python binding package:</p>

<p>{% codeblock lang:bash %}
~/ydk-gen/generate.py &ndash;python &ndash;bundle cisco-ios-xe_0_1_0.json -v
pip install ~/ydk-gen/gen-api/python/cisco_ios_xe-bundle/dist/ydk*.tar.gz
{% endcodeblock  %}</p>

<h2>Configuring BGP with YDK</h2>

<p>Now we can start configuring BGP using our newly generated Python package. First, we need to create an instance of BGP configuration data:</p>

<p>{% codeblock lang:python %}
from ydk.models.cisco_ios_xe.ned import Native
bgp = Native().router.Bgp()
{% endcodeblock  %}</p>

<p>The configuration will follow the pattern defined in the original model, which is why it&rsquo;s important to understand <a href="/blog/2017/02/15/restconf-yang/">the internal structure</a> of a YANG model. YANG leafs are represented as simple instance attributes. All YANG containers need to be explicitly instantiated, just like the <code>Native</code> and <code>Bgp</code> classes in the example above. Presence containers (<code>router</code> in the above example) will be instantiated at the same time as its parent container, inside the <code>__init__</code> function of the <code>Native</code> class. Don&rsquo;t worry if this doesn&rsquo;t make sense, use <strong>iPython</strong> or any IDE with autocompletion and after a few tries, you&rsquo;ll get the hang of it.</p>

<p>Let&rsquo;s see how we can set the local BGP AS number and add a new BGP peer to the neighbor list.</p>

<p>{% codeblock lang:python %}
bgp.id = 100
new_neighbor = bgp.Neighbor()
new_neighbor.id = &lsquo;2.2.2.2&rsquo;
new_neighbor.remote_as = 65100
bgp.neighbor.append(new_neighbor)
{% endcodeblock  %}</p>

<p>At this point of time all data is stored inside the instance of a <code>Bgp</code> class. In order to get an XML representation of it, we need to use YDK&rsquo;s XML provider and encoding service:</p>

<p>{% codeblock lang:python %}
from ydk.providers import CodecServiceProvider
from ydk.services import CodecService
provider = CodecServiceProvider(type=&ldquo;xml&rdquo;)
codec = CodecService()
xml_string = codec.encode(provider, bgp)
print xml_string
{% endcodeblock  %}</p>

<p>All what we&rsquo;ve got left now is to send the data to ODL:</p>

<p>{% codeblock lang:python %}
import requests
url = (&ldquo;<a href="http://localhost:8181/restconf">http://localhost:8181/restconf</a>&rdquo;
       &ldquo;/config/network-topology:network-topology&rdquo;
       &ldquo;/topology/topology-netconf/node&rdquo;
       &ldquo;/CSR1K/yang-ext:mount/ned:native&rdquo;
       &ldquo;/router&rdquo;)
headers = {&lsquo;Content-Type&rsquo;: &lsquo;application/xml&rsquo;}
result = requests.post(url, auth=(&lsquo;admin&rsquo;, &lsquo;admin&rsquo;), headers=headers, data=xml_string)
print result.status_code
{% endcodeblock  %}</p>

<p>The controller should have returned the status code <code>204 No Content</code>, meaning that configuration has been changed successfully.</p>

<h2>Verification</h2>

<p>Back at the IOS XE CLI we can see the new BGP configuration that has been pushed down from the controller.</p>

<p>{% codeblock lang:text %}
TEST#sh run | i router
router bgp 100
 bgp log-neighbor-changes
 neighbor 2.2.2.2 remote-as 65100
{% endcodeblock  %}</p>

<h2>More examples</h2>

<p>You can find a shorter version of the above procedure in my <a href="https://github.com/networkop/yang/tree/master/odl-101">ODL 101 repo</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to YANG Programming and RESTCONF on Cisco IOS XE]]></title>
    <link href="http://networkop.github.io/blog/2017/02/15/restconf-yang/"/>
    <updated>2017-02-15T00:00:00+00:00</updated>
    <id>http://networkop.github.io/blog/2017/02/15/restconf-yang</id>
    <content type="html"><![CDATA[<p>The sheer size of some of the YANG models can scare away even the bravest of network engineers. However, as it is with any programming language, the complexity is built out of a finite set of simple concepts. In this post we&rsquo;ll learn some of these concepts by building our own YANG model to program static IP routes on Cisco IOS XE.</p>

<!--more-->


<hr />

<p>  In the <a href="/blog/2017/01/25/netconf-intro/">previous post</a> I have demonstrated how to make changes to interface configuration of Cisco IOS XE device using the standard <strong>IETF</strong> model. In this post I&rsquo;ll show how to use Cisco&rsquo;s <strong>native</strong> YANG model to modify static IP routes. To make things even more interesting I&rsquo;ll use RESTCONF, an HTTP-based sibling of NETCONF.</p>

<h2>RESTCONF primer</h2>

<p><a href="https://www.rfc-editor.org/rfc/rfc8040.txt">RESTCONF</a> is a very close functional equivalent of NETCONF. Instead of SSH, RESTCONF relies on HTTP to interact with configuration data and operational state of the network device and encodes all exchanged data in either XML or JSON. RESTCONF borrows the idea of Create-Read-Update-Delete operations on resources from <a href="/blog/2016/01/01/rest-for-neteng/">REST</a> and maps them to YANG models and datastores. There is a direct relationship between NETCONF operations and RESTCONF HTTP verbs:</p>

<table>
<thead>
<tr>
<th> HTTP VERB </th>
<th> NETCONF OPERATION </th>
</tr>
</thead>
<tbody>
<tr>
<td> POST      </td>
<td> create            </td>
</tr>
<tr>
<td> PUT       </td>
<td> replace           </td>
</tr>
<tr>
<td> PATCH     </td>
<td> merge             </td>
</tr>
<tr>
<td> DELETE    </td>
<td> delete            </td>
</tr>
<tr>
<td> GET       </td>
<td> get/get-config    </td>
</tr>
</tbody>
</table>


<p>Both RESTfullness and the ability to encode data as JSON make RESTCONF a very attractive choice for application developers. In this post, for the sake of simplicity, we&rsquo;ll use Python CLI and <code>curl</code> to interact with RESTCONF API. In the upcoming posts I&rsquo;ll show how to implement the same functionality inside a simple Python library.</p>

<h2>Environment setup</h2>

<p>We&rsquo;ll pick up from where we left our environment in the <a href="/blog/2017/01/25/netconf-intro/">previous post</a> right after we&rsquo;ve configured a network interface. The following IOS CLI command enables RESTCONF&rsquo;s root URL at <code>http://192.168.145.51/restconf/api/</code></p>

<p>{% codeblock lang:text %}
CSR1k(config)#restconf
{% endcodeblock  %}</p>

<p>You can start exploring the structure of RESTCONF interface starting at the root URL by specifying resource names separated by &ldquo;/&rdquo;. For example, the following command will return all configuration from Cisco&rsquo;s native datastore.</p>

<p>{% codeblock lang:text %}
curl -v -k admin:admin <a href="http://192.168.145.51/restconfi/api/config/native?deep">http://192.168.145.51/restconfi/api/config/native?deep</a>
{% endcodeblock  %}</p>

<p>In order to get JSON instead of the default XML output the client should specify JSON media type <code>application/vnd.yang.datastore+json</code> and pass it in the <code>Accept</code> header.</p>

<h2>Writing a YANG model</h2>

<p><a href="/blog/2017/01/25/netconf-intro/">Normally</a>, you would expect to download the YANG model from the device itself. However IOS XE&rsquo;s NETCONF and RESTCONF support is so new that not all of the models are available. Specifically, Cisco&rsquo;s native YANG model for static routing cannot be found in either <a href="https://github.com/YangModels">Yang Github Repo</a> or the device itself (via <code>get_schema</code> RPC), which makes it a very good candidate for this post.</p>

<blockquote><p><strong>Update 13-02-2017</strong>: As it turned out, the model was right under my nose the whole time. It&rsquo;s called <code>ned</code> and encapsulates the whole of Cisco&rsquo;s native datastore. So think of everything that&rsquo;s to follow as a simple learning exercise, however the point I raise in the closing paragraph still stands.</p></blockquote>

<p>The first thing we need to do is get an understanding of the structure and naming convention of the YANG model. The simplest way to do that would be to make a change on the CLI and observe the result via RESTCONF.</p>

<h3>Retrieving running configuration data</h3>

<p>Let&rsquo;s start by adding the following static route to the IOS XE device:</p>

<p>{% codeblock lang:text %}
ip route 2.2.2.2 255.255.255.255 GigabitEthernet2
{% endcodeblock  %}</p>

<p>Now we can view the configured static route via RESTCONF:</p>

<p>{% codeblock lang:bash %}
curl -v -k -u admin:admin -H &ldquo;Accept: application/vnd.yang.data+json&rdquo; \
 <a href="http://192.168.145.51/restconf/api/config/native/ip/route?deep">http://192.168.145.51/restconf/api/config/native/ip/route?deep</a>
{% endcodeblock  %}</p>

<p>The returned output should look something like this:</p>

<p>{% codeblock lang:json %}
{ &ldquo;ned:route&rdquo;: {
    &ldquo;ip-route-interface-forwarding-list&rdquo;: [
      { &ldquo;prefix&rdquo;: &ldquo;2.2.2.2&rdquo;,
        &ldquo;mask&rdquo;: &ldquo;255.255.255.255&rdquo;,
        &ldquo;fwd-list&rdquo;: [ { &ldquo;fwd&rdquo;: &ldquo;GigabitEthernet2&rdquo; } ]
      }
    ]
  }
}
{% endcodeblock  %}</p>

<p>This JSON object gives us a good understanding of how the YANG model should look like. The root element <code>route</code> contains a list of IP prefixes, called <code>ip-route-interface-forwarding-list</code>. Each element of this list contains values for IP network and mask as well as the list of next-hops called <code>fwd-list</code>. Let&rsquo;s see how we can map this to YANG model concepts.</p>

<h3>Building a simple YANG model</h3>

<p>YANG <a href="https://tools.ietf.org/html/rfc6020">RFC</a> defines a number of data structures to model an XML tree. Let&rsquo;s first concentrate on the three most fundamental data structures that constitute the biggest part of any YANG model:</p>

<ul>
<li><strong>Container</strong> is a node of a tree with a unique name which encloses a set of child elements. In JSON it is mapped to a name/object pair <code>'name': {...}</code></li>
<li><strong>Leaf</strong> is a node which contains a value and does not contain any child elements. In JSON leaf is mapped to a single key/value pair <code>'name': 'value'</code></li>
<li><strong>List</strong> can be thought of as a table that contains a set rows (list entries). Each list entry can contain Leafs, Containers and other elements and can be uniquely identified by at least one Leaf element called a <code>key</code>. In JSON lists are encoded as name/arrays pairs containing JSON objects <code>'name': [{...}, {...}]</code></li>
</ul>


<p>Now let&rsquo;s see how we can describe the received data in terms of the above data structures:</p>

<ul>
<li>The value of the topmost <code>route</code> element is a JSON object, therefore it can only be mapped to a YANG container.</li>
<li>The value of <code>ip-route-interface-forwarding-list</code> is an array of JSON objects, therefore it must be a list.</li>
<li>The only entry of this list contains <code>prefix</code> and <code>mask</code> key/value pairs. Since they don&rsquo;t contain any child elements and their values are strings they can only be mapped to YANG leafs.</li>
<li>The third element, <code>fwd-list</code>, is another YANG list and so far contains a single next-hop value inside a YANG leaf called <code>fwd</code>.</li>
<li>Finally, since <code>fwd</code> is the only leaf in the <code>fwd-list</code> list, it must be that lists' key. The <code>ip-route-interface-forwarding-list</code> list will have both <code>prefix</code> and <code>mask</code> as its key values since their combination represents a unique IP destination.</li>
</ul>


<p>With all that in mind, this is how a skeleton of our YANG model will look like:</p>

<p>{% codeblock lang:json %}
module cisco-route-static {
  namespace &ldquo;<a href="http://cisco.com/ns/yang/ned/ios">http://cisco.com/ns/yang/ned/ios</a>&rdquo;;
  prefix ned;
  container route {
    list ip-route-interface-forwarding-list {
      key &ldquo;prefix mask&rdquo;;
      leaf prefix { type string; }
      leaf mask { type string; }
      list fwd-list {
        key &ldquo;fwd&rdquo;;
        leaf fwd { type string; }
      }
    }
  }
}
{% endcodeblock  %}</p>

<p>YANG&rsquo;s syntax is pretty light-weight and looks very similar to JSON. The topmost <code>module</code> defines the model&rsquo;s name and encloses all other elements. The first two statements are used to define XML namespace and prefix that I&rsquo;ve described in my <a href="/blog/2017/01/25/netconf-intro/">previous post</a>.</p>

<h3>Refactoring a YANG model</h3>

<p>At this stage the model can already be instantiated by <strong>pyang</strong> and <strong>pyangbind</strong>, however there&rsquo;s a couple of very important changes and additions that I wanted to make to demonstrate some of the other features of YANG.</p>

<p>The first of them is common IETF data types. So far in our model we&rsquo;ve assumed that prefix and mask can take <strong>any</strong> value in string format. But what if we wanted to check that the values we use are, in fact, the correctly-formatted IPv4 addresses and netmasks before sending them to the device? That is where IETF common data types come to the rescue. All what we need to do is add an import statement to define which model to use and we can start referencing them in our type definitions:</p>

<p>{% codeblock lang:json %}
&hellip;
import ietf-yang-types { prefix &ldquo;yang&rdquo;; }
import ietf-inet-types { prefix &ldquo;inet&rdquo;; }
&hellip;
leaf prefix { type inet:ipv4-address; }
leaf mask { type yang:dotted-quad; }
{% endcodeblock  %}</p>

<p>This solves the problem for the prefix part of a static route but how about its next-hop? Next-hops can be defined as either strings (representing an interface name) or IPv4 addresses. To make sure we can use either of these two types in the <code>fwd</code> leaf node we can define its type as a <code>union</code>. This built-in type is literally a union, a logical OR, of all its member elements. This is how we can change the <code>fwd</code> leaf definition:</p>

<p>{% codeblock lang:json %}
&hellip;
typedef ip-next-hop {
  type union {
    type inet:ipv4-address;
    type string;
  }
}
&hellip;
leaf fwd { type ip-next-hop; }
{% endcodeblock  %}</p>

<p>So far we&rsquo;ve been concentrating on the simplest form of a static route, which doesn&rsquo;t include any of the optional arguments. Let&rsquo;s add the leaf nodes for name, AD, tag, track and permanent options of the static route:</p>

<p>{% codeblock lang:json %}
&hellip;
leaf metric { type uint8; }
leaf name { type string; }
leaf tag { type uint8; }
leaf track { type uint8; }
leaf permanent { type empty; }
&hellip;
{% endcodeblock  %}</p>

<p>Since <strong>track</strong> and <strong>permanent</strong> options are mutually exclusive they should not appear in the configuration at the same time. To model that we can use the <code>choice</code> YANG statement. Let&rsquo;s remove the <strong>track</strong> and <strong>permanent</strong> leafs from the model and replace them with this:</p>

<p>{% codeblock lang:json %}
choice track-or-perm {
  leaf track { type uint8; }
  leaf permanent { type empty; }
}
{% endcodeblock  %}</p>

<p>And finally, we need to add an options for VRF. When VRF is defined the whole <code>ip-route-interface-forwarding-list</code> gets encapsulated inside a list called <code>vrf</code>. This list has just one more leaf element <code>name</code> which plays the role of this lists' key. In order to model this we can use another oft-used YANG concept called <code>grouping</code>. I like to think of it as a Python function, a reusable part of code that can be referenced multiple times by its name. Here are the final changes to our model to include the VRF support:</p>

<p>{% codeblock lang:json %}
grouping ip-route-list {
  list ip-route-interface-forwarding-list {
      &hellip;
  }
}
grouping vrf-grouping {
  list vrf {
    key &ldquo;name&rdquo;;
    leaf name { type string; }
    uses ip-route-list;
  }
}
container route {
  uses vrf-grouping;
  uses ip-route-list;
}
{% endcodeblock  %}</p>

<p>Each element in a YANG model is optional by default, which means that the <code>route</code> container can include any number of VRF and non-VRF routes. The full YANG model can be found <a href="https://github.com/networkop/yang/blob/master/yang-101/cisco-route-static.yang">here</a>.</p>

<h2>Modifying static route configuration</h2>

<p>Now let me demonstrate how to use our newly built YANG model to change the next-hop of an existing static route. Using <a href="https://github.com/mbj4668/pyang">pyang</a> we need to generate a Python module based on the YANG model.</p>

<p>{% codeblock lang:bash %}
pyang &ndash;plugindir $PYBINDPLUGIN -f pybind -o binding.py cisco-route-static.yang
{% endcodeblock  %}</p>

<p>From a Python shell, download the current static IP route configuration:</p>

<p>{% codeblock lang:python %}
import requests
url = &ldquo;<a href="http://">http://</a>{h}:{p}/restconf/api/config/native/ip/route?deep&rdquo;.format(h=&lsquo;192.168.145.51&rsquo;, p=&lsquo;80&rsquo;)
headers = {&lsquo;accept&rsquo;: &lsquo;application/vnd.yang.data+json&rsquo;}
result = requests.get(url, auth=(&lsquo;admin&rsquo;, &lsquo;admin&rsquo;), headers=headers)
current_json = result.text
{% endcodeblock  %}</p>

<p>Import the downloaded JSON into a YANG model instance:</p>

<p>{% codeblock lang:python %}
import binding
import pyangbind.lib.pybindJSON as pybindJSON
model = pybindJSON.loads_ietf(current_json, binding, &ldquo;cisco_route_static&rdquo;)
{% endcodeblock  %}</p>

<p>Delete the old next-hop and replace it with <strong>12.12.12.2</strong>:</p>

<p>{% codeblock lang:python %}
route = model.route.ip_route_interface_forwarding_list[&ldquo;2.2.2.2 255.255.255.255&rdquo;]
route.fwd_list.delete(&ldquo;GigabitEthernet2&rdquo;)
route.fwd_list.add(&ldquo;12.12.12.2&rdquo;)
{% endcodeblock  %}</p>

<p>Save the updated model in a JSON file with the help of a <a href="https://github.com/networkop/yang/blob/master/yang-101/helpers.py">write_file</a> function:</p>

<p>{% codeblock lang:python %}
json_data = pybindJSON.dumps(model, mode=&lsquo;ietf&rsquo;)
write_file(&lsquo;new_conf.json&rsquo;, json_data)
{% endcodeblock  %}</p>

<h2>Updating running configuration</h2>

<p>If we tried sending the <code>new_conf.json</code> file now, the device would have responded with an error:</p>

<p>{% codeblock lang:text %}
missing element: prefix in /ios:native/ios:ip/ios:route/ios:ip-route-interface-forwarding-list
{% endcodeblock  %}</p>

<p>In our JSON file the order of elements inside a JSON object can be different from what was defined in the YANG model. This is expected since one of the fundamental principles of JSON is that an object is an <strong>unordered</strong> collection of name/value pairs. However it looks like behind the scenes IOS XE converts JSON to XML before processing and expects all elements to come in a strict, predefined order. Fortunately, this <a href="https://github.com/CiscoDevNet/openconfig-getting-started/issues/4">bug</a> is already known and we can hope that Cisco will implement the fix for IOS XE soon. In the meantime, we&rsquo;re gonna have to resort to sending XML.</p>

<p>Following the procedure described in my <a href="/blog/2017/01/25/netconf-intro/">previous post</a>, we can use <strong>json2xml</strong> tool to convert our instance into an XML document. Here we hit another issue. Since <strong>json2xml</strong> was designed to produce a NETCONF-compliant XML, it wraps the payload inside a <strong>data</strong> or a <strong>config</strong> element. Thankfully, <strong>json2xml</strong> is a Python script and can be easily patched to produce a RESTCONF-compliant XML. The following is a diff between the original and the patched files</p>

<p>{% codeblock lang:text %}
408c409</p>

<h2>&lt;     if args.target not in [&ldquo;data&rdquo;, &ldquo;config&rdquo;]:</h2>

<blockquote><pre><code>if args.target not in ["data", "config", "restconf"]:
</code></pre>

<p>437c438,442</p>

<h2>&lt;     ET.ElementTree(root_el).write(outfile, encoding=&ldquo;utf-8&rdquo;, xml_declaration=True)</h2>

<pre><code>if args.target != 'restconf':
    ET.ElementTree(root_el).write(outfile, encoding="utf-8", xml_declaration=True)
else:
    ET.ElementTree(list(root_el)[0]).write(outfile, encoding="utf-8", xml_declaration=True)
</code></pre>

<p>{% endcodeblock  %}</p></blockquote>

<p>Instead of patching the original file, I&rsquo;ve applied the above changes to a local copy of the file. Once patched, the following commands should produce the needed XML.</p>

<p>{% codeblock lang:bash %}
pyang -f jtox -o static-route.jtox cisco-route-static.yang
./json2xml -t restconf -o new_conf.xml static-route.jtox new_conf.json
{% endcodeblock  %}</p>

<p>The final step would be to send the generated XML to the IOS XE device. Since we are replacing the old static IP route configuration we&rsquo;re gonna have to use HTTP PUT to overwrite the old data.</p>

<p>{% codeblock lang:bash %}
curl -v -k -u admin:admin -H &ldquo;Content-Type: application/vnd.yang.data+xml&rdquo; \
 -X PUT <a href="http://192.168.145.51/restconf/api/config/native/ip/route/">http://192.168.145.51/restconf/api/config/native/ip/route/</a> -d @new_conf.xml
{% endcodeblock  %}</p>

<h2>Verification</h2>

<p>Back at the IOS XE CLI we can see the new static IP route installed.
{% codeblock lang:text %}
TEST#sh run | i ip route
ip route 2.2.2.2 255.255.255.255 12.12.12.2
{% endcodeblock  %}</p>

<h2>More examples</h2>

<p>As always there are more examples available in my <a href="https://github.com/networkop/yang/tree/master/yang-101">YANG 101 repo</a></p>

<hr />

<p>The exercise we&rsquo;ve done in this post, though useful from a learning perspective, can come in very handy when dealing with vendors who forget or simply don&rsquo;t want to share their YANG models with their customers (I know of at least one vendor that would only publish tree representations of their YANG models). In the upcoming posts I&rsquo;ll show how to create a simple Python library to program static routes via RESTCONF and finally how to build an Ansible module to do that.</p>
]]></content>
  </entry>
  
</feed>
