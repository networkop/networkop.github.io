<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ansible | Network-oriented programming]]></title>
  <link href="http://networkop.github.io/blog/categories/ansible/atom.xml" rel="self"/>
  <link href="http://networkop.github.io/"/>
  <updated>2017-09-19T16:17:42+01:00</updated>
  <id>http://networkop.github.io/</id>
  <author>
    <name><![CDATA[Michael Kashin]]></name>
    <email><![CDATA[mmkashin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using YANG Models in Ansible to Configure and Verify State of IOS-XE and JUNOS Devices]]></title>
    <link href="http://networkop.github.io/blog/2017/04/04/ansible-yang/"/>
    <updated>2017-04-04T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2017/04/04/ansible-yang</id>
    <content type="html"><![CDATA[<p>In this post I will show how to use IETF, OpenConfig and vendor-specific YANG models in Ansible to configure BGP peering and verify state of physical interfaces between IOS-XE and JUNOS devices.</p>

<!--more-->


<p>The idea of using Ansible for <a href="http://networkop.co.uk/blog/2015/08/26/automating-network-build-p1/">configuration changes</a> and <a href="https://github.com/networktocode/ntc-ansible">state verification</a> is not new. However the approach I&rsquo;m going to demonstrate in this post, using YANG and NETCONF, will have a few notable differences:</p>

<ol>
<li>I will not use any templates and absolutely no XML/JSON for device config generation</li>
<li>All changes will be pushed through a single, vendor and model-independent Ansible module</li>
<li>State verification will be done with no pattern-matching or screen-scraping</li>
<li>All configuration and operational state will be based on a couple of YAML files</li>
<li>To demonstrate the model-agnostic behaviour I will use a mixture of vendor&rsquo;s native, IETF and OpenConfig YANG models</li>
</ol>


<p>I hope this promise is exciting enough so without further ado, let&rsquo;s get cracking.</p>

<h2>Environment setup</h2>

<p>The test environment will consist of a single instance of CSR1000v running IOS-XE version 16.4.1 and a single instance of vMX running JUNOS version 17.1R1.8. The VMs containing the two devices are deployed within a single hypervisor and connected with one interface to the management network and back-to-back with the second  pair of interfaces for BGP peering.</p>

<p>{% img center /images/ansible-yang.png %}</p>

<p>Each device contains some basic initial configuration to allow it be reachable from the Ansible server.</p>

<pre><code class="text IOS-XE initial configuration">interface GigabitEthernet1
ip address 192.168.145.51 255.255.255.0
!
netconf-yang
netconf-yang cisco-odm polling enable
netconf-yang cisco-odm actions parse Interfaces
</code></pre>

<p>vMX configuration is quite similar. Static MAC address is <a href="http://noshut.ru/2015/09/how-to-run-juniper-vmx-in-unetlab/">required</a> in order for <code>ge</code> interfaces to work.</p>

<pre><code class="text vMX initial configuration">set system login user admin class super password admin123
set system services netconf
set interface fxp0 unit 0 family inet address 192.168.145.53/24
set interface ge-0/0/0 mac 00:0c:29:fc:1a:b7
</code></pre>

<h2>Ansible playbook configuration</h2>

<p>My <a href="https://github.com/networkop/yang/tree/master/ansible-101">Ansible-101</a> repository contains two plays - one for configuration and one for state verification. The local inventory file contains details about the two devices along with the login credentials. All the work will be performed by a custom Ansible module stored in the <code>./library</code> directory. This module is a wrapper for a <code>ydk_yaml</code> module described in my <a href="/blog/2017/03/13/yaml-yang/">previous post</a>. I had to heavily modify the original <code>ydk_yaml</code> module to work around some Ansible limitations, like the lack of support for <strong>set</strong> data structures.<br/>
This custom Ansible module also relies on a number of <a href="/blog/2017/02/22/odl-ydk/">YDK</a> Python bindings to be pre-installed. Refer to my <a href="https://github.com/networkop/yang/tree/master/yaml-101">YAML</a>, <a href="https://github.com/networkop/yang/tree/master/oper-101">Operational</a> and <a href="https://github.com/networkop/yang/tree/master/junos-101">JUNOS</a> repositories for the instructions on how to install those modules.<br/>
The desired configuration and expected operational state are documented inside a couple of device-specific host variable files. For each device there is a configuration file <code>config.yaml</code>, describing the desired configuration state. For IOS-XE there is an additional file <code>verify.yaml</code>, describing the expected operational state using the IETF interface YANG model (I couldn&rsquo;t find how to get the IETF or OpenConfig state models to work on Juniper). <br/>
All of these files follow the same structure:</p>

<ul>
<li>Root container can be either <code>config</code> or <code>verify</code> and defines how the enclosed data is supposed to be used</li>
<li>First nested container has to match the top-most container of a YANG model. For example it could be <strong>bgp-state</strong> for <a href="https://github.com/YangModels/yang/blob/master/vendor/cisco/xe/1641/cisco-bgp-state.yang">cisco-bgp-state.yang</a> or <strong>openconfig-bgp</strong> for <a href="https://github.com/openconfig/public/blob/master/release/models/bgp/openconfig-bgp.yang">openconfig-bgp.yang</a> model</li>
<li>The remaining nested data has to follow the structure of the original YANG model as described in my <a href="/blog/2017/03/13/yaml-yang/">previous post</a>.</li>
</ul>


<p>Here&rsquo;s how IOS-XE will be configured, using IETF interfaca YANG models (to unshut the interface) and Cisco&rsquo;s native YANG model for interface IP and BGP settings:</p>

<h2>{% codeblock lang:yaml %}</h2>

<p>config:
  interfaces:
    interface:
      - name: GigabitEthernet3
        enabled: true
  native:
    interface:
      gigabitethernet:
        - name: &lsquo;3&rsquo;
          description: P2P link
          ip:
            address:
              primary:
                address: 12.12.12.1
                mask: 255.255.255.0
      loopback:
        - name: 0
          description: ROUTER ID
          ip:
            address:
              primary:
                address: 1.1.1.1
                mask: 255.255.255.255
    router:
      bgp:
        - id: 65111
          bgp:
            router_id: 1.1.1.1
          neighbor:
            - id: 12.12.12.2
              remote_as: 65222
          redistribute:
            connected:
              empty: empty
{% endcodeblock %}</p>

<p>For JUNOS configuration, instead of the default humongous native model, I&rsquo;ll use a set of much more light-weight OpenConfig YANG models to configure interfaces, BGP and redistribution policies:</p>

<h2>{% codeblock lang:yaml %}</h2>

<p>config:
  openconfig-interfaces:
    interface:
      - name: ge-0/0/0
        subinterfaces:
          subinterface:
            - index: 0
              ipv4:
                addresses:
                  address:
                    - ip: 12.12.12.2/24
                      config:
                        ip: 12.12.2.2
                        prefix_length: 24
      - name: lo0
        subinterfaces:
          subinterface:
            - index: 0
              ipv4:
                addresses:
                  address:
                    - ip: 2.2.2.2/32
                      config:
                        ip: 2.2.2.2
                        prefix_length: 32
  openconfig-policy:
    policy_definitions:
      policy_definition:
        - name: CONNECTED->BGP
          statements:
            statement:
              - name: Loopback0
                conditions:
                  match_interface:
                    config:
                      interface: lo0
                      subinterface: 0
                actions:
                  config:
                    accept_route: empty
  openconfig-bgp:
    global<em>:
      config:
        as</em>: 65222
    neighbors:
      neighbor:
        - neighbor_address: 12.12.12.1
          config:
            peer_group: YANG
            peer_as: 65111
    peer_groups:
      peer_group:
        - peer_group_name: YANG
          config:
            peer_as: 65111
          apply_policy:
            config:
              export_policy:
                - CONNECTED->BGP
{% endcodeblock %}</p>

<h2>Configuration</h2>

<p>Both devices now can be configured with just a single command:</p>

<p>{% codeblock lang:bash %}
ansible-playbook config.yaml
{% endcodeblock  %}</p>

<p>Behind the scenes, Ansible calls my custom <code>ydk_module</code> and passes to it the full configuration state and device credentials. This module then constructs an empty YDK binding based on the name of a YANG model and <a href="/blog/2017/03/13/yaml-yang/">populates it recursively</a> with the data from the <code>config</code> container. Finally, it pushes the data to the device with the help of YDK NETCONF service provider.</p>

<h2>Verification</h2>

<p>There&rsquo;s one side to YANG which I have carefully avoided until now and it&rsquo;s operational state models. These YANG models are built similarly to configuration models, but with a different goal - to extract the running state from a device. The reason why I&rsquo;ve avoided them is that, unlike the configuration models, the current support for state models is limited and somewhat brittle.<br/>
For example, JUNOS natively only supports state models as RPCs, where each RPC represents a certain <code>show</code> command which, I assume, when passed to the devices gets evaluated, its output parsed and result returned back to the client. With IOX-XE things are a little better with a few of the operational models available in the current 16.4 release. You can check out my <a href="https://github.com/networkop/yang/tree/master/oper-101">Github repo</a> for some examples of how to check the interface and BGP neighbor state between the two IOS-XE devices. However, most of the models are still missing (I&rsquo;m not counting the MIB-mapped YANG models) in the current release. The next few releases, though, are promised to come with an improved state model support, including some OpenConfig models, which is going to be super cool.<br/>
So in this post, since I couldn&rsquo;t get JUNOS OpenConfig models report any state and my IOS-XE BGP state model wouldn&rsquo;t return any output unless the BGP peering was with another Cisco device or in the <strong>Idle</strong> state, I&rsquo;m going to have to resort to simply checking the state of physical interfaces. This is how a sample operational state file would look like (question marks are YAML&rsquo;s special notation for sets which is how I decided to encode Enum data type):</p>

<h2>{% codeblock lang:yaml %}</h2>

<p>verify:
  interfaces-state:
    interface:
      - name: GigabitEthernet3
        oper_status:
          ? up
      - name: Loopback0
        oper_status:
          ? up
      - name: GigabitEthernet2
        oper_status:
          ? down
{% endcodeblock  %}</p>

<p>Once again, all expected state can be verified with a single command:</p>

<p>{% codeblock lang:bash %}
ansible-playbook verify.yaml
{% endcodeblock %}</p>

<p>If the state defined in that YAML file matches the data returned by the IOS-XE device, the playbook completes successfully. You can check that it works by shutting down one of the <code>GigabitEthernet3</code> or <code>Loopback0</code> interfaces and observing how Ansible module returns an error.</p>

<h2>Outro</h2>

<p>Now that I&rsquo;ve come to the end of my YANG series of posts I feel like I need to provide some concise and critical summary of everything I&rsquo;ve been through. However, if there&rsquo;s one thing I&rsquo;ve learned in the last couple of months about YANG, it&rsquo;s that things are changing very rapidly. Both Cisco and Juniper are working hard introducing new models and improving support for the existing ones. So one thing to keep in mind, if you&rsquo;re reading this post a few months after it was published (April 2017), is that some or most of the above limitations may not exist and it&rsquo;s always worth checking what the latest software release has to offer.</p>

<p>Finally, I wanted to say that I&rsquo;m a strong believer that YANG models are the way forward for network device configuration and state verification, despite the timid scepticism of the networking industry. I think that there are two things that may improve the industry&rsquo;s perception of YANG and help increase its adoption:</p>

<ol>
<li><p>Support from networking vendors - we&rsquo;ve already seen Cisco changing by introducing YANG support on IOS-XE instead of producing another dubious One-PK clone. So big thanks to them and I hope that other vendors will follow suit.</p></li>
<li><p>Tools - this part, IMHO, is the most crucial. In order for people to start using YANG models we have to have the right tools that would be versatile enough to allow network engineers to be limited only by their imagination and at the same time be as robust as the CLI. So I wanted to give a big shout out to all the people contributing to open-source projects like <strong>pyang</strong>, <strong>YDK</strong> and many others that I have missed or don&rsquo;t know about. You&rsquo;re doing a great job guys, don&rsquo;s stop.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Verifying TDD Scenarios]]></title>
    <link href="http://networkop.github.io/blog/2015/07/10/test-verification/"/>
    <updated>2015-07-10T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2015/07/10/test-verification</id>
    <content type="html"><![CDATA[<p>Now that Ansible has done all the information gathering for us it&rsquo;s time to finally make use of it. In this post I will show how to use Ansible to run traceroutes from and to the hosts defined in a test scenario and perform verification of the results of those tests. Should any of those tests fail, Ansible will provide a meaningful description of what exactly failed and why. While doing all this I&rsquo;ll introduce a couple of new Ansible features like conditional looping and interactive prompts.</p>

<!--more-->


<h2>TDD Playbook</h2>

<p>In order to run and verify tests I will create a separate playbook. It makes sense to separate it from the <a href="http://networkop.github.io/blog/2015/07/03/parser-modules/">previous playbook</a> simply because this time it will be used multiple times, while the information gathering playbook can only be run once. The new playbook will have to accomplish the following tasks:</p>

<ol>
<li>Select which scenario to test</li>
<li>Run tests as specified in that scenario</li>
<li>Parse test results</li>
<li>Verify that test results conform to the specification</li>
</ol>


<h2>Selecting test scenario</h2>

<p>Our <code>scenarios/all.txt</code> file contains multiple test scenarios each defined by a name. Each test scenario represent a certain state in the network, e.g. scenario #1 tests how the network behaves in a normal state with no outages or link failures, scenario #2 tests how traffic should be rerouted in the event of primary link failure. Inside each scenario there are one or more test steps each testing a behaviour of a particular traffic flow, e.g. traffic from router R1 to router R4 should traverse R2 followed by R3. Each steps contains keywords <code>From</code>, <code>To</code> and <code>Via</code> which identify  source, destination and transit routers. This is how a typical scenario file looks like.</p>

<p>{% codeblock lang:text ~/tdd_ansible/scenarios/all.txt %}
1. Testing of Primary Link
1.1 From R1 to R3 via R2
1.2 From R1 to R4 via R2, R3
1.3 From R2 to R4 via R3
1.4 From R1 to R2 via R2
2. Testing of Backup Link
2.1 From R1 to R3 via R4
2.2 From R1 to R2 via R4,R3
{% endcodeblock  %}</p>

<p>In the <a href="http://networkop.github.io/blog/2015/07/03/parser-modules/">previous post</a> I showed how to parse and store these scenarios in YAML dictionary in <code>group_vars/all.yml</code> file, which makes this information automatically available to any future playbooks. So in the new playbook all we need to do is let the user decide which scenario to test:</p>

<p>{% raw %}</p>

<h2>``` yaml ~/tdd_ansible/cisco_tdd.yml</h2>

<ul>
<li><p>name: Run traceroute commands
hosts: cisco-devices
gather_facts: false
remote_user: cisco</p>

<p>vars_prompt:</p>

<ul>
<li>name: scenario_num
prompt: &ldquo;Enter scenario number&rdquo;
default: &ldquo;1&rdquo;
private: no</li>
</ul>


<p>tasks:</p>

<ul>
<li>name: extracting scenario name and steps
set_fact:
  scenario_steps: &ldquo;{{ scenarios[scenario_num][1] }}&rdquo;
  scenario_name: &ldquo;{{ scenarios[scenario_num][0] }}&rdquo;
```
{% endraw  %}</li>
</ul>
</li>
</ul>


<p>This playbook contains a standard header followed by a <code>vars_prompt</code> section which prompts user to select a particular scenario number and stores the selection in <code>scenario_num</code> variable. The first task in the playbook extracts scenario name and steps from <code>scenarios</code> dictionary stored in <code>group_vars/all.yml</code> file and stores them in respective variables. Of course this task is optional and it&rsquo;s possible to reference the same data using full notation, however I prefer things to be more readable even if it leads to some inefficient memory use.</p>

<h2>Run test specified in scenario steps</h2>

<p>Now it&rsquo;s time to run traceroutes to see how the packets flow in the network. As we did in one of the <a href="http://networkop.github.io/blog/2015/06/24/ansible-intro/">previous posts</a> we&rsquo;ll use the <code>raw</code> module to run traceroutes. However this time, instead of running a full-mesh any-to-any traceroutes we&rsquo;ll only run them if they were defined in one of the test steps. Indeed, why would we run a traceroute between devices if we&rsquo;re not going to verify it? Ansible&rsquo;s conditionals will help us with that. For each of the hosts in <code>cisco-devices</code> group we&rsquo;ll look into scenario_steps dictionary and see if there were any tests defined and if there were, we&rsquo;ll run a traceroute to each of the destination hosts.</p>

<p>{% raw %}
<code>yaml ~/tdd_ansible/cisco_tdd.yml
    - name: run traceroutes as per the defined scenario steps
      raw: traceroute {{ hostvars[item.key]['ansible_ssh_host'] }} source Loopback0 probe 1 numeric
      when: scenario_steps[inventory_hostname] is defined
      with_dict: scenario_steps[inventory_hostname]|default({})
      register: trace_result
</code>
{% endraw  %}</p>

<p>When both a loop (<code>with_dict</code>) and a conditional (<code>when</code>) are defined in a task, Ansible does the looping first. That&rsquo;s why if a test scenario is not defined for a particular host (e.g. <code>R3</code>) the conditional check will fail and stop execution of the playbook. To overcome that we can use Ansible (Jinja) templates inside the <code>with_dict</code> loop. Appending <code>|default({})</code> will instruct Ansible create an empty dictionary in case <code>scenario_steps[inventory_hostname]</code> does not exist which will make conditional return <code>False</code> and skip this host altogether.</p>

<h2>Parse test results</h2>

<p>There&rsquo;s no silver bullet when it comes to parsing of the outcome of traceroute command. We&rsquo;ll have to use Python to traverse the textual output line by line looking for <code>msec</code> and storing all found IPs in a list.</p>

<p>{% codeblock lang:python ~/tdd_ansible/library/cisco_trace_parse.py %}
class TraceParse(object):</p>

<pre><code>def __init__(self, module):
    self.std_out = module.params['std_out']
    self.dest_host = module.params['dest_host']

def parse(self):
    result = dict()
    path = list()
    for line in self.std_out.split("\n"):
        if 'msec' in line:
            path.append(line.split()[1])
    result[self.dest_host] = path
    return result
</code></pre>

<p>def main():
    module = AnsibleModule(
        argument_spec=dict(
            std_out=dict(required=True, type=&lsquo;str&rsquo;),
            dest_host=dict(required=True, type=&lsquo;str&rsquo;)
        )
    )
    traceParser = TraceParse(module)
    result = traceParser.parse()
    module.exit_json(changed=False, ansible_facts=result)</p>

<h1>import module snippets</h1>

<p>from ansible.module_utils.basic import *
main()
{% endcodeblock  %}</p>

<p>The playbook task will run through each hosts' trace_results variable and pass it to the trace parse module.</p>

<p>{% raw %}
<code>yaml ~/tdd_ansible/cisco_tdd.yml
    - name: parse traceroute ouput
      cisco_trace_parse:
        dest_host: "{{ item.item.key }}"
        std_out: "{{ item.stdout }}"
      connection: local
      when: item.stdout is defined
      with_items: trace_result.results
</code>
{% endraw  %}</p>

<h2>Test verification</h2>

<p>Finally we need to compare the captured output with the scenario steps. This time all the information collected by Ansible in the previous tasks needs to be passed to a module.</p>

<p>{% raw %}
<code>yaml ~/tdd_ansible/cisco_tdd.yml
    - name: verify traceroutes against pre-defined scenarios
      cisco_tdd_verify:
        dest_host: "{{ item.key }}"
        src_host: "{{ inventory_hostname }}"
        scenario: "{{ scenario_steps }}"
        ip2host: "{{ ip2host }}"
        path: "{{ hostvars[inventory_hostname][item.key] }}"
        scenario_name: "{{ scenario_name }}"
      when: scenario_steps[inventory_hostname] is defined
      with_dict: scenario_steps[inventory_hostname]|default({})
      connection: local
</code>
{% endraw  %}</p>

<p>Ansible module contains a class with a single public method <code>compare</code>. The first thing it does is converts the list of IP addresses of transit devices into a list of hostnames. That&rsquo;s where the IP-to-Hostname dictionary created in the <a href="http://networkop.github.io/blog/2015/07/03/parser-modules/">previous playbook</a> is first used. IP address is used as a lookup key and the Hostname is extracted from the first element of the returned list (second element, the interface name, is currently unused). The private method <code>__validatepath</code> is used to confirm that devices listed after <code>Via</code> in a test scenario are present in the traceroute path in the specified order. If this verification fails, the whole module fails and the error message is passed back to Ansible playbook.</p>

<p>{% codeblock lang:python ~/tdd_ansible/library/cisco_tdd_verify.py %}
class ResultCompare(object):</p>

<pre><code>def __init__(self, module):
    self.dest_host = module.params['dest_host']
    self.src_host = module.params['src_host']
    self.trace_path = module.params['path']
    self.ref_scenario = module.params['scenario']
    self.ip2host = module.params['ip2host']
    self.scenario_name = module.params['scenario_name']

def compare(self):
    trace_path_new = list()
    for dev in self.trace_path:
        if dev in self.ip2host:
            trace_path_new.append(self.ip2host[dev][0])
        else:
            trace_path_new.append(dev)
    if self.src_host in self.ref_scenario:
        if self.dest_host in self.ref_scenario[self.src_host]:
            ref_path = self.ref_scenario[self.src_host][self.dest_host]
            if not self. __validatepath(trace_path_new):
                msg = "Failed scenario " + self.scenario_name +  ".\r\nTraceroute from " + self.src_host + " to " + self.dest_host + " has not traversed " + str(ref_path)
                msg += "\r\n Actual path taken: " + ' -&gt; '.join([self.src_host] + trace_path_new) + "\r\n"
                return 1, msg
    return 0, 'no error'

def __validatepath(self, path):
    index = 0
    for device in path:
        if device == self.ref_scenario[self.src_host][self.dest_host][index]:
            index += 1
            if index == len(self.ref_scenario[self.src_host][self.dest_host]):
                return True
    return False
</code></pre>

<p>def main():
    module = AnsibleModule(
        argument_spec=dict(
            dest_host=dict(required=True, type=&lsquo;str&rsquo;),
            src_host=dict(required=True, type=&lsquo;str&rsquo;),
            scenario=dict(required=True, type=&lsquo;dict&rsquo;),
            ip2host=dict(required=True, type=&lsquo;dict&rsquo;),
            path=dict(required=True, type=&lsquo;list&rsquo;),
            scenario_name=dict(required=True, type=&lsquo;str&rsquo;)
        )
    )
    comparator = ResultCompare(module)
    rc, error = comparator.compare()
    if rc != 0:
        module.fail_json(msg=error)
    else:
        module.exit_json(changed=False)</p>

<p>from ansible.module_utils.basic import *
main()
{% endcodeblock  %}</p>

<h2>TDD in action</h2>

<p>So let&rsquo;s finally see the whole thing action. First let&rsquo;s modify a <a href="http://networkop.github.io/blog/2015/06/17/dev-env-setup/">4-router topology</a> so that traffic from R1 to R4 is routed via R2 and R3 (a simple <code>delay 9999</code> on Ethernet0/1 will do). Now let&rsquo;s run the first scenario and verify that no errors are displayed.</p>

<p>{% codeblock lang:bash Scenario 1 successful %}
~/tdd_ansible# ansible-playbook cisco_tdd.yml
Enter scenario number [1]:</p>

<p>PLAY [Run traceroute commands] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>
&hellip;
PLAY RECAP </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>********************
R1                         : ok=4    changed=0    unreachable=0    failed=0
R2                         : ok=4    changed=0    unreachable=0    failed=0
R3                         : ok=2    changed=0    unreachable=0    failed=0
R4                         : ok=2    changed=0    unreachable=0    failed=0
{% endcodeblock  %}</p>

<p>Nothing much really, which is good, that means all scenarios were verified successfully. Now let&rsquo;s see how it fails. The easiest way is to run the tests from a second scenario, the one that assumes that the link between R1 and R2 failed and all the traffic is routed via R4.</p>

<p>{% codeblock lang:bash Scenario 2 failed %}
~/tdd_ansible# ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 2</p>

<p>PLAY [Run traceroute commands] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**************************
&hellip;
TASK: [verify traceroutes against pre-defined scenarios] </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
skipping: [R2]
skipping: [R4]
failed: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R2&rsquo;, &lsquo;value&rsquo;: [&lsquo;R4&rsquo;, &lsquo;R3&rsquo;]}) => {&ldquo;failed&rdquo;: true, &ldquo;item&rdquo;: {&ldquo;key&rdquo;: &ldquo;R2&rdquo;, &ldquo;value&rdquo;: [&ldquo;R4&rdquo;, &ldquo;R3&rdquo;]}}
msg: Failed scenario Testing of Backup Link.
Traceroute from R1 to R2 has not traversed [&lsquo;R4&rsquo;, &lsquo;R3&rsquo;]
 Actual path taken: R1 -> R2</p>

<p>failed: [R3] => (item={&lsquo;key&rsquo;: &lsquo;R1&rsquo;, &lsquo;value&rsquo;: [&lsquo;R4&rsquo;]}) => {&ldquo;failed&rdquo;: true, &ldquo;item&rdquo;: {&ldquo;key&rdquo;: &ldquo;R1&rdquo;, &ldquo;value&rdquo;: [&ldquo;R4&rdquo;]}}
msg: Failed scenario Testing of Backup Link.
Traceroute from R3 to R1 has not traversed [&lsquo;R4&rsquo;]
 Actual path taken: R3 -> R2 -> R1</p>

<p>failed: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R3&rsquo;, &lsquo;value&rsquo;: [&lsquo;R4&rsquo;]}) => {&ldquo;failed&rdquo;: true, &ldquo;item&rdquo;: {&ldquo;key&rdquo;: &ldquo;R3&rdquo;, &ldquo;value&rdquo;: [&ldquo;R4&rdquo;]}}
msg: Failed scenario Testing of Backup Link.
Traceroute from R1 to R3 has not traversed [&lsquo;R4&rsquo;]
 Actual path taken: R1 -> R2 -> R3</p>

<p>PLAY RECAP ********************************************************************
           to retry, use: &ndash;limit @/root/cisco_tdd.retry</p>

<p>R1                         : ok=3    changed=0    unreachable=0    failed=1
R2                         : ok=2    changed=0    unreachable=0    failed=0
R3                         : ok=3    changed=0    unreachable=0    failed=1
R4                         : ok=2    changed=0    unreachable=0    failed=0
{% endcodeblock  %}</p>

<p>Here all 3 test steps within a scenario failed. Ansible displayed error messages passed down by our module, specifying the expected and the actual path.<br/>
Now if we simply shutdown Ethernet0/0 of R1 to simulate a link failure and re-run the same scenario all tests will succeed again.</p>

<p>{% codeblock lang:bash Scenario 2 successful %}
~/tdd_ansible# ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 2</p>

<p>PLAY [Run traceroute commands] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>
&hellip;
PLAY RECAP </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>********************
R1                         : ok=4    changed=0    unreachable=0    failed=0
R2                         : ok=2    changed=0    unreachable=0    failed=0
R3                         : ok=4    changed=0    unreachable=0    failed=0
R4                         : ok=2    changed=0    unreachable=0    failed=0
{% endcodeblock  %}</p>

<p>So there it is, a working network TDD framework in action. I still haven&rsquo;t covered a lot of corner cases (e.g. when traceroute times out) and deployment scenarios (device with VRFs) but it should still work for a lot of scenarios and can be easily extended to cover those corner cases.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IP Address Information Collection With Custom Ansible Modules]]></title>
    <link href="http://networkop.github.io/blog/2015/07/03/parser-modules/"/>
    <updated>2015-07-03T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2015/07/03/parser-modules</id>
    <content type="html"><![CDATA[<p>Ansible has a very neat feature called &ldquo;fact gathering&rdquo;, which collects useful information from hosts prior to executing any of the tasks and makes this information available for use within those tasks. Unfortunately, this also relies on Python being available on the remote machine which doesn&rsquo;t work for Cisco IOS. In this post I&rsquo;ll show how to write a simple module which will collect IP address information from remote devices and store it in global variable for future use. I&rsquo;ll also show how to write a module which will convert our human-readable TDD scenarios into YAML structures. As always, full code repository is available on <a href="https://github.com/networkop/simple-cisco-tdd">Github</a></p>

<!--more-->


<h2>Cisco IOS IP fact gathering</h2>

<p>In order to recognise that a traceroute has traversed a certain device, without relying on DNS, we need to populate a local database mapping IP addresses to their respective devices. The resulting database (or YAML dictionary) needs to be stored in a file so that it can be read and used again by Ansible tasks doing the traceroute verification. In order to make it happen, we need to answer the following questions:</p>

<ul>
<li>How to get IP address information from each device?</li>
</ul>


<blockquote><p>The most straight-forward way is to capture the result of running something like <code>show ip interface brief</code> and parse the output. The assumption is that all devices are living in a non-overlapping IP address space (however it is possible to modify the examples to be vrf-aware).</p></blockquote>

<ul>
<li>Where to store the information?</li>
</ul>


<blockquote><p>Ideally, we would need a hash-like data structure (e.g. python dictionary) which will return a hostname when given a certain IP address. This data structure needs to be available to all hosts, however most of the variables in Ansible are host-specific. The only way to simulate a global variable in Ansible is to store all data in <code>group_vars/all.yml</code> file which is exactly what our module will do.</p></blockquote>

<ul>
<li>How will multiple processes write into a single file at the same time?</li>
</ul>


<blockquote><p>That&rsquo;s where Ansible&rsquo;s concurrency feature bites back. This is a well known computer science problem and the solution to this is to use <code>mutex</code>, however that&rsquo;s beyond what Ansible can do. In order to overcome that, I&rsquo;ll make Ansible do the tasks sequentially, which will dramatically slow things down for bigger environments. However, this task only needs to be run once, to collect the data, while all the other tasks can be run in parallel, in separate playbooks.</p></blockquote>

<h2>Developing Ansible playbook</h2>

<p>Our Ansible playbook will need to accomplish the following tasks:</p>

<ol>
<li>Capture the output <code>show ip interface brief</code> command</li>
<li>Parse the output capture in the previous step</li>
<li>Save the output in a <code>group_vars/all.yml</code> file</li>
</ol>


<p>All these tasks will need to be run sequentially on every host from <code>cisco-devices</code> group. To get the output from a Cisco device we&rsquo;ll use the <code>raw</code> module again. The other two tasks don&rsquo;t require connection to remote device and will be run on a localhost by the virtue of a <code>delegate_to: 127.0.0.1</code> option.</p>

<p>{% raw %}</p>

<h2>``` yaml ~/tdd_ansible/cisco-ip-collect.yml</h2>

<ul>
<li><p>name: Collect IP address data
hosts: cisco-devices
gather_facts: false
remote_user: cisco
serial: 1</p>

<p>tasks:</p>

<ul>
<li><p>name: capture show ip interface brief
raw: show ip interface brief | exclude unassigned
register: siib_text</p></li>
<li><p>name: parse the output of &ldquo;show ip interface brief&rdquo;
cisco_ip_intf_facts_collect: output_text=&ldquo;{{ siib_text.stdout }}&rdquo;
delegate_to: 127.0.0.1</p></li>
<li><p>name: combine ip address facts and save as a global variable
cisco_ip_intf_facts_combine:
  ipTable=&ldquo;{{ IPs }}&rdquo;
  hostname=&ldquo;{{ inventory_hostname }}&rdquo;
delegate_to: 127.0.0.1</p></li>
</ul>


<p>tags:</p>

<ul>
<li>collect
```
{% endraw %}</li>
</ul>
</li>
</ul>


<h2>Writing a custom Ansible module</h2>

<p>Ansible has an <a href="http://docs.ansible.com/developing_modules.html">official guide</a> on module development. A typical module will contain a header with license information along with module documentation and usage examples, a <code>main()</code> function processing the arguments passed to this module from Ansible and, of course, the actual code that implements module&rsquo;s logic. For the sake of brevity I will omit the header and some of the less important details in the code.</p>

<h2>Ansible module to parse command output</h2>

<p>This ansible module needs to extract IP address and, optionally, interface name from the output of <code>show ip interface brief</code> and store it in a python dictionary. The right way to examine the module code is from <code>main()</code> function. This function will contain a <code>module</code> variable (instance of AnsibleModule) which specifies all the arguments expected by this module and their type (the type will be converted to the appropriate python type). Text parser is implemented with a <code>SIIBparse</code> class whose only public method <code>parse()</code> will traverse the text line by line looking for interfaces with Line Protocol in <code>up</code> state, extract IP address (1st column), interface name (2nd column) and store the result in a python dictionary with IP address as the key and interface name as it&rsquo;s value.</p>

<p>{% codeblock lang:python ~/tdd_ansible/library/cisco_ip_intf_facts_collect.py %}
class SIIBparse(object):</p>

<pre><code>def __init__(self, module):
    self.output_text = module.params['output_text']
    self.ip2intf = dict()

def parse(self):
    for line in self.output_text.split("\n"):
        row = line.split()
        if len(row) &gt; 0 and row[-1] == 'up':
            ipAddress = row[1]
            intfName = row[0]
            self.ip2intf[ipAddress] = intfName
    result = {
        "IPs": self.ip2intf
    }
    rc = 0 if len(self.ip2intf) &gt; 0 else 1
    return rc, result
</code></pre>

<p>def main():
    module = AnsibleModule(
        argument_spec=dict(
            output_text=dict(required=True, type=&lsquo;str&rsquo;)
        )
    )
    siib = SIIBparse(module)
    rc, result = siib.parse()
    if rc != 0:
        module.fail_json(msg=&ldquo;Failed to parse. Incorrect input.&rdquo;)
    else:
        module.exit_json(changed=False, ansible_facts=result)</p>

<h1>import module snippets</h1>

<p>from ansible.module_utils.basic import *
main()
{% endcodeblock  %}</p>

<p>If information passed to the module in the argument was invalid, the module must fail with a meaningful message passed inside a <code>fail_json</code> method call. When parsing is complete, our module exits and the resulting data structure is passed back to Ansible variables with <code>ansible_facts</code> argument. Now all hosts can access it through variable called <code>IPs</code>.</p>

<h2>Ansible module to save IP address information</h2>

<p>The task of this module is to get all the information collected inside each hosts' <code>IPs</code> variables, combine it with devices' hostnames and save it in the <code>group_vars/all.yml</code> file. This module makes use of <a href="http://pyyaml.org/wiki/PyYAMLDocumentation">Python&rsquo;s yaml library</a>. Built-in class <code>FactUpdater</code> can read(), update() the contents and write() the global variable file defined in a <code>FILENAME</code> variable.</p>

<p>{% codeblock lang:python ~/tdd_ansible/library/cisco_ip_intf_facts_combine.py %}
import yaml
FILENAME=&ldquo;group_vars/all.yml&rdquo;</p>

<p>class FactUpdater(object):</p>

<pre><code>def __init__(self, module):
    self.ip2intf = module.params['ipTable']
    self.hostname = module.params['hostname']
    self.file_content = {'ip2host':{}}

def read(self):
    try:
        with open(FILENAME, 'r') as fileObj:
            self.file_content = yaml.load(fileObj)
    except:
        # in case there is no file - create it
        open(FILENAME, 'w').close()

def write(self):
    with open(FILENAME, 'w') as fileObj:
        yaml.safe_dump(self.file_content, fileObj, explicit_start=True, indent=2, allow_unicode=True)


def update(self):
    if not 'ip2host' in self.file_content:
        self.file_content['ip2host'] = dict()
    for ip in self.ip2intf:
        self.file_content['ip2host'][ip] = [self.hostname, self.ip2intf[ip]]
</code></pre>

<p>def main():
    module = AnsibleModule(
        argument_spec=dict(
            ipTable=dict(required=True, type=&lsquo;dict&rsquo;),
            hostname=dict(required=True, type=&lsquo;str&rsquo;),
        )
    )
    result = &lsquo;&rsquo;
    factUpdater = FactUpdater(module)
    try:
        factUpdater.read()
        factUpdater.update()
        factUpdater.write()
    except IOError as e:
        module.fail_json(msg=&ldquo;Unexpected error: &rdquo; + str(e))</p>

<pre><code>module.exit_json(changed=False)
</code></pre>

<h1>import module snippets</h1>

<p>from ansible.module_utils.basic import *
main()
{% endcodeblock  %}</p>

<p>This module only performs actions on local file and does not provide any output back to Ansible.</p>

<h2>Read and parse TDD scenarios</h2>

<p>Finally, since we&rsquo;re modifying Ansible global variable file, it would make sense to also update it with testing scenarios information. Technically, this steps doesn&rsquo;t need to be done in Ansible and could be done simply using Python or Bash scripts, but I&rsquo;ll still show it here to demonstrate two additional Ansible features. The first one is <code>local_action: module_name</code> which is a shorthand for specifying <code>module</code> with <code>delegate_to</code> option (see above). Second feature is <code>tags</code>, it allows to specify which play to run in playbook containing many of them. In our case one file <code>cisco-ip-collect.yml</code> will have two plays defined and will run both of them by default unless <code>--tag=scenario</code> or <code>--tag=collect</code> specifies the exact play.</p>

<p>{% raw %}
``` yaml ~/tdd_ansible/cisco-ip-collect.yml
- name: Parse and save scenarios
  hosts: localhost
  gather_facts: false</p>

<p>  tasks:</p>

<pre><code>- name: parse scenario file and save it in group_vars/all.yml
  local_action: cisco_scenarios_convert
</code></pre>

<p>  tags:
    - scenario
```
{% endraw  %}</p>

<p>This play has a single task which runs a single custom module. Before we proceed to the module let&rsquo;s see how a typical testing scenario file looks like.</p>

<p>{% codeblock lang:text ~/tdd_ansible/scenarios/all.txt %}
1. Testing of Primary Link
1.1 From R1 to R3 via R2
1.2 From R1 to R4 via R2, R3
2. Testing of Backup Link
2.1 From R1 to R3 via R4
2.2 From R1 to R2 via R4,R3
{% endcodeblock  %}</p>

<p>The file should be stored in a <code>scenarios/</code> directory and should have a name <code>all.txt</code>. This file contains a list of scenarios, each with its own name, and a list of test steps that need to be performed to validate a particular scenario. The parser for this file is a custom Python module which opens and reads the contents of <code>group_vars/all.yml</code> file, parses the scenarios file with the help of some ugly-looking regular expressions, and, finally, updates and saves the contents of Ansible group variable back to file.</p>

<p>{% codeblock lang:python ~/tdd_ansible/library/cisco_scenarios_convert.py %}
import yaml
import re
SCENARIO_FILE = &ldquo;scenarios/all.txt&rdquo;
GROUP_VAR_FILE = &ldquo;group_vars/all.yml&rdquo;</p>

<p>class ScenarioParser(object):</p>

<pre><code>def __init__(self):
    self.rc = 0
    self.storage = dict()
    self.file_content = dict()

def open(self):
   try:
        with open(GROUP_VAR_FILE, 'r') as fileObj:
            self.file_content = yaml.load(fileObj)
   except:
       open(GROUP_VAR_FILE, 'w').close()

def read(self):
    scenario_number = 0
    scenario_step   = 0
    scenario_name   = ''
    name_pattern = re.compile(r'^(\d+)\.?\s+(.*)')
    step_pattern = re.compile(r'.*[Ff][Rr][Oo][Mm]\s+([\d\w]+)\s+[Tt][Oo]\s+([\d\w]+)\s+[Vv][Ii][Aa]\s+([\d\w]+,*\s*[\d\w]+)*')
    with open(SCENARIO_FILE, 'r') as fileObj:
        for line in fileObj:
            if not line.startswith('#') and len(line) &gt; 3:
                name_match = name_pattern.match(line)
                step_match = step_pattern.match(line)
                if name_match:
                    scenario_number = name_match.group(1)
                    scenario_name   = name_match.group(2)
                    scenario_steps  = [scenario_name, {}]
                    if not scenario_number in self.storage:
                        self.storage[scenario_number] = scenario_steps
                    else:
                        scenario_steps = self.storage[scenario_number]
                elif step_match:
                    from_device = step_match.group(1)
                    to_device = step_match.group(2)
                    via = step_match.group(3)
                    via_devices = [device_name.strip() for device_name in via.split(',')]
                    if not scenario_number == 0 or not scenario_name:
                        if not from_device in scenario_steps[1]:
                            scenario_steps[1][from_device] = dict()
                        scenario_steps[1][from_device][to_device] = via_devices
                else:
                    self.rc = 1

def write(self):
   self.file_content['scenarios'] = self.storage
   if self.rc == 0:
       with open(GROUP_VAR_FILE, 'w+') as fileObj:
           yaml.safe_dump(self.file_content, fileObj, explicit_start=True, indent=3, allow_unicode=True)
</code></pre>

<p>def main():
    module = AnsibleModule(argument_spec=dict())
    parser = ScenarioParser()
    parser.open()
    parser.read()
    parser.write()
    if not parser.rc == 0:
        module.fail_json(msg=&ldquo;Failed to parse. Incorrect input.&rdquo;)
    else:
        module.exit_json(changed=False)</p>

<p>from ansible.module_utils.basic import *
main()
{% endcodeblock  %}</p>

<p>The biggest portion of code is the read() method of the parser which does the following:</p>

<ul>
<li>scans text file line by line ignoring lines starting with <code>#</code> and whose length is not enough to contain either a scenario name or scenario step</li>
<li>matches each line against pre-compiled regular expressions for scenario name or for scenario step (<a href="https://regex101.com/">a very helpful tool for regex testing</a>)</li>
<li>attempts to save the data in a Python dictionary whose keys are scenario numbers and whose values is a list consisting of a scenario name (1st element) and a dictionary with scenario steps (2nd element)</li>
</ul>


<p>The end result of running both ip address collection and scenarios conversion plays is Ansible group variable file that looks like this:</p>

<p>{% raw %}</p>

<h2>``` yaml  ~/tdd_ansible/library/group_vars/all.yml</h2>

<p>ip2host:
   10.0.0.1: [R1, Loopback0]
   10.0.0.2: [R2, Loopback0]
   10.0.0.3: [R3, Loopback0]
   10.0.0.4: [R4, Loopback0]
   12.12.12.1: [R1, Ethernet0/0]
   12.12.12.2: [R2, Ethernet0/0]
   14.14.14.1: [R1, Ethernet0/1]
   14.14.14.4: [R4, Ethernet0/1]
   192.168.247.25: [R1, Ethernet0/2]
   23.23.23.2: [R3, Ethernet0/0]
   34.34.34.3: [R3, Ethernet0/1]
   34.34.34.4: [R4, Ethernet0/0]
scenarios:
   &lsquo;1&rsquo;:
   - Testing of Primary Link
   -  R1:
         R2: [R2]
         R3: [R2]
         R4: [R2, R3]
      R2:
         R4: [R3]
   &lsquo;2&rsquo;:
   - Testing of Backup Link
   -  R1:
         R2: [R4, R3]
         R3: [R4]
      R3:
         R1: [R4]
```
{% endraw  %}</p>

<hr />

<p>The next post, final in a series, will show how to write an Ansible play to validate TDD scenarios and produce a meaningful error message in case it fails.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started With Ansible for Cisco IOS]]></title>
    <link href="http://networkop.github.io/blog/2015/06/24/ansible-intro/"/>
    <updated>2015-06-24T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2015/06/24/ansible-intro</id>
    <content type="html"><![CDATA[<p>Ansible is well-known for it&rsquo;s low entry threshold. All what&rsquo;s required to get started is just one inventory file. However Cisco IOS devices require special considerations.
Passwordless SSH RSA-based authentication is still a novelty and in most cases users are authenticated based on their passwords. Another problem is the lack of Python execution
environment on IOS devices, which seriously limits the choice of Ansible modules that can be used. In this post I will show how to setup Ansible
environment to control Cisco IOS devices</p>

<!--more-->


<h2>Ansible overview</h2>

<p>There&rsquo;s been a lot written about what Ansible is and what it was built to accomplish. I will just provide a brief summary of its features focusing on what we&rsquo;re gonna be using it for, leaving an in-depth explanation to the official <a href="http://docs.ansible.com/">Ansible documentation</a>.</p>

<ul>
<li>What is it?</li>
</ul>


<blockquote><p>Ansible is an IT automation and orchestration framework</p></blockquote>

<ul>
<li>What was it built to accomplish?</li>
</ul>


<blockquote><p>Ansible was designed to automate routine tasks like server/application deployment and configuration</p></blockquote>

<ul>
<li>How does it work?</li>
</ul>


<blockquote><p>It connects to several hosts at the same time and executes small programs called &ldquo;modules&rdquo; in the order specified in a file called &ldquo;playbook&rdquo;</p></blockquote>

<p>To build what we&rsquo;ve set out to accomplish I&rsquo;m gonna be using the latter feature. I am not gonna be using Ansible for system provisioning or service orchestration. Instead, I will be exploiting Ansible&rsquo;s ability to run multiple parallel connections to remote hosts, execute commands on them and return their result. Due to that, I will diverge from some of the <a href="https://docs.ansible.com/playbooks_best_practices.html">Ansible&rsquo;s best practices</a> of splitting functions into roles and I will use one flat playbook file segregating different functions with tags.</p>

<h2>Ansible configuration file</h2>

<p>Ansible configuration file <code>ansible.cfg</code> contains <a href="http://docs.ansible.com/intro_configuration.html">application-wide settings</a> like default timeouts, port numbers and other flags. The default Ansible configuration file is located in <code>/etc/ansible/</code> directory. However, instead of overwriting the defaults it is possible to create a configuration file in a local directory with only the settings that need to be overridden. To better work with Cisco devices the following settings will need to be modified:</p>

<ul>
<li>Default SSH library (transport) needs to be set to <code>paramiko</code> which is more stable than its alternative, OpenSSH, when working with Cisco IOS.</li>
<li>For a small project it is easier to maintain a local copy of inventory file which is configured with <code>hostfile</code> setting.</li>
<li>Strict SSH key checking is a MUST in every production environment, however, for development environment an exception can be made.</li>
<li>Default SSH timeout is decreased to 5 seconds reflecting a small size of the testing environment.</li>
</ul>


<p><code>bash ~/tdd_ansible/ansible.cfg
[defaults]
transport=paramiko
hostfile = ./myhosts
host_key_checking=False
timeout = 5
</code></p>

<h2>Inventory file</h2>

<p>Inventory contains the list of hosts to be managed by Ansible. Hosts are normally combined into groups (<code>cisco-devices</code> in our case) and Ansible performs actions on all hosts in the group in parallel.</p>

<p><code>bash ~/tdd_ansible/myhosts
[cisco-devices]
R1
R2
R3
R4
</code>
It is considered a <a href="https://docs.ansible.com/playbooks_best_practices.html#group-and-host-variables">best practice</a> to keep all variables in separate folders and files. We need to define additional host variables to let Ansible know which IP address to use to connect to a remote device. I will also add SSH password to a host variable file which is a VERY bad practice, however this will prevent me from typing password every time I run a playbook. If I ever did this in production, I&rsquo;d add host variables directory to <code>.gitignore</code> file so that it doesn&rsquo;t get uploaded to Github. Host variables files must follow YAML formatting, must be stored in a <code>./host_vars</code> directory and must match the name of the host they are being assigned to.</p>

<h2>``` yaml ~/tdd_ansible/host_vars/R1</h2>

<p>ansible_ssh_host: 10.0.0.1
ansible_ssh_pass: cisco
```</p>

<p>Similar files need to be created for R2, R3 and R4.</p>

<h2>Run a test traceroute commands</h2>

<p>Now it is time to finally see Ansible in action. Let&rsquo;s first see if we can run a standalone traceroute command. I will manually define SSH username with <code>-u</code> flag and use a module called <code>raw</code> passing traceroute command as an argument with <code>-a</code> option.</p>

<pre><code class="bash Ad-hoc traceroute command">$ ansible cisco-devices -u cisco -m raw -a "traceroute 10.0.0.4 source Loopback0 probe 1 numeric"
SSH password:
R1 | success | rc=0 &gt;&gt;

Type escape sequence to abort.
Tracing the route to 10.0.0.4
VRF info: (vrf in name/id, vrf out name/id)
  1 14.14.14.4 0 msec *  0 msec

R2 | success | rc=0 &gt;&gt;

Type escape sequence to abort.
Tracing the route to 10.0.0.4
VRF info: (vrf in name/id, vrf out name/id)
  1 12.12.12.1 0 msec 0 msec 0 msec
  2  *  *
    14.14.14.4 0 msec

R3 | success | rc=0 &gt;&gt;

Type escape sequence to abort.
Tracing the route to 10.0.0.4
VRF info: (vrf in name/id, vrf out name/id)
  1 34.34.34.4 0 msec 0 msec *

R4 | success | rc=0 &gt;&gt;

Type escape sequence to abort.
Tracing the route to 10.0.0.4
VRF info: (vrf in name/id, vrf out name/id)
  1 10.0.0.4 0 msec 0 msec *
</code></pre>

<p>Ansible ad-hoc commands are a good way to quickly test something out and learn how things work. Next step would be to create a playbook file which will contain several of those commands in a more structured way. Playbooks use YAML syntax and follow strict formatting rules. At the top of the file there&rsquo;s a name of the play along with the target hosts group. Following that are a list of tasks, each of which calls its own module and passes arguments to it. In this example playbook does the following:</p>

<ol>
<li>Defines a <code>loopbacks</code> variable which stores in a hash a list of devices along with their loopback IP addresses.</li>
<li>Uses <code>raw</code> module to run traceroute commands. This is the only module that doesn&rsquo;t require Python to be installed on a target machine.</li>
<li>For each host in <code>cisco-devices</code> group runs traceroute to every other hosts' loopback IP</li>
<li>Stores the result in a <code>trace_result</code> variable</li>
</ol>


<p>{% raw %}</p>

<h2>``` yaml ~/tdd_ansible/cisco-trace-run.yml</h2>

<ul>
<li><p>name: Run traceroute commands
hosts: cisco-devices
gather_facts: false
remote_user: cisco</p>

<p>vars:
  loopbacks: {
  &ldquo;R1&rdquo;: &ldquo;10.0.0.1&rdquo;,
  &ldquo;R2&rdquo;: &ldquo;10.0.0.2&rdquo;,
  &ldquo;R3&rdquo;: &ldquo;10.0.0.3&rdquo;,
  &ldquo;R4&rdquo;: &ldquo;10.0.0.4&rdquo;,
  }</p>

<p>tasks:</p>

<ul>
<li>name: run traceroute to every other host
raw: traceroute {{ item.value }} source Loopback0 probe 1 numeric
when: item.key != inventory_hostname
with_dict: loopbacks
register: trace_result</li>
</ul>
</li>
</ul>


<h1>- name: Debug registered variables</h1>

<h1>debug: var=trace_result</h1>

<pre><code>{% endraw %}

In this Playbook I use several useful Ansible features:

* [Variables defined in playbooks](https://docs.ansible.com/playbooks_variables.html#variables-defined-in-a-playbook)
* [Looping over hashes](https://docs.ansible.com/playbooks_loops.html#looping-over-hashes)
* [Conditionals](https://docs.ansible.com/playbooks_conditionals.html)
* [Registered variables](https://docs.ansible.com/playbooks_variables.html#registered-variables)

The end result of this task is that traceroute is run 12 times - one time from each of the hosts to each other host except for when source and destination are equal.
</code></pre>

<p>$ ansible-playbook cisco-trace-run.yml</p>

<p>PLAY [Run traceroute commands] ************************************************</p>

<p>TASK: [run traceroute to every other host] ************************************
skipping: [R4] => (item={&lsquo;key&rsquo;: &lsquo;R4&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.4&rsquo;})
ok: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R4&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.4&rsquo;})
skipping: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R1&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.1&rsquo;})
ok: [R3] => (item={&lsquo;key&rsquo;: &lsquo;R4&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.4&rsquo;})
ok: [R4] => (item={&lsquo;key&rsquo;: &lsquo;R1&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.1&rsquo;})
ok: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R2&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.2&rsquo;})
ok: [R3] => (item={&lsquo;key&rsquo;: &lsquo;R1&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.1&rsquo;})
ok: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R3&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.3&rsquo;})
ok: [R3] => (item={&lsquo;key&rsquo;: &lsquo;R2&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.2&rsquo;})
skipping: [R3] => (item={&lsquo;key&rsquo;: &lsquo;R3&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.3&rsquo;})
ok: [R2] => (item={&lsquo;key&rsquo;: &lsquo;R4&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.4&rsquo;})
ok: [R2] => (item={&lsquo;key&rsquo;: &lsquo;R1&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.1&rsquo;})
skipping: [R2] => (item={&lsquo;key&rsquo;: &lsquo;R2&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.2&rsquo;})
ok: [R4] => (item={&lsquo;key&rsquo;: &lsquo;R2&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.2&rsquo;})
ok: [R2] => (item={&lsquo;key&rsquo;: &lsquo;R3&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.3&rsquo;})
ok: [R4] => (item={&lsquo;key&rsquo;: &lsquo;R3&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.3&rsquo;})</p>

<p>PLAY RECAP ********************************************************************
R1                         : ok=1    changed=0    unreachable=0    failed=0
R2                         : ok=1    changed=0    unreachable=0    failed=0
R3                         : ok=1    changed=0    unreachable=0    failed=0
R4                         : ok=1    changed=0    unreachable=0    failed=0</p>

<p>```</p>

<p>The above shows that all 12 tasks were completed successfully, meaning the command was executed and result was stored in a registered variable. To view the actual output of <code>traceroute</code> commands uncomment the two debug lines at the end of the playbook and rerun it.</p>

<hr />

<p>Now that the goal of running commands on multiple devices in parallel is achieved, the next step would be to decide how to make use of the received output. In the next posts I will attempt to tackle the following problems:</p>

<ul>
<li>Parse textual output of traceroute command and extract transit IP addresses.</li>
<li>Find a way to convert these transit IP addresses into hostnames without relying on DNS.</li>
<li>Verify TDD scenarios against traceroute outputs and produce an intelligible result of this verification.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Development Environment Setup]]></title>
    <link href="http://networkop.github.io/blog/2015/06/17/dev-env-setup/"/>
    <updated>2015-06-17T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2015/06/17/dev-env-setup</id>
    <content type="html"><![CDATA[<p>Before we proceed with TDD framework build it is important to have the development environment setup. In our case it will consist of two major components:</p>

<ul>
<li>Network Simulation Environment</li>
<li>Ansible Development Environment</li>
</ul>


<p>To simplify things I will run both of these environments on the same Virtual Machine. For network simulation I will use <a href="http://www.unetlab.com/">UnetLab</a>, a wonderful product developed by Andrea Dainese. Currently, UnetLab is distributed as an OVA package and is available for free download on <a href="http://www.unetlab.com/download/">the website</a>. To simulate network devices I will run <abbr title="IOS on Unix">IOU</abbr> which will be interconnected to form a simple network. Finally, I will show how to setup development environment with Ansible, git and Python.</p>

<!--more-->


<h2>UnetLab setup</h2>

<p>UnetLab is a network simulation environment very similar to GNS3. The biggest advantage for me, personally, is that it runs as a single entity and doesn&rsquo;t require a separate front-end like GNS3. That being said, the only requirement for this project is for the test network to have remote connectivity to a machine running Ansible, so having UnetLab specifically is not required and any network simulator would do, including a real (non-virtual) lab. One of the side effects of choosing UnetLab is that all development will have to be done on Ubuntu which is the OS pre-installed in the OVA.<br/>
Here are the steps required to get the network environment setup:</p>

<ol>
<li><a href="http://www.unetlab.com/download/">Download</a> and import OVA file into the hypervisor of your choice.</li>
<li>Download and <a href="http://www.unetlab.com/2014/11/adding-cisco-iouiol-images/">import</a> Cisco L3 IOU file.</li>
<li>Create a simple 4-device network (<a href="http://www.unetlab.com/2014/11/create-the-first-lab/">example</a>) and <a href="http://www.unetlab.com/2014/11/using-cloud-devices/">connect it to the network of host machine</a>.</li>
<li><a href="http://www.unetlab.com/2015/03/url-telnet-ssh-vnc-integration-on-windows/">Configure</a> your favourite terminal program to work with UnetLab&rsquo;s web interface</li>
</ol>


<p>This is the topology I will be using for testing:
{% img center /images/lab-topo.png &lsquo;Test Topology&rsquo;%}</p>

<p>Each device will have a Loopback interface in <code>10.0.0.0/24</code> subnet which I will statically point to <code>interface Eth0/2</code> of R1 on the host machine. Here&rsquo;s the example of R1&rsquo;s configuration:</p>

<pre><code class="text Sample Router Configuration - R1">! Configure hostname, domain and RSA key to enable SSH
hostname R1
ip domain name tdd.lab
crypto key generate rsa modulus 1024
! Point AAA to local database
aaa new-model
aaa authentication login default local
aaa authorization exec default local
username cisco privilege 15 secret cisco
! Enable remote ssh connections
line vty 0 4
 transport input ssh
! Configure interfaces
interface Loopback0
 ip address 10.0.0.1 255.255.255.255
!
interface Ethernet0/0
 ip address 12.12.12.1 255.255.255.0
!
interface Ethernet0/1
 ip address 14.14.14.1 255.255.255.0
!
interface Ethernet0/2
 description connection to host machine
 ip address 192.168.247.25 255.255.255.0
! Enable dynamic routing
router eigrp 100
 network 0.0.0.0
!
end
write 
</code></pre>

<p>All other devices will have similar configuration with the end goal of having connectivity between any pair of Loopback interfaces.</p>

<p>In order to to have connectivity to devices from a host machine we need to add a static route for <code>10.0.0.0/24</code> network:</p>

<pre><code class="bash Adding a static route to test topology">$ route add -net 10.0.0.0 netmask 255.255.255.0 gw 192.168.247.25
</code></pre>

<p>At this point host machine should be able to ping each one of those Loopbacks:</p>

<pre><code class="bash Testing connectivity to test devices">$ for i in {1..4}; do ping -c 1 10.0.0.$i; done | grep packets
1 packets transmitted, 1 received, 0% packet loss, time 0ms
1 packets transmitted, 1 received, 0% packet loss, time 0ms
1 packets transmitted, 1 received, 0% packet loss, time 0ms
1 packets transmitted, 1 received, 0% packet loss, time 0ms
</code></pre>

<h2>Dev environment setup</h2>

<p>Ansible is one of the most popular automation and orchestration tools in IT industry. Part of its popularity is due to the &ldquo;clientless&rdquo; architecture where
the only requirement to a managed system is to have ssh access and Python execution environment. The latter pretty much rules out the biggest part of common
networking infrastructure. However it is still possible to use Ansible in a &ldquo;raw&rdquo; mode and write modules of our own. That&rsquo;s exactly what we&rsquo;re gonna do in this exercise.
Due to the fact that Ansible is written in Python, it has better support for modules written in the same language, therefore all modules will be written in Python.<br/>
One important tool every developer uses is version control. It allows to track changes made to the code and enables collaboration between multiple
people working on the same project. For beginners it always makes sense to stick to the most popular tools, that&rsquo;s why I&rsquo;ll be using git for version control and store all my code on Github.</p>

<p>This is what&rsquo;s needed to setup the development environment:</p>

<pre><code class="bash 1. Install Python and git packages">$ sudo apt-get update &amp;&amp; sudo apt-get install python git-core
</code></pre>

<pre><code class="bash 2. Initialise global git settings">$ git config --global user.name "Network-oriented programming"
$ git config --global user.email "networkop@example.com"
</code></pre>

<pre><code class="bash 3. Install Ansible http://docs.ansible.com/intro_installation.html Ansible Installation">$ sudo apt-get install software-properties-common
$ sudo apt-add-repository ppa:ansible/ansible
$ sudo apt-get update
$ sudo apt-get install ansible
</code></pre>

<pre><code class="bash 4. Test Ansible connectivity to our network topology">$ sudo echo "R1 ansible_ssh_host=10.0.0.1" &gt;&gt; /etc/ansible/hosts
$ printf "[defaults]\nhost_key_checking=False\n" &gt;&gt; ansible.cfg
$ ansible R1 -u cisco --ask-pass -m "raw" -a "show version | include IOS"
SSH password:
R3 | success | rc=0 &gt;&gt;
Cisco IOS Software, Linux Software (I86BI_LINUX-ADVENTERPRISEK9-M), Version 15.4(1)T, DEVELOPMENT TEST SOFTWARE
Connection to 10.0.0.1 closed by remote host.
</code></pre>

<p>The above script first populates Ansible <code>inventory</code> file with an ip address of R1, then disables ssh key checking,
 and finally runs an <code>ad-hoc</code> command <code>show version | include IOS</code> which should prompt for a password and return a result of command execution on R1.
 I will explain about inventory and configuration files in a bit more detail in the next post. At this stage all what&rsquo;s required is a meaningful response from a Cisco router.</p>

<p><figure class='code'><figcaption><span>
5. Create a free Github account and setup a new repository
</span><a href='https://github.com/join'>Join Github</a></figcaption><div class="highlight">
</figure>
For my blog I will be using <code>networkop</code> as a Github username and <code>simple-cisco-tdd</code> as a repository name.
Once respository is created, Github will provide instructions to setup repository on a local machine which will be done in the next step.</p>

<pre><code class="bash 6. Setup a project directory and initialise git">$ mkdir ~/tdd_ansible &amp;&amp; cd ~/tdd_ansible
$ eacho "simple-cisco-tdd" &gt;&gt; README.md
$ git init
$ git add README.md
$ git commit -m "first commit"
$ git remote add origin https://github.com/networkop/simple-cisco-tdd.git
$ git push -u origin master
Username for https://github.com: networkop
Password for https://networkop@github.com:
Counting objects: 3, done.
Writing objects: 100% (3/3), 206 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/networkop/simple-cisco-tdd.git
 * [new branch]      master -&gt; master
Branch master set up to track remote branch master from origin.
</code></pre>

<p>The above result indicates that <code>README.md</code> file has been pushed to Github successfully. Needless to say that all pushed local files can be also viewed from Github&rsquo;s web page.</p>

<hr />

<p>This completes the initial environment setup. I highly recommend at this stage, hypervisor permitting, to take a snapshot of a current state of a virtual machine to avoid having to rebuild it every time something goes pear-shaped.
In the next post I will show how to setup Ansible to work with Cisco devices.</p>
]]></content>
  </entry>
  
</feed>
