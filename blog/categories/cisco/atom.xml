<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cisco | Network-oriented programming]]></title>
  <link href="http://networkop.github.io/blog/categories/cisco/atom.xml" rel="self"/>
  <link href="http://networkop.github.io/"/>
  <updated>2017-11-26T10:48:55+00:00</updated>
  <id>http://networkop.github.io/</id>
  <author>
    <name><![CDATA[Michael Kashin]]></name>
    <email><![CDATA[mmkashin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Network TDD Quickstart Guide]]></title>
    <link href="http://networkop.github.io/blog/2015/07/17/tdd-quickstart/"/>
    <updated>2015-07-17T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2015/07/17/tdd-quickstart</id>
    <content type="html"><![CDATA[<p>This post gives a quick overview of how to use network Test Driven Development framework. As an example I&rsquo;ll use a simplified version of a typical enterprise network with a Data Centre/HQ and a Branch office. A new branch is being added and the task is to configure routing for that branch using a TDD approach. First we&rsquo;ll devise a set of TDD scenarios to be tested and then, going through each one of them, modify routing to make sure those scenarios don&rsquo;t fail (a so-called red-green-refactor approach)</p>

<!--more-->


<h2>Network overview</h2>

<p>Let&rsquo;s assume you&rsquo;re working in a proverbial Acme Inc. It has a Data Centre hosting all centralised services and a single office branch (Branch #1). Sites are interconnected using active/backup WAN links. The company decides to expand and adds a new office in a city nearby. In additional to standard dual WAN links it&rsquo;s possible to buy a cheap and high throughput backdoor link between the two branches.</p>

<p>{% img centre /images/tdd-big-topo.png Acme Inc. Topology%}</p>

<h2>Network configuration</h2>

<p>Acme Inc. uses OSPF for intra-site routing and BGP for WAN routing. A standard configuration assumes that the core router at each site is the route reflector for the two WAN routers.</p>

<pre><code class="text CORE ROUTER CONFIG">interface Loopback0
 ip address 10.0.X.1 255.255.255.255
!
router ospf 100
 network 0.0.0.0 255.255.255.255 area 0
!
router bgp X
 bgp log-neighbor-changes
 timers bgp 1 5
 neighbor RR-CLIENTS peer-group
 neighbor RR-CLIENTS remote-as 1
 neighbor RR-CLIENTS update-source Loopback0
 neighbor RR-CLIENTS route-reflector-client
 neighbor 10.0.X.2 peer-group RR-CLIENTS
 neighbor 10.0.X.3 peer-group RR-CLIENTS
</code></pre>

<p>WAN routers originate site summary by first injecting their own Loopback IP address into BGP RIB and then aggregating it to site summary boundary (/24).</p>

<pre><code class="text WAN ROUTER 1 CONFIG">router ospf 100
 network 0.0.0.0 255.255.255.255 area 0
!
router bgp X
 bgp log-neighbor-changes
 network 10.0.X.2 mask 255.255.255.255
 aggregate-address 10.0.X.0 255.255.255.0
 neighbor &lt;PRIMARY_PE_IP&gt; remote-as &lt;PRIMARY_WAN_AS&gt;
 neighbor 10.0.X.1 remote-as 1
 neighbor 10.0.X.1 update-source Loopback0
</code></pre>

<p>No special path manipulation is done on either WAN routers by default.</p>

<pre><code class="text WAN ROUTER 2 CONFIG">router ospf 100
 network 0.0.0.0 255.255.255.255 area 0
!
router bgp X
 bgp log-neighbor-changes
 network 10.0.X.2 mask 255.255.255.255
 aggregate-address 10.0.X.0 255.255.255.0
 neighbor &lt;BACKUP_PE_IP&gt; remote-as &lt;BACKUP_WAN_AS&gt;
 neighbor 10.0.X.1 remote-as 1
 neighbor 10.0.X.1 update-source Loopback0
</code></pre>

<p>The same pattern is repeated on all sites with the exception of an additional backdoor link between the branch sites over which the two cores run eBGP. Inter-device transit subnets can be anything within the site-allocated range.</p>

<h2>Devising TDD scenarios</h2>

<p>After careful consideration of all links' bandwidths you devise a set of TDD scenarios and along with the high-level network topology present them to your management for endorsement. The idea is to always try to use the primary WAN link if possible. However for the inter-branch communication, backdoor link should be the preferred option. When the primary link fails at the new branch, all traffic to and from the DC should traverse the backdoor link only falling back to the secondary WAN link in case both primary and backdoor link fail. This corresponds to the 4 TDD scenarios (shown with coloured arrows on the above diagram):</p>

<p>{% codeblock lang:text ./scenarios/all.txt %}
1. Testing of Primary Link (default scenario)</p>

<p>1.1 From DC-CORE to BR2-CORE via DC-WAN1,BR2-WAN1
1.2 From BR2-CORE to DC-CORE via BR2-WAN1, DC-WAN1
1.3 From BR2-WAN1 to BR1-WAN1 via BR2-CORE,BR1-CORE
1.4 From BR1-WAN1 to BR2-WAN1 via BR1-CORE, BR2-CORE</p>

<ol>
<li>Primary WAN failed at Branch #2</li>
</ol>


<p>2.1 From DC-CORE to BR2-CORE via DC-WAN1,BR1-WAN1,BR1-CORE
2.2 From BR2-CORE to DC-CORE via BR1-CORE, BR1-WAN1, DC-WAN1
2.3 From BR2-WAN2 to BR1-WAN2 via BR2-CORE, BR1-CORE
2.4 From BR1-WAN2 to BR2-WAN2 via BR1-CORE, BR2-CORE</p>

<ol>
<li>Backdoor link failed</li>
</ol>


<p>3.1 From BR2-WAN2 to BR1-WAN2 via BR2-WAN1, BR1-WAN1
3.2 FROM BR1-WAN2 to BR2-WAN2 via BR1-WAN1, BR2-WAN1</p>

<ol>
<li>Both Primary and Backdoor links failed at Branch #2</li>
</ol>


<p>4.1 From DC-CORE to BR2-CORE via DC-WAN2, BR2-WAN2
4.2 From BR2-CORE to DC-CORE via BR2-WAN2, DC-WAN2
4.3 From BR2-CORE to BR1-CORE via BR2-WAN2, BR1-WAN2
4.4 From BR1-CORE to BR2-CORE via BR1-WAN2, BR2-WAN2
{% endcodeblock  %}</p>

<h2>Preparing the test environment</h2>

<p>First, you need to get a Linux machine connected to internet and to your network. A simply VM inside a VirtualBox would do. Now clone the git repository:
<code>bash Cloning git repository
git clone https://github.com/networkop/simple-cisco-tdd.git tdd-acme-inc
cd tdd-acme-int
</code>
Populate Ansible hosts inventory. In this case hosts are assigned to the group corresponding to their site and all the site groups are assigned to a parent group.
``` text ./myhosts
[dc-devices]
DC-CORE ansible_ssh_host=10.0.1.1
DC-WAN1 ansible_ssh_host=10.0.1.2
DC-WAN2 ansible_ssh_host=10.0.1.3</p>

<p>[br1-devices]
BR1-CORE ansible_ssh_host=10.0.2.1
BR1-WAN1 ansible_ssh_host=10.0.2.2
BR1-WAN2 ansible_ssh_host=10.0.2.3</p>

<p>[br2-devices]
BR2-CORE ansible_ssh_host=10.0.3.1
BR2-WAN1 ansible_ssh_host=10.0.3.2
BR2-WAN2 ansible_ssh_host=10.0.3.3</p>

<p>[cisco-devices:children]
dc-devices
br1-devices
br2-devices
```</p>

<p>Optionally, you can define your username/password credentials.</p>

<pre><code class="yaml ./group_vars/cisco-devices.yml">---
ansible_ssh_user: cisco
ansible_ssh_pass: cisco
</code></pre>

<p>Do the IP address information gathering and scenario processing first.
<code>bash Run the fact gathering
./ansible-playbook cisco-ip-collect.yml
</code></p>

<p>Verify that IP addresses and scenarios are now recorded in a global group variable file.
<code>bash Verify the content of all.yml file
cat ./group_vars/all.yml
</code></p>

<h2>Test the default scenario</h2>

<p>Now it&rsquo;s time to test. First, the default scenario:
<code>bash Testing scenario #1
ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 1
...
skipping: [DC-WAN1]
skipping: [BR1-CORE]
skipping: [DC-WAN2]
skipping: [BR1-WAN2]
skipping: [BR2-WAN2]
ok: [BR2-CORE] =&gt; (item={'key': 'DC-CORE', 'value': ['BR2-WAN1', 'DC-WAN1']})
ok: [BR2-WAN1] =&gt; (item={'key': 'BR1-WAN1', 'value': ['BR2-CORE', 'BR1-CORE']})
ok: [BR1-WAN1] =&gt; (item={'key': 'BR2-WAN1', 'value': ['BR1-CORE', 'BR2-CORE']})
ok: [DC-CORE] =&gt; (item={'key': 'BR2-CORE', 'value': ['DC-WAN1', 'BR2-WAN1']})
</code></p>

<p>All tests succeeded.</p>

<h2>Testing the primary link failure</h2>

<p>Now, let&rsquo;s simulate the failure of a primary WAN link by shutting down the uplink on the WAN router:
<code>text BR2-WAN1
BR2-WAN1#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
BR2-WAN1(config)#int eth 0/0
BR2-WAN1(config-if)#shut
</code></p>

<p>And now run the second scenario:
<code>bash Testing scenario #2 - failed
ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 2
...
failed: [DC-CORE] =&gt; (item={'key': 'BR2-CORE', 'value': ['DC-WAN1', 'BR1-WAN1']}) =&gt; {"failed": true, "item": {"key": "BR2-CORE", "value": ["DC-WAN1", "BR1-WAN1"]}}
msg: Failed scenario Primary WAN failed at Branch #2.
Traceroute from DC-CORE to BR2-CORE has not traversed ['DC-WAN1', 'BR1-WAN1']
 Actual path taken: DC-CORE -&gt; DC-WAN2 -&gt; 2.2.2.2 -&gt; BR2-WAN2 -&gt; BR2-CORE
ok: [BR1-WAN2] =&gt; (item={'key': 'BR2-WAN2', 'value': ['BR1-CORE', 'BR2-CORE']})
failed: [BR2-CORE] =&gt; (item={'key': 'DC-CORE', 'value': ['BR1-CORE', 'BR1-WAN1']}) =&gt; {"failed": true, "item": {"key": "DC-CORE", "value": ["BR1-CORE", "BR1-WAN1"]}}
msg: Failed scenario Primary WAN failed at Branch #2.
Traceroute from BR2-CORE to DC-CORE has not traversed ['BR1-CORE', 'BR1-WAN1']
 Actual path taken: BR2-CORE -&gt; BR2-WAN2 -&gt; 2.2.3.2 -&gt; DC-WAN2 -&gt; DC-CORE
ok: [BR2-WAN2] =&gt; (item={'key': 'BR1-WAN2', 'value': ['BR2-CORE', 'BR1-CORE']})
</code></p>

<p>Right, here is where it gets interesting. You see that the two scenarios have failed. Specifically traffic between the new branch and the DC has not traversed the backdoor link preferring the backup WAN instead. So we need to make the backup WAN less preferred. The easiest way is to use <code>as-path prepend</code> feature. Let&rsquo;s modify the configuration of our backup WAN router:</p>

<pre><code class="text BR2-WAN1">route-map RM-BGP-PREPEND-IN permit 10
 set as-path prepend last-as 4
route-map RM-BGP-PREPEND-OUT permit 10
 set as-path prepend 3 3 3 3
!
router bgp 3
neighbor 2.2.3.2 route-map RM-BGP-PREPEND-IN in
neighbor 2.2.3.2 route-map RM-BGP-PREPEND-OUT out
</code></pre>

<p>Now let&rsquo;s run the same test again:</p>

<pre><code class="bash Testing scenario #2 - success">ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 2
ok: [DC-CORE] =&gt; (item={'key': 'BR2-CORE', 'value': ['DC-WAN1', 'BR1-WAN1']})
ok: [BR1-WAN2] =&gt; (item={'key': 'BR2-WAN2', 'value': ['BR1-CORE', 'BR2-CORE']})
ok: [BR2-CORE] =&gt; (item={'key': 'DC-CORE', 'value': ['BR1-CORE', 'BR1-WAN1']})
ok: [BR2-WAN2] =&gt; (item={'key': 'BR1-WAN2', 'value': ['BR2-CORE', 'BR1-CORE']})
</code></pre>

<p>Looks better now. Let&rsquo;s move on.</p>

<h2>Testing the Backdoor link failure</h2>

<p>Next in order, backdoor link failure. First let&rsquo;s restore our primary WAN link first:
<code>text BR2-WAN1
BR2-WAN1#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
BR2-WAN1(config)#int eth 0/0
BR2-WAN1(config-if)#no shut
</code></p>

<p>And bring down the link between the two branches:
<code>text BR2-CORE
BR2-CORE#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
BR2-CORE(config)#int eth 0/2
BR2-CORE(config-if)#shut
</code></p>

<p>Run the third scenario:
<code>bash Testing scenario #3
root@netops:~/quickstart# ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 3
ok: [BR1-WAN2] =&gt; (item={'key': 'BR2-WAN2', 'value': ['BR1-WAN1', 'BR2-WAN1']})
ok: [BR2-WAN2] =&gt; (item={'key': 'BR1-WAN2', 'value': ['BR2-WAN1', 'BR1-WAN1']})
</code></p>

<p>Looking good. Now even the backup WAN routers traverse the primary WAN to talk to each other. Just as we expected.</p>

<h2>Testing of backup WAN</h2>

<p>Finally, let&rsquo;s see what would happen when both primary WAN and backdoor links go down. First, bring down the primary WAN link again:</p>

<pre><code class="text BR2-WAN1">BR2-WAN1#conf t
Enter configuration commands, one per line.  End with CNTL/Z.
BR2-WAN1(config)#int eth 0/0
BR2-WAN1(config-if)#shut
</code></pre>

<p>Run the last scenario:
<code>bash
ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 4
ok: [DC-CORE] =&gt; (item={'key': 'BR2-CORE', 'value': ['DC-WAN2', 'BR2-WAN2']})
ok: [BR1-CORE] =&gt; (item={'key': 'BR2-CORE', 'value': ['BR1-WAN2', 'BR2-WAN2']})
ok: [BR2-CORE] =&gt; (item={'key': 'DC-CORE', 'value': ['BR2-WAN2', 'DC-WAN2']})
ok: [BR2-CORE] =&gt; (item={'key': 'BR1-CORE', 'value': ['BR2-WAN2', 'BR1-WAN2']})
</code></p>

<p>All tests passed. Now the network at the new branch is behaving exactly as we expect it to.</p>

<h2>Conclusion</h2>

<p>The above scenario, of course, is a gross simplification of a real life, however the demonstrated approach can be applied to varied network topologies. The desired state may be achieved through not one but several red-green-refactor cycles. The benefit of using this approach is not only confidence that you haven&rsquo;t broken anything by fixing one particular failure condition scenario, but also for future growth and development, when new devices are added or traffic flows are modified, these same tests can be re-run to ensure that the agreed assumptions still hold.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Verifying TDD Scenarios]]></title>
    <link href="http://networkop.github.io/blog/2015/07/10/test-verification/"/>
    <updated>2015-07-10T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2015/07/10/test-verification</id>
    <content type="html"><![CDATA[<p>Now that Ansible has done all the information gathering for us it&rsquo;s time to finally make use of it. In this post I will show how to use Ansible to run traceroutes from and to the hosts defined in a test scenario and perform verification of the results of those tests. Should any of those tests fail, Ansible will provide a meaningful description of what exactly failed and why. While doing all this I&rsquo;ll introduce a couple of new Ansible features like conditional looping and interactive prompts.</p>

<!--more-->


<h2>TDD Playbook</h2>

<p>In order to run and verify tests I will create a separate playbook. It makes sense to separate it from the <a href="http://networkop.github.io/blog/2015/07/03/parser-modules/">previous playbook</a> simply because this time it will be used multiple times, while the information gathering playbook can only be run once. The new playbook will have to accomplish the following tasks:</p>

<ol>
<li>Select which scenario to test</li>
<li>Run tests as specified in that scenario</li>
<li>Parse test results</li>
<li>Verify that test results conform to the specification</li>
</ol>


<h2>Selecting test scenario</h2>

<p>Our <code>scenarios/all.txt</code> file contains multiple test scenarios each defined by a name. Each test scenario represent a certain state in the network, e.g. scenario #1 tests how the network behaves in a normal state with no outages or link failures, scenario #2 tests how traffic should be rerouted in the event of primary link failure. Inside each scenario there are one or more test steps each testing a behaviour of a particular traffic flow, e.g. traffic from router R1 to router R4 should traverse R2 followed by R3. Each steps contains keywords <code>From</code>, <code>To</code> and <code>Via</code> which identify  source, destination and transit routers. This is how a typical scenario file looks like.</p>

<p>{% codeblock lang:text ~/tdd_ansible/scenarios/all.txt %}
1. Testing of Primary Link
1.1 From R1 to R3 via R2
1.2 From R1 to R4 via R2, R3
1.3 From R2 to R4 via R3
1.4 From R1 to R2 via R2
2. Testing of Backup Link
2.1 From R1 to R3 via R4
2.2 From R1 to R2 via R4,R3
{% endcodeblock  %}</p>

<p>In the <a href="http://networkop.github.io/blog/2015/07/03/parser-modules/">previous post</a> I showed how to parse and store these scenarios in YAML dictionary in <code>group_vars/all.yml</code> file, which makes this information automatically available to any future playbooks. So in the new playbook all we need to do is let the user decide which scenario to test:</p>

<p>{% raw %}</p>

<h2>``` yaml ~/tdd_ansible/cisco_tdd.yml</h2>

<ul>
<li><p>name: Run traceroute commands
hosts: cisco-devices
gather_facts: false
remote_user: cisco</p>

<p>vars_prompt:</p>

<ul>
<li>name: scenario_num
prompt: &ldquo;Enter scenario number&rdquo;
default: &ldquo;1&rdquo;
private: no</li>
</ul>


<p>tasks:</p>

<ul>
<li>name: extracting scenario name and steps
set_fact:
  scenario_steps: &ldquo;{{ scenarios[scenario_num][1] }}&rdquo;
  scenario_name: &ldquo;{{ scenarios[scenario_num][0] }}&rdquo;
```
{% endraw  %}</li>
</ul>
</li>
</ul>


<p>This playbook contains a standard header followed by a <code>vars_prompt</code> section which prompts user to select a particular scenario number and stores the selection in <code>scenario_num</code> variable. The first task in the playbook extracts scenario name and steps from <code>scenarios</code> dictionary stored in <code>group_vars/all.yml</code> file and stores them in respective variables. Of course this task is optional and it&rsquo;s possible to reference the same data using full notation, however I prefer things to be more readable even if it leads to some inefficient memory use.</p>

<h2>Run test specified in scenario steps</h2>

<p>Now it&rsquo;s time to run traceroutes to see how the packets flow in the network. As we did in one of the <a href="http://networkop.github.io/blog/2015/06/24/ansible-intro/">previous posts</a> we&rsquo;ll use the <code>raw</code> module to run traceroutes. However this time, instead of running a full-mesh any-to-any traceroutes we&rsquo;ll only run them if they were defined in one of the test steps. Indeed, why would we run a traceroute between devices if we&rsquo;re not going to verify it? Ansible&rsquo;s conditionals will help us with that. For each of the hosts in <code>cisco-devices</code> group we&rsquo;ll look into scenario_steps dictionary and see if there were any tests defined and if there were, we&rsquo;ll run a traceroute to each of the destination hosts.</p>

<p>{% raw %}
<code>yaml ~/tdd_ansible/cisco_tdd.yml
    - name: run traceroutes as per the defined scenario steps
      raw: traceroute {{ hostvars[item.key]['ansible_ssh_host'] }} source Loopback0 probe 1 numeric
      when: scenario_steps[inventory_hostname] is defined
      with_dict: scenario_steps[inventory_hostname]|default({})
      register: trace_result
</code>
{% endraw  %}</p>

<p>When both a loop (<code>with_dict</code>) and a conditional (<code>when</code>) are defined in a task, Ansible does the looping first. That&rsquo;s why if a test scenario is not defined for a particular host (e.g. <code>R3</code>) the conditional check will fail and stop execution of the playbook. To overcome that we can use Ansible (Jinja) templates inside the <code>with_dict</code> loop. Appending <code>|default({})</code> will instruct Ansible create an empty dictionary in case <code>scenario_steps[inventory_hostname]</code> does not exist which will make conditional return <code>False</code> and skip this host altogether.</p>

<h2>Parse test results</h2>

<p>There&rsquo;s no silver bullet when it comes to parsing of the outcome of traceroute command. We&rsquo;ll have to use Python to traverse the textual output line by line looking for <code>msec</code> and storing all found IPs in a list.</p>

<p>{% codeblock lang:python ~/tdd_ansible/library/cisco_trace_parse.py %}
class TraceParse(object):</p>

<pre><code>def __init__(self, module):
    self.std_out = module.params['std_out']
    self.dest_host = module.params['dest_host']

def parse(self):
    result = dict()
    path = list()
    for line in self.std_out.split("\n"):
        if 'msec' in line:
            path.append(line.split()[1])
    result[self.dest_host] = path
    return result
</code></pre>

<p>def main():
    module = AnsibleModule(
        argument_spec=dict(
            std_out=dict(required=True, type=&lsquo;str&rsquo;),
            dest_host=dict(required=True, type=&lsquo;str&rsquo;)
        )
    )
    traceParser = TraceParse(module)
    result = traceParser.parse()
    module.exit_json(changed=False, ansible_facts=result)</p>

<h1>import module snippets</h1>

<p>from ansible.module_utils.basic import *
main()
{% endcodeblock  %}</p>

<p>The playbook task will run through each hosts' trace_results variable and pass it to the trace parse module.</p>

<p>{% raw %}
<code>yaml ~/tdd_ansible/cisco_tdd.yml
    - name: parse traceroute ouput
      cisco_trace_parse:
        dest_host: "{{ item.item.key }}"
        std_out: "{{ item.stdout }}"
      connection: local
      when: item.stdout is defined
      with_items: trace_result.results
</code>
{% endraw  %}</p>

<h2>Test verification</h2>

<p>Finally we need to compare the captured output with the scenario steps. This time all the information collected by Ansible in the previous tasks needs to be passed to a module.</p>

<p>{% raw %}
<code>yaml ~/tdd_ansible/cisco_tdd.yml
    - name: verify traceroutes against pre-defined scenarios
      cisco_tdd_verify:
        dest_host: "{{ item.key }}"
        src_host: "{{ inventory_hostname }}"
        scenario: "{{ scenario_steps }}"
        ip2host: "{{ ip2host }}"
        path: "{{ hostvars[inventory_hostname][item.key] }}"
        scenario_name: "{{ scenario_name }}"
      when: scenario_steps[inventory_hostname] is defined
      with_dict: scenario_steps[inventory_hostname]|default({})
      connection: local
</code>
{% endraw  %}</p>

<p>Ansible module contains a class with a single public method <code>compare</code>. The first thing it does is converts the list of IP addresses of transit devices into a list of hostnames. That&rsquo;s where the IP-to-Hostname dictionary created in the <a href="http://networkop.github.io/blog/2015/07/03/parser-modules/">previous playbook</a> is first used. IP address is used as a lookup key and the Hostname is extracted from the first element of the returned list (second element, the interface name, is currently unused). The private method <code>__validatepath</code> is used to confirm that devices listed after <code>Via</code> in a test scenario are present in the traceroute path in the specified order. If this verification fails, the whole module fails and the error message is passed back to Ansible playbook.</p>

<p>{% codeblock lang:python ~/tdd_ansible/library/cisco_tdd_verify.py %}
class ResultCompare(object):</p>

<pre><code>def __init__(self, module):
    self.dest_host = module.params['dest_host']
    self.src_host = module.params['src_host']
    self.trace_path = module.params['path']
    self.ref_scenario = module.params['scenario']
    self.ip2host = module.params['ip2host']
    self.scenario_name = module.params['scenario_name']

def compare(self):
    trace_path_new = list()
    for dev in self.trace_path:
        if dev in self.ip2host:
            trace_path_new.append(self.ip2host[dev][0])
        else:
            trace_path_new.append(dev)
    if self.src_host in self.ref_scenario:
        if self.dest_host in self.ref_scenario[self.src_host]:
            ref_path = self.ref_scenario[self.src_host][self.dest_host]
            if not self. __validatepath(trace_path_new):
                msg = "Failed scenario " + self.scenario_name +  ".\r\nTraceroute from " + self.src_host + " to " + self.dest_host + " has not traversed " + str(ref_path)
                msg += "\r\n Actual path taken: " + ' -&gt; '.join([self.src_host] + trace_path_new) + "\r\n"
                return 1, msg
    return 0, 'no error'

def __validatepath(self, path):
    index = 0
    for device in path:
        if device == self.ref_scenario[self.src_host][self.dest_host][index]:
            index += 1
            if index == len(self.ref_scenario[self.src_host][self.dest_host]):
                return True
    return False
</code></pre>

<p>def main():
    module = AnsibleModule(
        argument_spec=dict(
            dest_host=dict(required=True, type=&lsquo;str&rsquo;),
            src_host=dict(required=True, type=&lsquo;str&rsquo;),
            scenario=dict(required=True, type=&lsquo;dict&rsquo;),
            ip2host=dict(required=True, type=&lsquo;dict&rsquo;),
            path=dict(required=True, type=&lsquo;list&rsquo;),
            scenario_name=dict(required=True, type=&lsquo;str&rsquo;)
        )
    )
    comparator = ResultCompare(module)
    rc, error = comparator.compare()
    if rc != 0:
        module.fail_json(msg=error)
    else:
        module.exit_json(changed=False)</p>

<p>from ansible.module_utils.basic import *
main()
{% endcodeblock  %}</p>

<h2>TDD in action</h2>

<p>So let&rsquo;s finally see the whole thing action. First let&rsquo;s modify a <a href="http://networkop.github.io/blog/2015/06/17/dev-env-setup/">4-router topology</a> so that traffic from R1 to R4 is routed via R2 and R3 (a simple <code>delay 9999</code> on Ethernet0/1 will do). Now let&rsquo;s run the first scenario and verify that no errors are displayed.</p>

<p>{% codeblock lang:bash Scenario 1 successful %}
~/tdd_ansible# ansible-playbook cisco_tdd.yml
Enter scenario number [1]:</p>

<p>PLAY [Run traceroute commands] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>
&hellip;
PLAY RECAP </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>********************
R1                         : ok=4    changed=0    unreachable=0    failed=0
R2                         : ok=4    changed=0    unreachable=0    failed=0
R3                         : ok=2    changed=0    unreachable=0    failed=0
R4                         : ok=2    changed=0    unreachable=0    failed=0
{% endcodeblock  %}</p>

<p>Nothing much really, which is good, that means all scenarios were verified successfully. Now let&rsquo;s see how it fails. The easiest way is to run the tests from a second scenario, the one that assumes that the link between R1 and R2 failed and all the traffic is routed via R4.</p>

<p>{% codeblock lang:bash Scenario 2 failed %}
~/tdd_ansible# ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 2</p>

<p>PLAY [Run traceroute commands] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**************************
&hellip;
TASK: [verify traceroutes against pre-defined scenarios] </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>
skipping: [R2]
skipping: [R4]
failed: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R2&rsquo;, &lsquo;value&rsquo;: [&lsquo;R4&rsquo;, &lsquo;R3&rsquo;]}) => {&ldquo;failed&rdquo;: true, &ldquo;item&rdquo;: {&ldquo;key&rdquo;: &ldquo;R2&rdquo;, &ldquo;value&rdquo;: [&ldquo;R4&rdquo;, &ldquo;R3&rdquo;]}}
msg: Failed scenario Testing of Backup Link.
Traceroute from R1 to R2 has not traversed [&lsquo;R4&rsquo;, &lsquo;R3&rsquo;]
 Actual path taken: R1 -> R2</p>

<p>failed: [R3] => (item={&lsquo;key&rsquo;: &lsquo;R1&rsquo;, &lsquo;value&rsquo;: [&lsquo;R4&rsquo;]}) => {&ldquo;failed&rdquo;: true, &ldquo;item&rdquo;: {&ldquo;key&rdquo;: &ldquo;R1&rdquo;, &ldquo;value&rdquo;: [&ldquo;R4&rdquo;]}}
msg: Failed scenario Testing of Backup Link.
Traceroute from R3 to R1 has not traversed [&lsquo;R4&rsquo;]
 Actual path taken: R3 -> R2 -> R1</p>

<p>failed: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R3&rsquo;, &lsquo;value&rsquo;: [&lsquo;R4&rsquo;]}) => {&ldquo;failed&rdquo;: true, &ldquo;item&rdquo;: {&ldquo;key&rdquo;: &ldquo;R3&rdquo;, &ldquo;value&rdquo;: [&ldquo;R4&rdquo;]}}
msg: Failed scenario Testing of Backup Link.
Traceroute from R1 to R3 has not traversed [&lsquo;R4&rsquo;]
 Actual path taken: R1 -> R2 -> R3</p>

<p>PLAY RECAP ********************************************************************
           to retry, use: &ndash;limit @/root/cisco_tdd.retry</p>

<p>R1                         : ok=3    changed=0    unreachable=0    failed=1
R2                         : ok=2    changed=0    unreachable=0    failed=0
R3                         : ok=3    changed=0    unreachable=0    failed=1
R4                         : ok=2    changed=0    unreachable=0    failed=0
{% endcodeblock  %}</p>

<p>Here all 3 test steps within a scenario failed. Ansible displayed error messages passed down by our module, specifying the expected and the actual path.<br/>
Now if we simply shutdown Ethernet0/0 of R1 to simulate a link failure and re-run the same scenario all tests will succeed again.</p>

<p>{% codeblock lang:bash Scenario 2 successful %}
~/tdd_ansible# ansible-playbook cisco_tdd.yml
Enter scenario number [1]: 2</p>

<p>PLAY [Run traceroute commands] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>
&hellip;
PLAY RECAP </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>********************
R1                         : ok=4    changed=0    unreachable=0    failed=0
R2                         : ok=2    changed=0    unreachable=0    failed=0
R3                         : ok=4    changed=0    unreachable=0    failed=0
R4                         : ok=2    changed=0    unreachable=0    failed=0
{% endcodeblock  %}</p>

<p>So there it is, a working network TDD framework in action. I still haven&rsquo;t covered a lot of corner cases (e.g. when traceroute times out) and deployment scenarios (device with VRFs) but it should still work for a lot of scenarios and can be easily extended to cover those corner cases.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IP Address Information Collection With Custom Ansible Modules]]></title>
    <link href="http://networkop.github.io/blog/2015/07/03/parser-modules/"/>
    <updated>2015-07-03T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2015/07/03/parser-modules</id>
    <content type="html"><![CDATA[<p>Ansible has a very neat feature called &ldquo;fact gathering&rdquo;, which collects useful information from hosts prior to executing any of the tasks and makes this information available for use within those tasks. Unfortunately, this also relies on Python being available on the remote machine which doesn&rsquo;t work for Cisco IOS. In this post I&rsquo;ll show how to write a simple module which will collect IP address information from remote devices and store it in global variable for future use. I&rsquo;ll also show how to write a module which will convert our human-readable TDD scenarios into YAML structures. As always, full code repository is available on <a href="https://github.com/networkop/simple-cisco-tdd">Github</a></p>

<!--more-->


<h2>Cisco IOS IP fact gathering</h2>

<p>In order to recognise that a traceroute has traversed a certain device, without relying on DNS, we need to populate a local database mapping IP addresses to their respective devices. The resulting database (or YAML dictionary) needs to be stored in a file so that it can be read and used again by Ansible tasks doing the traceroute verification. In order to make it happen, we need to answer the following questions:</p>

<ul>
<li>How to get IP address information from each device?</li>
</ul>


<blockquote><p>The most straight-forward way is to capture the result of running something like <code>show ip interface brief</code> and parse the output. The assumption is that all devices are living in a non-overlapping IP address space (however it is possible to modify the examples to be vrf-aware).</p></blockquote>

<ul>
<li>Where to store the information?</li>
</ul>


<blockquote><p>Ideally, we would need a hash-like data structure (e.g. python dictionary) which will return a hostname when given a certain IP address. This data structure needs to be available to all hosts, however most of the variables in Ansible are host-specific. The only way to simulate a global variable in Ansible is to store all data in <code>group_vars/all.yml</code> file which is exactly what our module will do.</p></blockquote>

<ul>
<li>How will multiple processes write into a single file at the same time?</li>
</ul>


<blockquote><p>That&rsquo;s where Ansible&rsquo;s concurrency feature bites back. This is a well known computer science problem and the solution to this is to use <code>mutex</code>, however that&rsquo;s beyond what Ansible can do. In order to overcome that, I&rsquo;ll make Ansible do the tasks sequentially, which will dramatically slow things down for bigger environments. However, this task only needs to be run once, to collect the data, while all the other tasks can be run in parallel, in separate playbooks.</p></blockquote>

<h2>Developing Ansible playbook</h2>

<p>Our Ansible playbook will need to accomplish the following tasks:</p>

<ol>
<li>Capture the output <code>show ip interface brief</code> command</li>
<li>Parse the output capture in the previous step</li>
<li>Save the output in a <code>group_vars/all.yml</code> file</li>
</ol>


<p>All these tasks will need to be run sequentially on every host from <code>cisco-devices</code> group. To get the output from a Cisco device we&rsquo;ll use the <code>raw</code> module again. The other two tasks don&rsquo;t require connection to remote device and will be run on a localhost by the virtue of a <code>delegate_to: 127.0.0.1</code> option.</p>

<p>{% raw %}</p>

<h2>``` yaml ~/tdd_ansible/cisco-ip-collect.yml</h2>

<ul>
<li><p>name: Collect IP address data
hosts: cisco-devices
gather_facts: false
remote_user: cisco
serial: 1</p>

<p>tasks:</p>

<ul>
<li><p>name: capture show ip interface brief
raw: show ip interface brief | exclude unassigned
register: siib_text</p></li>
<li><p>name: parse the output of &ldquo;show ip interface brief&rdquo;
cisco_ip_intf_facts_collect: output_text=&ldquo;{{ siib_text.stdout }}&rdquo;
delegate_to: 127.0.0.1</p></li>
<li><p>name: combine ip address facts and save as a global variable
cisco_ip_intf_facts_combine:
  ipTable=&ldquo;{{ IPs }}&rdquo;
  hostname=&ldquo;{{ inventory_hostname }}&rdquo;
delegate_to: 127.0.0.1</p></li>
</ul>


<p>tags:</p>

<ul>
<li>collect
```
{% endraw %}</li>
</ul>
</li>
</ul>


<h2>Writing a custom Ansible module</h2>

<p>Ansible has an <a href="http://docs.ansible.com/developing_modules.html">official guide</a> on module development. A typical module will contain a header with license information along with module documentation and usage examples, a <code>main()</code> function processing the arguments passed to this module from Ansible and, of course, the actual code that implements module&rsquo;s logic. For the sake of brevity I will omit the header and some of the less important details in the code.</p>

<h2>Ansible module to parse command output</h2>

<p>This ansible module needs to extract IP address and, optionally, interface name from the output of <code>show ip interface brief</code> and store it in a python dictionary. The right way to examine the module code is from <code>main()</code> function. This function will contain a <code>module</code> variable (instance of AnsibleModule) which specifies all the arguments expected by this module and their type (the type will be converted to the appropriate python type). Text parser is implemented with a <code>SIIBparse</code> class whose only public method <code>parse()</code> will traverse the text line by line looking for interfaces with Line Protocol in <code>up</code> state, extract IP address (1st column), interface name (2nd column) and store the result in a python dictionary with IP address as the key and interface name as it&rsquo;s value.</p>

<p>{% codeblock lang:python ~/tdd_ansible/library/cisco_ip_intf_facts_collect.py %}
class SIIBparse(object):</p>

<pre><code>def __init__(self, module):
    self.output_text = module.params['output_text']
    self.ip2intf = dict()

def parse(self):
    for line in self.output_text.split("\n"):
        row = line.split()
        if len(row) &gt; 0 and row[-1] == 'up':
            ipAddress = row[1]
            intfName = row[0]
            self.ip2intf[ipAddress] = intfName
    result = {
        "IPs": self.ip2intf
    }
    rc = 0 if len(self.ip2intf) &gt; 0 else 1
    return rc, result
</code></pre>

<p>def main():
    module = AnsibleModule(
        argument_spec=dict(
            output_text=dict(required=True, type=&lsquo;str&rsquo;)
        )
    )
    siib = SIIBparse(module)
    rc, result = siib.parse()
    if rc != 0:
        module.fail_json(msg=&ldquo;Failed to parse. Incorrect input.&rdquo;)
    else:
        module.exit_json(changed=False, ansible_facts=result)</p>

<h1>import module snippets</h1>

<p>from ansible.module_utils.basic import *
main()
{% endcodeblock  %}</p>

<p>If information passed to the module in the argument was invalid, the module must fail with a meaningful message passed inside a <code>fail_json</code> method call. When parsing is complete, our module exits and the resulting data structure is passed back to Ansible variables with <code>ansible_facts</code> argument. Now all hosts can access it through variable called <code>IPs</code>.</p>

<h2>Ansible module to save IP address information</h2>

<p>The task of this module is to get all the information collected inside each hosts' <code>IPs</code> variables, combine it with devices' hostnames and save it in the <code>group_vars/all.yml</code> file. This module makes use of <a href="http://pyyaml.org/wiki/PyYAMLDocumentation">Python&rsquo;s yaml library</a>. Built-in class <code>FactUpdater</code> can read(), update() the contents and write() the global variable file defined in a <code>FILENAME</code> variable.</p>

<p>{% codeblock lang:python ~/tdd_ansible/library/cisco_ip_intf_facts_combine.py %}
import yaml
FILENAME=&ldquo;group_vars/all.yml&rdquo;</p>

<p>class FactUpdater(object):</p>

<pre><code>def __init__(self, module):
    self.ip2intf = module.params['ipTable']
    self.hostname = module.params['hostname']
    self.file_content = {'ip2host':{}}

def read(self):
    try:
        with open(FILENAME, 'r') as fileObj:
            self.file_content = yaml.load(fileObj)
    except:
        # in case there is no file - create it
        open(FILENAME, 'w').close()

def write(self):
    with open(FILENAME, 'w') as fileObj:
        yaml.safe_dump(self.file_content, fileObj, explicit_start=True, indent=2, allow_unicode=True)


def update(self):
    if not 'ip2host' in self.file_content:
        self.file_content['ip2host'] = dict()
    for ip in self.ip2intf:
        self.file_content['ip2host'][ip] = [self.hostname, self.ip2intf[ip]]
</code></pre>

<p>def main():
    module = AnsibleModule(
        argument_spec=dict(
            ipTable=dict(required=True, type=&lsquo;dict&rsquo;),
            hostname=dict(required=True, type=&lsquo;str&rsquo;),
        )
    )
    result = &lsquo;&rsquo;
    factUpdater = FactUpdater(module)
    try:
        factUpdater.read()
        factUpdater.update()
        factUpdater.write()
    except IOError as e:
        module.fail_json(msg=&ldquo;Unexpected error: &rdquo; + str(e))</p>

<pre><code>module.exit_json(changed=False)
</code></pre>

<h1>import module snippets</h1>

<p>from ansible.module_utils.basic import *
main()
{% endcodeblock  %}</p>

<p>This module only performs actions on local file and does not provide any output back to Ansible.</p>

<h2>Read and parse TDD scenarios</h2>

<p>Finally, since we&rsquo;re modifying Ansible global variable file, it would make sense to also update it with testing scenarios information. Technically, this steps doesn&rsquo;t need to be done in Ansible and could be done simply using Python or Bash scripts, but I&rsquo;ll still show it here to demonstrate two additional Ansible features. The first one is <code>local_action: module_name</code> which is a shorthand for specifying <code>module</code> with <code>delegate_to</code> option (see above). Second feature is <code>tags</code>, it allows to specify which play to run in playbook containing many of them. In our case one file <code>cisco-ip-collect.yml</code> will have two plays defined and will run both of them by default unless <code>--tag=scenario</code> or <code>--tag=collect</code> specifies the exact play.</p>

<p>{% raw %}
``` yaml ~/tdd_ansible/cisco-ip-collect.yml
- name: Parse and save scenarios
  hosts: localhost
  gather_facts: false</p>

<p>  tasks:</p>

<pre><code>- name: parse scenario file and save it in group_vars/all.yml
  local_action: cisco_scenarios_convert
</code></pre>

<p>  tags:
    - scenario
```
{% endraw  %}</p>

<p>This play has a single task which runs a single custom module. Before we proceed to the module let&rsquo;s see how a typical testing scenario file looks like.</p>

<p>{% codeblock lang:text ~/tdd_ansible/scenarios/all.txt %}
1. Testing of Primary Link
1.1 From R1 to R3 via R2
1.2 From R1 to R4 via R2, R3
2. Testing of Backup Link
2.1 From R1 to R3 via R4
2.2 From R1 to R2 via R4,R3
{% endcodeblock  %}</p>

<p>The file should be stored in a <code>scenarios/</code> directory and should have a name <code>all.txt</code>. This file contains a list of scenarios, each with its own name, and a list of test steps that need to be performed to validate a particular scenario. The parser for this file is a custom Python module which opens and reads the contents of <code>group_vars/all.yml</code> file, parses the scenarios file with the help of some ugly-looking regular expressions, and, finally, updates and saves the contents of Ansible group variable back to file.</p>

<p>{% codeblock lang:python ~/tdd_ansible/library/cisco_scenarios_convert.py %}
import yaml
import re
SCENARIO_FILE = &ldquo;scenarios/all.txt&rdquo;
GROUP_VAR_FILE = &ldquo;group_vars/all.yml&rdquo;</p>

<p>class ScenarioParser(object):</p>

<pre><code>def __init__(self):
    self.rc = 0
    self.storage = dict()
    self.file_content = dict()

def open(self):
   try:
        with open(GROUP_VAR_FILE, 'r') as fileObj:
            self.file_content = yaml.load(fileObj)
   except:
       open(GROUP_VAR_FILE, 'w').close()

def read(self):
    scenario_number = 0
    scenario_step   = 0
    scenario_name   = ''
    name_pattern = re.compile(r'^(\d+)\.?\s+(.*)')
    step_pattern = re.compile(r'.*[Ff][Rr][Oo][Mm]\s+([\d\w]+)\s+[Tt][Oo]\s+([\d\w]+)\s+[Vv][Ii][Aa]\s+([\d\w]+,*\s*[\d\w]+)*')
    with open(SCENARIO_FILE, 'r') as fileObj:
        for line in fileObj:
            if not line.startswith('#') and len(line) &gt; 3:
                name_match = name_pattern.match(line)
                step_match = step_pattern.match(line)
                if name_match:
                    scenario_number = name_match.group(1)
                    scenario_name   = name_match.group(2)
                    scenario_steps  = [scenario_name, {}]
                    if not scenario_number in self.storage:
                        self.storage[scenario_number] = scenario_steps
                    else:
                        scenario_steps = self.storage[scenario_number]
                elif step_match:
                    from_device = step_match.group(1)
                    to_device = step_match.group(2)
                    via = step_match.group(3)
                    via_devices = [device_name.strip() for device_name in via.split(',')]
                    if not scenario_number == 0 or not scenario_name:
                        if not from_device in scenario_steps[1]:
                            scenario_steps[1][from_device] = dict()
                        scenario_steps[1][from_device][to_device] = via_devices
                else:
                    self.rc = 1

def write(self):
   self.file_content['scenarios'] = self.storage
   if self.rc == 0:
       with open(GROUP_VAR_FILE, 'w+') as fileObj:
           yaml.safe_dump(self.file_content, fileObj, explicit_start=True, indent=3, allow_unicode=True)
</code></pre>

<p>def main():
    module = AnsibleModule(argument_spec=dict())
    parser = ScenarioParser()
    parser.open()
    parser.read()
    parser.write()
    if not parser.rc == 0:
        module.fail_json(msg=&ldquo;Failed to parse. Incorrect input.&rdquo;)
    else:
        module.exit_json(changed=False)</p>

<p>from ansible.module_utils.basic import *
main()
{% endcodeblock  %}</p>

<p>The biggest portion of code is the read() method of the parser which does the following:</p>

<ul>
<li>scans text file line by line ignoring lines starting with <code>#</code> and whose length is not enough to contain either a scenario name or scenario step</li>
<li>matches each line against pre-compiled regular expressions for scenario name or for scenario step (<a href="https://regex101.com/">a very helpful tool for regex testing</a>)</li>
<li>attempts to save the data in a Python dictionary whose keys are scenario numbers and whose values is a list consisting of a scenario name (1st element) and a dictionary with scenario steps (2nd element)</li>
</ul>


<p>The end result of running both ip address collection and scenarios conversion plays is Ansible group variable file that looks like this:</p>

<p>{% raw %}</p>

<h2>``` yaml  ~/tdd_ansible/library/group_vars/all.yml</h2>

<p>ip2host:
   10.0.0.1: [R1, Loopback0]
   10.0.0.2: [R2, Loopback0]
   10.0.0.3: [R3, Loopback0]
   10.0.0.4: [R4, Loopback0]
   12.12.12.1: [R1, Ethernet0/0]
   12.12.12.2: [R2, Ethernet0/0]
   14.14.14.1: [R1, Ethernet0/1]
   14.14.14.4: [R4, Ethernet0/1]
   192.168.247.25: [R1, Ethernet0/2]
   23.23.23.2: [R3, Ethernet0/0]
   34.34.34.3: [R3, Ethernet0/1]
   34.34.34.4: [R4, Ethernet0/0]
scenarios:
   &lsquo;1&rsquo;:
   - Testing of Primary Link
   -  R1:
         R2: [R2]
         R3: [R2]
         R4: [R2, R3]
      R2:
         R4: [R3]
   &lsquo;2&rsquo;:
   - Testing of Backup Link
   -  R1:
         R2: [R4, R3]
         R3: [R4]
      R3:
         R1: [R4]
```
{% endraw  %}</p>

<hr />

<p>The next post, final in a series, will show how to write an Ansible play to validate TDD scenarios and produce a meaningful error message in case it fails.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started With Ansible for Cisco IOS]]></title>
    <link href="http://networkop.github.io/blog/2015/06/24/ansible-intro/"/>
    <updated>2015-06-24T00:00:00+01:00</updated>
    <id>http://networkop.github.io/blog/2015/06/24/ansible-intro</id>
    <content type="html"><![CDATA[<p>Ansible is well-known for it&rsquo;s low entry threshold. All what&rsquo;s required to get started is just one inventory file. However Cisco IOS devices require special considerations.
Passwordless SSH RSA-based authentication is still a novelty and in most cases users are authenticated based on their passwords. Another problem is the lack of Python execution
environment on IOS devices, which seriously limits the choice of Ansible modules that can be used. In this post I will show how to setup Ansible
environment to control Cisco IOS devices</p>

<!--more-->


<h2>Ansible overview</h2>

<p>There&rsquo;s been a lot written about what Ansible is and what it was built to accomplish. I will just provide a brief summary of its features focusing on what we&rsquo;re gonna be using it for, leaving an in-depth explanation to the official <a href="http://docs.ansible.com/">Ansible documentation</a>.</p>

<ul>
<li>What is it?</li>
</ul>


<blockquote><p>Ansible is an IT automation and orchestration framework</p></blockquote>

<ul>
<li>What was it built to accomplish?</li>
</ul>


<blockquote><p>Ansible was designed to automate routine tasks like server/application deployment and configuration</p></blockquote>

<ul>
<li>How does it work?</li>
</ul>


<blockquote><p>It connects to several hosts at the same time and executes small programs called &ldquo;modules&rdquo; in the order specified in a file called &ldquo;playbook&rdquo;</p></blockquote>

<p>To build what we&rsquo;ve set out to accomplish I&rsquo;m gonna be using the latter feature. I am not gonna be using Ansible for system provisioning or service orchestration. Instead, I will be exploiting Ansible&rsquo;s ability to run multiple parallel connections to remote hosts, execute commands on them and return their result. Due to that, I will diverge from some of the <a href="https://docs.ansible.com/playbooks_best_practices.html">Ansible&rsquo;s best practices</a> of splitting functions into roles and I will use one flat playbook file segregating different functions with tags.</p>

<h2>Ansible configuration file</h2>

<p>Ansible configuration file <code>ansible.cfg</code> contains <a href="http://docs.ansible.com/intro_configuration.html">application-wide settings</a> like default timeouts, port numbers and other flags. The default Ansible configuration file is located in <code>/etc/ansible/</code> directory. However, instead of overwriting the defaults it is possible to create a configuration file in a local directory with only the settings that need to be overridden. To better work with Cisco devices the following settings will need to be modified:</p>

<ul>
<li>Default SSH library (transport) needs to be set to <code>paramiko</code> which is more stable than its alternative, OpenSSH, when working with Cisco IOS.</li>
<li>For a small project it is easier to maintain a local copy of inventory file which is configured with <code>hostfile</code> setting.</li>
<li>Strict SSH key checking is a MUST in every production environment, however, for development environment an exception can be made.</li>
<li>Default SSH timeout is decreased to 5 seconds reflecting a small size of the testing environment.</li>
</ul>


<p><code>bash ~/tdd_ansible/ansible.cfg
[defaults]
transport=paramiko
hostfile = ./myhosts
host_key_checking=False
timeout = 5
</code></p>

<h2>Inventory file</h2>

<p>Inventory contains the list of hosts to be managed by Ansible. Hosts are normally combined into groups (<code>cisco-devices</code> in our case) and Ansible performs actions on all hosts in the group in parallel.</p>

<p><code>bash ~/tdd_ansible/myhosts
[cisco-devices]
R1
R2
R3
R4
</code>
It is considered a <a href="https://docs.ansible.com/playbooks_best_practices.html#group-and-host-variables">best practice</a> to keep all variables in separate folders and files. We need to define additional host variables to let Ansible know which IP address to use to connect to a remote device. I will also add SSH password to a host variable file which is a VERY bad practice, however this will prevent me from typing password every time I run a playbook. If I ever did this in production, I&rsquo;d add host variables directory to <code>.gitignore</code> file so that it doesn&rsquo;t get uploaded to Github. Host variables files must follow YAML formatting, must be stored in a <code>./host_vars</code> directory and must match the name of the host they are being assigned to.</p>

<h2>``` yaml ~/tdd_ansible/host_vars/R1</h2>

<p>ansible_ssh_host: 10.0.0.1
ansible_ssh_pass: cisco
```</p>

<p>Similar files need to be created for R2, R3 and R4.</p>

<h2>Run a test traceroute commands</h2>

<p>Now it is time to finally see Ansible in action. Let&rsquo;s first see if we can run a standalone traceroute command. I will manually define SSH username with <code>-u</code> flag and use a module called <code>raw</code> passing traceroute command as an argument with <code>-a</code> option.</p>

<pre><code class="bash Ad-hoc traceroute command">$ ansible cisco-devices -u cisco -m raw -a "traceroute 10.0.0.4 source Loopback0 probe 1 numeric"
SSH password:
R1 | success | rc=0 &gt;&gt;

Type escape sequence to abort.
Tracing the route to 10.0.0.4
VRF info: (vrf in name/id, vrf out name/id)
  1 14.14.14.4 0 msec *  0 msec

R2 | success | rc=0 &gt;&gt;

Type escape sequence to abort.
Tracing the route to 10.0.0.4
VRF info: (vrf in name/id, vrf out name/id)
  1 12.12.12.1 0 msec 0 msec 0 msec
  2  *  *
    14.14.14.4 0 msec

R3 | success | rc=0 &gt;&gt;

Type escape sequence to abort.
Tracing the route to 10.0.0.4
VRF info: (vrf in name/id, vrf out name/id)
  1 34.34.34.4 0 msec 0 msec *

R4 | success | rc=0 &gt;&gt;

Type escape sequence to abort.
Tracing the route to 10.0.0.4
VRF info: (vrf in name/id, vrf out name/id)
  1 10.0.0.4 0 msec 0 msec *
</code></pre>

<p>Ansible ad-hoc commands are a good way to quickly test something out and learn how things work. Next step would be to create a playbook file which will contain several of those commands in a more structured way. Playbooks use YAML syntax and follow strict formatting rules. At the top of the file there&rsquo;s a name of the play along with the target hosts group. Following that are a list of tasks, each of which calls its own module and passes arguments to it. In this example playbook does the following:</p>

<ol>
<li>Defines a <code>loopbacks</code> variable which stores in a hash a list of devices along with their loopback IP addresses.</li>
<li>Uses <code>raw</code> module to run traceroute commands. This is the only module that doesn&rsquo;t require Python to be installed on a target machine.</li>
<li>For each host in <code>cisco-devices</code> group runs traceroute to every other hosts' loopback IP</li>
<li>Stores the result in a <code>trace_result</code> variable</li>
</ol>


<p>{% raw %}</p>

<h2>``` yaml ~/tdd_ansible/cisco-trace-run.yml</h2>

<ul>
<li><p>name: Run traceroute commands
hosts: cisco-devices
gather_facts: false
remote_user: cisco</p>

<p>vars:
  loopbacks: {
  &ldquo;R1&rdquo;: &ldquo;10.0.0.1&rdquo;,
  &ldquo;R2&rdquo;: &ldquo;10.0.0.2&rdquo;,
  &ldquo;R3&rdquo;: &ldquo;10.0.0.3&rdquo;,
  &ldquo;R4&rdquo;: &ldquo;10.0.0.4&rdquo;,
  }</p>

<p>tasks:</p>

<ul>
<li>name: run traceroute to every other host
raw: traceroute {{ item.value }} source Loopback0 probe 1 numeric
when: item.key != inventory_hostname
with_dict: loopbacks
register: trace_result</li>
</ul>
</li>
</ul>


<h1>- name: Debug registered variables</h1>

<h1>debug: var=trace_result</h1>

<pre><code>{% endraw %}

In this Playbook I use several useful Ansible features:

* [Variables defined in playbooks](https://docs.ansible.com/playbooks_variables.html#variables-defined-in-a-playbook)
* [Looping over hashes](https://docs.ansible.com/playbooks_loops.html#looping-over-hashes)
* [Conditionals](https://docs.ansible.com/playbooks_conditionals.html)
* [Registered variables](https://docs.ansible.com/playbooks_variables.html#registered-variables)

The end result of this task is that traceroute is run 12 times - one time from each of the hosts to each other host except for when source and destination are equal.
</code></pre>

<p>$ ansible-playbook cisco-trace-run.yml</p>

<p>PLAY [Run traceroute commands] ************************************************</p>

<p>TASK: [run traceroute to every other host] ************************************
skipping: [R4] => (item={&lsquo;key&rsquo;: &lsquo;R4&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.4&rsquo;})
ok: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R4&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.4&rsquo;})
skipping: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R1&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.1&rsquo;})
ok: [R3] => (item={&lsquo;key&rsquo;: &lsquo;R4&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.4&rsquo;})
ok: [R4] => (item={&lsquo;key&rsquo;: &lsquo;R1&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.1&rsquo;})
ok: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R2&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.2&rsquo;})
ok: [R3] => (item={&lsquo;key&rsquo;: &lsquo;R1&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.1&rsquo;})
ok: [R1] => (item={&lsquo;key&rsquo;: &lsquo;R3&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.3&rsquo;})
ok: [R3] => (item={&lsquo;key&rsquo;: &lsquo;R2&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.2&rsquo;})
skipping: [R3] => (item={&lsquo;key&rsquo;: &lsquo;R3&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.3&rsquo;})
ok: [R2] => (item={&lsquo;key&rsquo;: &lsquo;R4&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.4&rsquo;})
ok: [R2] => (item={&lsquo;key&rsquo;: &lsquo;R1&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.1&rsquo;})
skipping: [R2] => (item={&lsquo;key&rsquo;: &lsquo;R2&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.2&rsquo;})
ok: [R4] => (item={&lsquo;key&rsquo;: &lsquo;R2&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.2&rsquo;})
ok: [R2] => (item={&lsquo;key&rsquo;: &lsquo;R3&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.3&rsquo;})
ok: [R4] => (item={&lsquo;key&rsquo;: &lsquo;R3&rsquo;, &lsquo;value&rsquo;: &lsquo;10.0.0.3&rsquo;})</p>

<p>PLAY RECAP ********************************************************************
R1                         : ok=1    changed=0    unreachable=0    failed=0
R2                         : ok=1    changed=0    unreachable=0    failed=0
R3                         : ok=1    changed=0    unreachable=0    failed=0
R4                         : ok=1    changed=0    unreachable=0    failed=0</p>

<p>```</p>

<p>The above shows that all 12 tasks were completed successfully, meaning the command was executed and result was stored in a registered variable. To view the actual output of <code>traceroute</code> commands uncomment the two debug lines at the end of the playbook and rerun it.</p>

<hr />

<p>Now that the goal of running commands on multiple devices in parallel is achieved, the next step would be to decide how to make use of the received output. In the next posts I will attempt to tackle the following problems:</p>

<ul>
<li>Parse textual output of traceroute command and extract transit IP addresses.</li>
<li>Find a way to convert these transit IP addresses into hostnames without relying on DNS.</li>
<li>Verify TDD scenarios against traceroute outputs and produce an intelligible result of this verification.</li>
</ul>

]]></content>
  </entry>
  
</feed>
